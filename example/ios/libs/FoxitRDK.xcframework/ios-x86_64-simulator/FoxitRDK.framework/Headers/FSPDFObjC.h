/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#import <CoreGraphics/CoreGraphics.h>

@class FSNote;
@class FSBitmap;
@class FSPDFPage;
@class FSReflowPage;
@class FSPDFDoc;
@class FSAnnot;
@class FSLayerContext;
@class FSFileSpec;
@class FSMarkup;
@class FSRedact;
@class FSPopup;
@class FSField;
@class FSControl;
@class FSPDFDictionary;
@class FSStdEncryptData;
@class FSDRMEncryptData;
@class FSCustomEncryptData;
@class FSCertificateEncryptData;
@class FSRMSEncryptData;
@class FSPDFObject;
@class FSPDFNameTree;
@class FSReadingBookmark;
@class FSSignature;
@class FSSecurityHandler;
@class FSLayerNode;
@class FSLayerPrintData;
@class FSGraphicsObject;
@class FSPDFArray;
@class FSPDFStream;
@class FSWatermarkSettings;
@class FSWatermarkTextProperties;
@class FSTextObject;
@class FSXFAWidget;
@class FSXFAPage;
@class FSForm;
@class FSRectI;
@class FSRectF;
@class FSMatrix2D;
@class FSGraphicsObjects;
@class FSGraphicsObjectArray;
@class FSFormXObject;
@class FSImageObject;
@class FSPathObject;
@class FSShadingObject;
@class FSEnvelope;
@class FSTimer;
@class FSScreen;
@class FSMediaPlayer;
@class FSTimeStampServer;
@class FSRevocationArrayInfo;
@class FSSignatureVerifyResult;
@class FSSignatureVerifyResultArray;
@class FSOptimizerSettings;
@class FSColor;
@class FSTextState;
@class FSFillSignObject;
@class FSPortfolio;
@class FSSchemaField;
@class FSSchemaFieldArray;
@class FSPortfolioNode;
@class FSPortfolioNodeArray;
@class FSPortfolioFileNode;
@class FSPortfolioFolderNode;
@class FSPSInkPointData;
@class FSFieldArray;

@protocol FSPauseCallback;
@protocol FSFileReaderCallback;
@protocol FSStreamCallback;
@protocol FSFileWriterCallback;
@protocol FSActionCallback;
@protocol FSIconProviderCallback;
@protocol FSNotifierCallback;
@protocol FSDocEventCallback;
@protocol FSAsyncReaderCallback;
@protocol FSFillerAssistCallback;
@protocol FSSearchCallback;
@protocol FSSearchCancelCallback;
@protocol FSPSICallback;
@protocol FSSecurityCallback;
@protocol FSCertificateSecurityCallback;
@protocol FSDRMSecurityCallback;
@protocol FSCustomSecurityCallback;
@protocol FSRMSSecurityCallback;
@protocol FSSignatureCallback;
@protocol FSAppProviderCallback;
@protocol FSDocProviderCallback;
@protocol FSRevocationCallback;
@protocol FSTrustedCertStoreCallback;
@protocol FSFontMapperCallback;
@protocol FSAnnotationSummaryCallback;
@protocol FSTimeStampCallback;


#import <Foundation/Foundation.h>
                
typedef NS_ENUM(NSInteger, FSPDFPageSize);
typedef NS_ENUM(NSInteger, FSAnnotAppearanceType);
typedef NS_ENUM(NSInteger, FSSignatureSignatureType);
typedef NS_ENUM(NSInteger, FSGraphicsObjectBlendMode);



#ifdef __cplusplus
extern "C" {
#endif

@interface SWIGTYPE_p_void : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

@end

@interface FSBasicArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

-(void)dealloc;

@end



@interface FSPoint : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getX) int x;
@property (nonatomic, getter=getY) int y;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithX: (int)X Y: (int)Y;
-(id)initWithOther: (FSPoint*)other;
-(void)set: (int)x y: (int)y;
-(void)add: (int)x y: (int)y;
-(void)subtract: (int)x y: (int)y;
-(void)reset;
-(void)dealloc;

@end

@interface FSPointF : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getX) float x;
@property (nonatomic, getter=getY) float y;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithX: (float)X Y: (float)Y;
-(id)initWithOther: (FSPointF*)other;
-(void)set: (float)x y: (float)y;
-(void)add: (float)x y: (float)y;
-(void)subtract: (float)x y: (float)y;
-(void)reset;
-(void)dealloc;

@end

@interface FSRectFArray : FSBasicArray
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSRectFArray*)other;
-(int)getSize;
-(int)getUpperBound;
-(BOOL)setSize: (int)nNewSize nGrowBy: (int)nGrowBy;
-(void)removeAll;
-(FSRectF*)getAt: (int)nIndex;
-(BOOL)setAt: (int)nIndex newElement: (FSRectF*)newElement;
-(BOOL)setAtGrow: (int)nIndex newElement: (FSRectF*)newElement;
-(BOOL)add: (FSRectF*)newElement;
-(BOOL)insertAt: (int)nIndex newElement: (FSRectF*)newElement nCount: (int)nCount;
-(BOOL)removeAt: (int)nIndex nCount: (int)nCount;
-(int)find: (FSRectF*)data iStart: (int)iStart;

-(void)dealloc;

@end

@interface FSPointFArray : FSBasicArray
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSPointFArray*)other;
-(int)getSize;
-(int)getUpperBound;
-(BOOL)setSize: (int)nNewSize nGrowBy: (int)nGrowBy;
-(void)removeAll;
-(FSPointF*)getAt: (int)nIndex;
-(BOOL)setAt: (int)nIndex newElement: (FSPointF*)newElement;
-(BOOL)setAtGrow: (int)nIndex newElement: (FSPointF*)newElement;
-(BOOL)add: (FSPointF*)newElement;
-(BOOL)insertAt: (int)nIndex newElement: (FSPointF*)newElement nCount: (int)nCount;
-(BOOL)removeAt: (int)nIndex nCount: (int)nCount;
-(int)find: (FSPointF*)data iStart: (int)iStart;

-(void)dealloc;

@end

@interface FSFloatArray : FSBasicArray
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSFloatArray*)other;
-(int)getSize;
-(int)getUpperBound;
-(BOOL)setSize: (int)nNewSize nGrowBy: (int)nGrowBy;
-(void)removeAll;
-(float)getAt: (int)nIndex;
-(BOOL)setAt: (int)nIndex newElement: (float)newElement;
-(BOOL)setAtGrow: (int)nIndex newElement: (float)newElement;
-(BOOL)add: (float)newElement;
-(BOOL)insertAt: (int)nIndex newElement: (float)newElement nCount: (int)nCount;
-(BOOL)removeAt: (int)nIndex nCount: (int)nCount;
-(int)find: (float)data iStart: (int)iStart;

-(void)dealloc;

@end

@interface FSInt32Array : FSBasicArray
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSInt32Array*)other;
-(int)getSize;
-(int)getUpperBound;
-(BOOL)setSize: (int)nNewSize nGrowBy: (int)nGrowBy;
-(void)removeAll;
-(int)getAt: (int)nIndex;
-(BOOL)setAt: (int)nIndex newElement: (int)newElement;
-(BOOL)setAtGrow: (int)nIndex newElement: (int)newElement;
-(BOOL)add: (int)newElement;
-(BOOL)insertAt: (int)nIndex newElement: (int)newElement nCount: (int)nCount;
-(BOOL)removeAt: (int)nIndex nCount: (int)nCount;
-(int)find: (int)data iStart: (int)iStart;

-(void)dealloc;

@end

@interface FSRectI : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getLeft) int left;
@property (nonatomic, getter=getTop) int top;
@property (nonatomic, getter=getRight) int right;
@property (nonatomic, getter=getBottom) int bottom;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithLeft1: (int)left1 top1: (int)top1 right1: (int)right1 bottom1: (int)bottom1;
-(int)width;
-(int)height;
-(BOOL)isEmpty;
-(void)normalize;
-(void)intersect: (FSRectI*)src;
-(void)union: (FSRectI*)other_rect;
-(void)offset: (int)dx dy: (int)dy;
-(BOOL)contains: (FSRectI*)other_rect;
-(BOOL)valid;

-(void)dealloc;

@end

@interface FSRectF : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getLeft) float left;
@property (nonatomic, getter=getRight) float right;
@property (nonatomic, getter=getBottom) float bottom;
@property (nonatomic, getter=getTop) float top;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithLeft1: (float)left1 bottom1: (float)bottom1 right1: (float)right1 top1: (float)top1;
-(BOOL)isEmpty;
-(void)normalize;
-(void)reset;
-(BOOL)contains: (FSRectF*)other_rect;
-(void)transform: (FSMatrix2D*)pMatrix;
-(void)intersect: (FSRectF*)other_rect;
-(void)union: (FSRectF*)other_rect;
-(FSRectI*)getInnerRect;
-(FSRectI*)getOuterRect;
-(FSRectI*)getClosestRect;
-(void)initRect: (float)x y: (float)y;
-(void)updateRect: (float)x y: (float)y;
-(float)width;
-(float)height;
-(void)inflate: (float)x y: (float)y;
-(void)deflate: (float)x y: (float)y;
-(void)translate: (float)e f: (float)f;
+(FSRectF*)getBBox: (FSPointF*)pPoints nPoints: (int)nPoints;
+(BOOL)IsRectAdjacent: (FSRectF*)rect1 rect2: (FSRectF*)rect2 alignmentTolerance: (float)alignmentTolerance distanceTolerance: (float)distanceTolerance direction: (int)direction;

-(void)dealloc;

@end

@interface FSMatrix2D : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getA) float a;
@property (nonatomic, getter=getB) float b;
@property (nonatomic, getter=getC) float c;
@property (nonatomic, getter=getD) float d;
@property (nonatomic, getter=getE) float e;
@property (nonatomic, getter=getF) float f;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithA1: (float)a1 b1: (float)b1 c1: (float)c1 d1: (float)d1 e1: (float)e1 f1: (float)f1;
-(void)set: (float)a b: (float)b c: (float)c d: (float)d e: (float)e f: (float)f;
-(void)setIdentity;
-(void)setReverse: (FSMatrix2D*)m;
-(void)concat: (float)a b: (float)b c: (float)c d: (float)d e: (float)e f: (float)f bPrepended: (BOOL)bPrepended;
-(void)concatInverse: (FSMatrix2D*)m bPrepended: (BOOL)bPrepended;
-(void)reset;
-(void)copy: (FSMatrix2D*)m;
-(BOOL)isIdentity;
-(BOOL)isInvertible;
-(BOOL)is90Rotated;
-(BOOL)isScaled;
-(void)translate: (float)x y: (float)y bPrepended: (BOOL)bPrepended;
-(void)translateI: (int)x y: (int)y bPrepended: (BOOL)bPrepended;
-(void)scale: (float)sx sy: (float)sy bPrepended: (BOOL)bPrepended;
-(void)rotate: (float)fRadian bPrepended: (BOOL)bPrepended;
-(void)rotateAt: (float)fRadian x: (float)x y: (float)y bPrepended: (BOOL)bPrepended;
-(void)shear: (float)fAlphaRadian fBetaRadian: (float)fBetaRadian bPrepended: (BOOL)bPrepended;
-(void)matchRect: (FSRectF*)dest src: (FSRectF*)src;
-(float)getXUnit;
-(float)getYUnit;
-(FSRectF*)getUnitRect;
-(float)getUnitArea;
-(float)transformXDistance: (float)dx;
-(float)transformYDistance: (float)dy;
-(float)transformDistance: (float)dx dy: (float)dy;
-(void)transformPoint: (float *)x y: (float *)y;
-(void)transformRect: (FSRectF*)rect;
-(void)dealloc;

@end







typedef NS_ENUM(NSInteger, FSErrorCode) {
  FSErrSuccess = 0,
  FSErrFile = 1,
  FSErrFormat = 2,
  FSErrPassword = 3,
  FSErrHandle = 4,
  FSErrCertificate = 5,
  FSErrUnknown = 6,
  FSErrInvalidLicense = 7,
  FSErrParam = 8,
  FSErrUnsupported = 9,
  FSErrOutOfMemory = 10,
  FSErrSecurityHandler = 11,
  FSErrNotParsed = 12,
  FSErrNotFound = 13,
  FSErrInvalidType = 14,
  FSErrConflict = 15,
  FSErrUnknownState = 16,
  FSErrDataNotReady = 17,
  FSErrInvalidData = 18,
  FSErrXFALoadError = 19,
  FSErrNotLoaded = 20,
  FSErrInvalidState = 21,
  FSErrNotCDRM = 22,
  FSErrCanNotConnectToServer = 23,
  FSErrInvalidUserToken = 24,
  FSErrNoRights = 25,
  FSErrRightsExpired = 26,
  FSErrDeviceLimitation = 27,
  FSErrCanNotRemoveSecurityFromServer = 28,
  FSErrCanNotGetACL = 29,
  FSErrCanNotSetACL = 30,
  FSErrIsAlreadyCPDF = 31,
  FSErrIsAlreadyCDRM = 32,
  FSErrCanNotUploadDocInfo = 33,
  FSErrCanNotUploadCDRMInfo = 34,
  FSErrInvalidWrapper = 35,
  FSErrCanNotGetClientID = 36,
  FSErrCanNotGetUserToken = 37,
  FSErrInvalidACL = 38,
  FSErrInvalidClientID = 39,
  FSErrOCREngineNotInit = 40,
  FSErrDiskFull = 41,
  FSErrOCRTrialIsEnd = 42,
  FSErrFilePathNotExist = 43,
  FSErrComplianceEngineNotInit = 44,
  FSErrComplianceEngineInvalidUnlockCode = 45,
  FSErrComplianceEngineInitFailed = 46,
  FSErrTimeStampServerMgrNotInit = 47,
  FSErrLTVVerifyModeNotSet = 48,
  FSErrLTVRevocationCallbackNotSet = 49,
  FSErrLTVCannotSwitchVersion = 50,
  FSErrLTVCannotCheckDTS = 51,
  FSErrLTVCannotLoadDSS = 52,
  FSErrLTVCannotLoadDTS = 53,
  FSErrNeedSigned = 54,
  FSErrComplianceResourceFile = 55,
  FSErrTimeStampServerMgrNoDefaltServer = 56,
  FSErrDefaultTimeStampServer = 57,
  FSErrNoConnectedPDFModuleRight = 58,
  FSErrNoXFAModuleRight = 59,
  FSErrNoRedactionModuleRight = 60,
  FSErrNoRMSModuleRight = 61,
  FSErrNoOCRModuleRight = 62,
  FSErrNoComparisonModuleRight = 63,
  FSErrNoComplianceModuleRight = 64,
  FSErrNoOptimizerModuleRight = 65,
  FSErrNoConversionModuleRight = 66,
  FSErrOfficeComNotInit = 67,
  FSErrNoMicroOfficeInstalled = 68,
  FSErrExcelHasNoContent = 69,
  FSErrNoLayoutRecognitionModuleRight = 70,
  FSErrWPSEngineNotFound = 71
};

@interface FSBase : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

-(void)dealloc;

@end

@interface FSDateTime : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getYear) unsigned short year;
@property (nonatomic, getter=getMonth) unsigned short month;
@property (nonatomic, getter=getDay) unsigned short day;
@property (nonatomic, getter=getHour) unsigned short hour;
@property (nonatomic, getter=getMinute) unsigned short minute;
@property (nonatomic, getter=getSecond) unsigned short second;
@property (nonatomic, getter=getMilliseconds) unsigned short milliseconds;
@property (nonatomic, getter=getUtc_hour_offset) short utc_hour_offset;
@property (nonatomic, getter=getUtc_minute_offset) unsigned short utc_minute_offset;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSDateTime*)getUTCTime;
+(FSDateTime*)getLocalTime;
-(id)initWithYear: (unsigned short)year month: (unsigned short)month day: (unsigned short)day hour: (unsigned short)hour minute: (unsigned short)minute second: (unsigned short)second milliseconds: (unsigned short)milliseconds utc_hour_offset: (short)utc_hour_offset utc_minute_offset: (unsigned short)utc_minute_offset;
-(id)init;
-(id)initWithDt: (FSDateTime*)dt;
-(void)set: (unsigned short)year month: (unsigned short)month day: (unsigned short)day hour: (unsigned short)hour minute: (unsigned short)minute second: (unsigned short)second milliseconds: (unsigned short)milliseconds utc_hour_offset: (short)utc_hour_offset utc_minute_offset: (unsigned short)utc_minute_offset;
-(BOOL)isValid;
-(FSDateTime*)toLocalTime;
-(FSDateTime*)toUTCTime;
-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSRotation) {
  FSRotation0 = 0,
  FSRotation90 = 1,
  FSRotation180 = 2,
  FSRotation270 = 3,
  FSRotationUnknown = 4
};

typedef NS_ENUM(NSInteger, FSAlignment) {
  FSAlignmentLeft = 0,
  FSAlignmentCenter = 1,
  FSAlignmentRight = 2
};

typedef NS_ENUM(NSInteger, FSFillMode) {
  FSFillModeNone = 0,
  FSFillModeAlternate = 1,
  FSFillModeWinding = 2
};

typedef NS_ENUM(NSInteger, FSPosition) {
  FSPosTopLeft = 0,
  FSPosTopCenter = 1,
  FSPosTopRight = 2,
  FSPosCenterLeft = 3,
  FSPosCenter = 4,
  FSPosCenterRight = 5,
  FSPosBottomLeft = 6,
  FSPosBottomCenter = 7,
  FSPosBottomRight = 8
};

typedef NS_ENUM(NSInteger, FSModuleName) {
  FSModuleNameConnectedPDF = 1,
  FSModuleNameXFA = 2,
  FSModuleNameRedaction = 3,
  FSModuleNameRMS = 4,
  FSModuleNameOCR = 5,
  FSModuleNameComparison = 6,
  FSModuleNameCompliance = 7,
  FSModuleNameOptimizer = 8,
  FSModuleNameConversion = 9,
  FSModuleNameLayoutRecognition = 10
};

typedef NS_ENUM(NSInteger, FSColorSpaceType) {
  FSColorSpaceInvalid = 0,
  FSColorSpaceDeviceGray = 1,
  FSColorSpaceDeviceRGB = 2,
  FSColorSpaceDeviceCMYK = 3,
  FSColorSpaceCalGray = 4,
  FSColorSpaceCalRGB = 5,
  FSColorSpaceLab = 6,
  FSColorSpaceSeparation = 8,
  FSColorSpaceDeviceN = 9,
  FSColorSpacePattern = 11,
  FSColorSpaceICCBasedDeviceGray = 12,
  FSColorSpaceICCBasedDeviceRGB = 13,
  FSColorSpaceICCBasedDeviceCMYK = 14
};

typedef NS_ENUM(NSInteger, FSLocaleID) {
  FSLocaleIDUnspecified = 0,
  FSLocaleIDHongKong = 1,
  FSLocaleIDTaiwan = 2,
  FSLocaleIDNetherlands = 3,
  FSLocaleIDFrance = 4,
  FSLocaleIDGermany = 5,
  FSLocaleIDItaly = 6,
  FSLocaleIDKorea = 7,
  FSLocaleIDJapan = 8
};

@interface FSCodec : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(NSData *)base64Encode: (NSData *)buffer;
+(NSData *)base64Decode: (NSData *)buffer;
+(NSData *)flateCompress: (NSData *)buffer;
+(NSData *)flateDecompress: (NSData *)buffer;
-(id)init;

-(void)dealloc;

@end



typedef NS_ENUM(NSInteger, FSProgressiveState) {
  FSProgressiveError = 0,
  FSProgressiveToBeContinued = 1,
  FSProgressiveFinished = 2
};

@interface FSProgressive : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSProgressive*)other;
-(FSProgressiveState)resume;
-(int)getRateOfProgress;

-(void)dealloc;

@end

@interface FSRenderConfig : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getGraphics_objs_count_in_one_step) int graphics_objs_count_in_one_step;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithGraphics_objs_count_in_one_step: (int)graphics_objs_count_in_one_step;
-(void)set: (int)graphics_objs_count_in_one_step;
-(void)dealloc;

@end

@interface FSLibrary : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSErrorCode)initialize: (NSString *)sn key: (NSString *)key;
+(FSErrorCode)reinitialize;
+(void)destroy;
+(BOOL)hasModuleLicenseRight: (FSModuleName)module_name;
+(NSString *)getVersion;
+(BOOL)setCacheSize: (unsigned int)size;
+(BOOL)enableJavaScript: (BOOL)enable_javascript;
+(BOOL)setAnnotIconProviderCallback: (id<FSIconProviderCallback>)annot_icon_provider;
+(BOOL)setNotifierCallback: (id<FSNotifierCallback>)notifier;
+(BOOL)setActionCallback: (id<FSActionCallback>)action_callback;
+(BOOL)setDocEventCallback: (id<FSDocEventCallback>)callback;
+(BOOL)registerSignatureCallback: (NSString *)filter sub_filter: (NSString *)sub_filter signature_callback: (id<FSSignatureCallback>)signature_callback;
+(BOOL)registerSecurityCallback: (NSString *)filter callback: (id<FSSecurityCallback>)callback;
+(BOOL)unregisterSecurityCallback: (NSString *)filter;
+(BOOL)setTimeStampCallback: (id<FSTimeStampCallback>)timestamp_callback;
+(BOOL)isFipsMode;
+(void)registerXFAAppProviderCallback: (id<FSAppProviderCallback>)callback;
+(void)setRenderTextGamma: (float)gamma;
+(void)setLogFile: (NSString *)log_file_path;
+(BOOL)setFontMapperCallback: (id<FSFontMapperCallback>)callback;
+(void)setDefaultICCProfilesPath: (NSString *)icc_profile_folder_path;
+(FSRenderConfig*)getRenderConfig;
+(void)setRenderConfig: (FSRenderConfig*)render_config;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSGraphStateLineCapStyle) {
  FSGraphStateLineCapButt = 0,
  FSGraphStateLineCapRound = 1,
  FSGraphStateLineCapSquare = 2
};

typedef NS_ENUM(NSInteger, FSGraphStateLineJoinStyle) {
  FSGraphStateLineJoinMiter = 0,
  FSGraphStateLineJoinRound = 1,
  FSGraphStateLineJoinBevel = 2
};

@interface FSGraphState : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getLine_width) float line_width;
@property (nonatomic, getter=getLine_join) FSGraphStateLineJoinStyle line_join;
@property (nonatomic, getter=getMiter_limit) float miter_limit;
@property (nonatomic, getter=getLine_cap) FSGraphStateLineCapStyle line_cap;
@property (nonatomic, getter=getDash_phase) float dash_phase;
@property (nonatomic, copy, getter=getDashes) FSFloatArray* dashes;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithLine_width: (float)line_width line_join: (FSGraphStateLineJoinStyle)line_join miter_limit: (float)miter_limit line_cap: (FSGraphStateLineCapStyle)line_cap dash_phase: (float)dash_phase dashes: (FSFloatArray*)dashes;
-(id)init;
-(id)initWithState: (FSGraphState*)state;
-(void)set: (float)line_width line_join: (FSGraphStateLineJoinStyle)line_join miter_limit: (float)miter_limit line_cap: (FSGraphStateLineCapStyle)line_cap dash_phase: (float)dash_phase dashes: (FSFloatArray*)dashes;
-(void)dealloc;

@end



typedef NS_ENUM(NSInteger, FSRangeFilter) {
  FSRangeAll = 0,
  FSRangeEven = 1,
  FSRangeOdd = 2
};

@interface FSRange : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithIndex: (int)index;
-(id)initWithStart_index: (int)start_index end_index: (int)end_index filter: (FSRangeFilter)filter;
-(id)initWithStart_index: (int)start_index end_index: (int)end_index;
-(id)initWithOther: (FSRange*)other;
-(BOOL)isEmpty;
-(void)addSingle: (int)index;
-(void)addSegment: (int)start_index end_index: (int)end_index filter: (FSRangeFilter)filter;
-(int)getSegmentCount;
-(int)getSegmentStart: (int)segment_index;
-(int)getSegmentEnd: (int)segment_index;
-(void)removeAll;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSFontStyles) {
  FSFontStyleFixedPitch = 0x0001,
  FSFontStyleSerif = 0x0002,
  FSFontStyleSymbolic = 0x0004,
  FSFontStyleScript = 0x0008,
  FSFontStyleNonSymbolic = 0x0020,
  FSFontStyleItalic = 0x0040,
  FSFontStyleAllCap = 0x10000,
  FSFontStylesSmallCap = 0x20000,
  FSFontStylesBold = 0x40000
};

typedef NS_ENUM(NSInteger, FSFontCharset) {
  FSFontCharsetANSI = 0,
  FSFontCharsetDefault = 1,
  FSFontCharsetSymbol = 2,
  FSFontCharsetShift_JIS = 128,
  FSFontCharsetHangeul = 129,
  FSFontCharsetGB2312 = 134,
  FSFontCharsetChineseBig5 = 136,
  FSFontCharsetThai = 222,
  FSFontCharsetEastEurope = 238,
  FSFontCharsetRussian = 204,
  FSFontCharsetGreek = 161,
  FSFontCharsetTurkish = 162,
  FSFontCharsetHebrew = 177,
  FSFontCharsetArabic = 178,
  FSFontCharsetBaltic = 186
};

typedef NS_ENUM(NSInteger, FSFontCIDCharset) {
  FSFontCIDCharsetUnknown = 0,
  FSFontCIDCharsetGB1 = 1,
  FSFontCIDCharsetCNS1 = 2,
  FSFontCIDCharsetJAPAN1 = 3,
  FSFontCIDCharsetKOREA1 = 4,
  FSFontCIDCharsetUNICODE = 5
};

typedef NS_ENUM(NSInteger, FSFontStandardID) {
  FSFontStdIDCourier = 0,
  FSFontStdIDCourierB = 1,
  FSFontStdIDCourierBI = 2,
  FSFontStdIDCourierI = 3,
  FSFontStdIDHelvetica = 4,
  FSFontStdIDHelveticaB = 5,
  FSFontStdIDHelveticaBI = 6,
  FSFontStdIDHelveticaI = 7,
  FSFontStdIDTimes = 8,
  FSFontStdIDTimesB = 9,
  FSFontStdIDTimesBI = 10,
  FSFontStdIDTimesI = 11,
  FSFontStdIDSymbol = 12,
  FSFontStdIDZapfDingbats = 13
};

typedef NS_ENUM(NSInteger, FSFontFontTypes) {
  FSFontFontTypeType1 = 1,
  FSFontFontTypeTrueType = 2,
  FSFontFontTypeType3 = 3,
  FSFontFontTypeCIDFont = 4
};

@interface FSFont : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithName: (NSString *)name styles: (unsigned int)styles charset: (FSFontCharset)charset weight: (int)weight;
-(id)initWithFont_id: (FSFontStandardID)font_id;
-(id)initWithFont_file_path: (NSString *)font_file_path face_index: (int)face_index charset: (FSFontCharset)charset;
-(id)initWithOther: (FSFont*)other;
-(BOOL)isEmpty;
-(NSString *)getName;
-(NSString *)getFamilyName;
-(BOOL)isBold;
-(BOOL)isItalic;
-(BOOL)isEmbedded: (FSPDFDoc*)document;
-(BOOL)isSupportEmbedded: (FSPDFDoc*)document;
-(FSFont*)embed: (FSPDFDoc*)document;
-(int)getAscent;
-(int)getDescent;
-(FSRectI*)getCharBBox: (unsigned int)unicode;
-(float)getCharWidth: (unsigned int)unicode;
-(FSRectI*)getCharBBoxWithDoc: (unsigned int)unicode document: (FSPDFDoc*)document;
-(float)getCharWidthWithDoc: (unsigned int)unicode document: (FSPDFDoc*)document;
-(unsigned int)getStyles: (FSPDFDoc*)document;
-(FSFontCIDCharset)getCIDCharset: (FSPDFDoc*)document;
-(BOOL)isStandardFont: (FSPDFDoc*)document;
-(FSFontStandardID)getStandard14Font: (FSPDFDoc*)document;
-(FSFontFontTypes)getFontType: (FSPDFDoc*)document;
-(NSString *)getBaseFontName: (FSPDFDoc*)document;
-(BOOL)isVertWriting: (FSPDFDoc*)document;

-(void)dealloc;

@end

@interface FSFontMapResult : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getFile_read) id<FSFileReaderCallback> file_read;
@property (nonatomic, getter=getFace_index) int face_index;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithFile_read: (id<FSFileReaderCallback>)file_read face_index: (int)face_index;
-(id)initWithOther: (FSFontMapResult*)other;
-(void)set: (id<FSFileReaderCallback>)file_read face_index: (int)face_index;
-(void)dealloc;

@end



typedef NS_ENUM(NSInteger, FSPathPointType) {
  FSPathTypeMoveTo = 1,
  FSPathTypeLineTo = 2,
  FSPathTypeLineToCloseFigure = 3,
  FSPathTypeBezierTo = 4,
  FSPathTypeBezierToCloseFigure = 5
};

@interface FSPath : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSPath*)other;
-(BOOL)isEmpty;
-(int)getPointCount;
-(FSPointF*)getPoint: (int)index;
-(FSPathPointType)getPointType: (int)index;
-(BOOL)setPoint: (int)index point: (FSPointF*)point type: (FSPathPointType)type;
-(BOOL)moveTo: (FSPointF*)point;
-(BOOL)lineTo: (FSPointF*)point;
-(BOOL)cubicBezierTo: (FSPointF*)point1 point2: (FSPointF*)point2 point3: (FSPointF*)point3;
-(BOOL)closeFigure;
-(BOOL)removePoint: (int)index;
-(BOOL)appendRect: (FSRectF*)rect;
-(BOOL)appendEllipse: (FSRectF*)rect;
-(void)transform: (FSMatrix2D*)matrix;
-(void)clear;
-(void)increasePointCount: (int)count;

-(void)dealloc;

@end

@interface FSPathArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSPathArray*)other;
-(unsigned long)getSize;
-(FSPath*)getAt: (unsigned long)index;
-(void)add: (FSPath*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSPath*)element;
-(void)removeAll;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSColorSpaceRenderingIntent) {
  FSColorSpaceRenderIntentPerceptual = 0,
  FSColorSpaceRenderIntentRelColorimetric = 1,
  FSColorSpaceRenderIntentSaturation = 2,
  FSColorSpaceRenderIntentAbsColorimetric = 3
};

@interface FSColorSpace : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithType: (FSColorSpaceType)type;
-(id)initWithOther: (FSColorSpace*)other;
-(BOOL)isEmpty;
-(int)getComponentCount;
-(FSColorSpaceType)getColorSpaceType;
-(BOOL)isSpotColorSpace;
-(NSArray<NSData *> *)getComponentNames;
-(FSColor*)convertColor: (FSColor*)color;
-(FSColor*)convertColorRGB: (int)r_value g_value: (int)g_value b_value: (int)b_value;
-(FSColor*)convertColorCMYK: (int)c_value m_value: (int)m_value y_value: (int)y_value k_value: (int)k_value;

-(void)dealloc;

@end

@interface FSColor : FSBase
@property (nonatomic, copy, getter=getValue) FSFloatArray* value;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithColor_space: (FSColorSpace*)color_space;
-(id)initWithOther: (FSColor*)other;
-(BOOL)isEmpty;
-(FSColorSpace*)getColorSpace;
-(FSColor*)convertToRGB: (FSColorSpaceRenderingIntent)intent;
-(FSColor*)convertToCMYK: (FSColorSpaceRenderingIntent)intent;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSBitmapDIBFormat) {
  FSBitmapDIBInvalid = 0,
  FSBitmapDIBRgb = 0x018,
  FSBitmapDIBRgb32 = 0x020,
  FSBitmapDIBArgb = 0x220,
  FSBitmapDIB8bppMask = 0x108,
  FSBitmapDIB8bpp = 0x008,
  FSBitmapDIB8bppGray = 0x1008,
  FSBitmapDIBAbgr = 0x222,
  FSBitmapDIBRgb565 = 0x565
};

typedef NS_ENUM(NSInteger, FSBitmapInterpolationFlag) {
  FSBitmapDownsample = 0x01,
  FSBitmapQuadratic = 0x02,
  FSBitmapBicubic = 0x04
};

@interface FSBitmap : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithWidth: (int)width height: (int)height format: (FSBitmapDIBFormat)format buffer: (NSData *)buffer pitch: (int)pitch;
-(id)initWithWidth: (int)width height: (int)height format: (FSBitmapDIBFormat)format;
-(id)initWithOther: (FSBitmap*)other;
-(id)init;
-(BOOL)isEmpty;
-(FSBitmap*)clone: (FSRectI*)clip_rect;
-(int)getWidth;
-(int)getHeight;
-(int)getPitch;
-(int)getBpp;
-(FSBitmapDIBFormat)getFormat;
-(void)fillRect: (unsigned int)color rect: (FSRectI*)rect;
-(FSBitmap*)convertFormat: (FSBitmapDIBFormat)format icc_transform: (NSData *)icc_transform;
-(FSRectI*)calculateBBoxByColor: (unsigned int)backgroud_color;
-(FSRectI*)detectBBoxByColorDiffer: (int)detection_size color_differ: (int)color_differ;
-(FSBitmap*)swapXY: (BOOL)is_flip_horz is_flip_vert: (BOOL)is_flip_vert clip_rect: (FSRectI*)clip_rect;
-(FSBitmap*)flip: (BOOL)is_flip_horz is_flip_vert: (BOOL)is_flip_vert;
-(FSBitmap*)stretchTo: (int)dest_width dest_height: (int)dest_height flag: (FSBitmapInterpolationFlag)flag clip_rect: (FSRectI*)clip_rect;
-(FSBitmap*)transformTo: (FSMatrix2D*)matrix flag: (FSBitmapInterpolationFlag)flag out_left: (int *)out_left out_top: (int *)out_top clip_rect: (FSRectI*)clip_rect;
-(FSBitmap*)getMask: (FSRectI*)clip_rect;
-(NSData *)getBuffer;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSImageType) {
  FSImageUnknown = -1,
  FSImageNone = 0,
  FSImageBMP = 1,
  FSImageJPG = 2,
  FSImagePNG = 3,
  FSImageGIF = 4,
  FSImageTIF = 5,
  FSImageJPX = 6,
  FSImageJBIG2 = 8
};

@interface FSImage : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithPath: (NSString *)path;
-(id)initWithFile_read: (id<FSFileReaderCallback>)file_read;
-(id)initWithOther: (FSImage*)other;
-(BOOL)isEmpty;
-(FSImageType)getType;
-(int)getWidth;
-(int)getHeight;
-(int)getFrameCount;
-(FSBitmap*)getFrameBitmap: (int)index;
-(int)getXDPI;
-(int)getYDPI;
-(BOOL)addFrame: (FSBitmap*)bitmap;
-(void)setDPIs: (int)x_dpi y_dpi: (int)y_dpi;
-(BOOL)saveAs: (NSString *)file_path;
-(id)initWithBuffer: (NSData *)buffer;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSRendererColorMode) {
  FSRendererColorModeNormal = 0,
  FSRendererColorModeMappingGray = 1,
  FSRendererColorModeMapping = 2
};

typedef NS_ENUM(NSInteger, FSRendererContentFlag) {
  FSRendererRenderPage = 0x01,
  FSRendererRenderAnnot = 0x02
};

typedef NS_ENUM(NSInteger, FSRendererDeviceType) {
  FSRendererDeviceDisplay = 1,
  FSRendererDevicePrinter = 2
};

@interface FSRenderer : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithBitmap: (FSBitmap*)bitmap is_rgb_order: (BOOL)is_rgb_order;
-(id)initWithContext: (CGContextRef)context device_type: (FSRendererDeviceType)device_type;
-(id)initWithOther: (FSRenderer*)other;
-(BOOL)isEmpty;
-(FSProgressive*)startQuickRender: (FSPDFPage*)page matrix: (FSMatrix2D*)matrix pause: (id<FSPauseCallback>)pause;
-(FSProgressive*)startRender: (FSPDFPage*)page matrix: (FSMatrix2D*)matrix pause: (id<FSPauseCallback>)pause;
-(FSProgressive*)startRenderReflowPage: (FSReflowPage*)reflow_page matrix: (FSMatrix2D*)matrix pause: (id<FSPauseCallback>)pause;
-(FSProgressive*)startRenderXFAPage: (FSXFAPage*)xfa_page_view matrix: (FSMatrix2D*)matrix is_highlight: (BOOL)is_highlight pause: (id<FSPauseCallback>)pause;
-(FSProgressive*)startRenderBitmap: (FSBitmap*)bitmap matrix: (FSMatrix2D*)matrix clip_rect: (FSRectI*)clip_rect interpolation: (unsigned int)interpolation pause: (id<FSPauseCallback>)pause;
-(void)setRenderAnnotAppearanceType: (FSAnnotAppearanceType)ap_type;
-(BOOL)renderAnnot: (FSAnnot*)annot matrix: (FSMatrix2D*)matrix;
-(BOOL)renderFormControls: (FSPDFPage*)page matrix: (FSMatrix2D*)matrix;
-(BOOL)renderGraphicsObject: (FSGraphicsObject*)graphics_object page: (FSPDFPage*)page matrix: (FSMatrix2D*)matrix;
-(void)setClipRect: (FSRectI*)clip_rect;
-(void)setClipPathFill: (FSPath*)clip_path matrix: (FSMatrix2D*)matrix fill_mode: (FSFillMode)fill_mode;
-(void)setClipPathStroke: (FSPath*)clip_path matrix: (FSMatrix2D*)matrix graph_state: (FSGraphState*)graph_state;
-(void)setRenderContentFlags: (unsigned int)render_content_flags;
-(void)setRenderAnnotsForThumbnail: (BOOL)is_render_annots_for_thumbnail;
-(void)setRenderFormField: (BOOL)is_render_formfield;
-(void)setRenderSignature: (BOOL)is_render_signature;
-(void)setLayerContext: (FSLayerContext*)layer_context;
-(void)setColorMode: (FSRendererColorMode)color_mode;
-(void)setMappingModeColors: (unsigned int)background_color foreground_color: (unsigned int)foreground_color;
-(void)setJPEGDownSample: (BOOL)is_jepg_down_sample;
-(void)setJPXDownSample: (BOOL)is_jpx_down_sample;
-(void)enableForPrint: (BOOL)is_render_for_print;
-(void)setForceHalftone: (BOOL)is_to_force_halftone;
-(void)setRenderPathThinLine: (BOOL)is_render_path_thin_line;
-(void)setRenderTextAntiAliasing: (BOOL)is_render_text_antialiasing;
-(void)setRenderPathAntiAliasing: (BOOL)is_render_path_antialiasing;
-(void)setRenderImageAntiAliasing: (BOOL)is_render_image_antialiasing;
-(void)setRenderEnhanceThinLines: (BOOL)is_render_enhance_thin_lines;
-(void)drawTextString: (FSPDFDoc*)document text_string: (NSString *)text_string graph_state: (FSGraphState*)graph_state origin_x: (float)origin_x origin_y: (float)origin_y font: (FSFont*)font font_size: (float)font_size matrix: (FSMatrix2D*)matrix fill_color: (unsigned int)fill_color stroke_color: (unsigned int)stroke_color;
-(void)drawPath: (FSPath*)path graph_state: (FSGraphState*)graph_state matrix: (FSMatrix2D*)matrix fill_color: (unsigned int)fill_color stroke_color: (unsigned int)stroke_color fill_mode: (FSFillMode)fill_mode blend_mode: (FSGraphicsObjectBlendMode)blend_mode;
-(void)drawStrokeRect: (FSMatrix2D*)matrix rect: (FSRectF*)rect color: (unsigned int *)color width: (float)width;

-(void)dealloc;

@end



typedef NS_ENUM(NSInteger, FSBarcodeFormat) {
  FSBarcodeFormatCode39 = 0,
  FSBarcodeFormatCode128 = 1,
  FSBarcodeFormatEAN8 = 2,
  FSBarcodeFormatUPCA = 3,
  FSBarcodeFormatEAN13 = 4,
  FSBarcodeFormatITF = 5,
  FSBarcodeFormatPDF417 = 6,
  FSBarcodeFormatQRCode = 7
};

typedef NS_ENUM(NSInteger, FSBarcodeQRErrorCorrectionLevel) {
  FSBarcodeQRCorrectionLevelLow = 0,
  FSBarcodeQRCorrectionLevelMedium = 1,
  FSBarcodeQRCorrectionLevelQuater = 2,
  FSBarcodeQRCorrectionLevelHigh = 3
};

@interface FSBarcode : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSBarcode*)other;
-(BOOL)isEmpty;
-(FSBitmap*)generateBitmap: (NSString *)info format: (FSBarcodeFormat)format unit_width: (int)unit_width unit_height: (int)unit_height level: (FSBarcodeQRErrorCorrectionLevel)level;

-(void)dealloc;

@end

@interface FSRedaction : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document;
-(id)initWithOther: (FSRedaction*)other;
-(BOOL)isEmpty;
-(FSRedact*)markRedactAnnot: (FSPDFPage*)page rects: (FSRectFArray*)rects;
-(BOOL)apply;

-(void)dealloc;

@end

@interface FSWidgetChoiceOption : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getOption_label) NSString * option_label;
@property (nonatomic, getter=getSelected) BOOL selected;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOption_label: (NSString *)option_label selected: (BOOL)selected;
-(id)initWithOption: (FSWidgetChoiceOption*)option;
-(void)set: (NSString *)option_label selected: (BOOL)selected;
-(void)dealloc;

@end

@interface FSWidgetChoiceOptionArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSWidgetChoiceOptionArray*)other;
-(unsigned long)getSize;
-(FSWidgetChoiceOption*)getAt: (unsigned long)index;
-(void)add: (FSWidgetChoiceOption*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSWidgetChoiceOption*)element;
-(void)removeAll;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSAppProviderCallbackAppInfo) {
  FSAppProviderCallbackAppInfoVersion = 0x0,
  FSAppProviderCallbackAppInfoLanguage = 0x01,
  FSAppProviderCallbackAppInfoPlatform = 0x02,
  FSAppProviderCallbackAppInfoVariation = 0x03,
  FSAppProviderCallbackAppInfoName = 0x04,
  FSAppProviderCallbackAppInfoType = 0x05
};

typedef NS_ENUM(NSInteger, FSAppProviderCallbackBeepType) {
  FSAppProviderCallbackBeepTypeError = 0,
  FSAppProviderCallbackBeepTypeWarning = 1,
  FSAppProviderCallbackBeepTypeQuestion = 2,
  FSAppProviderCallbackBeepTypeStatus = 3,
  FSAppProviderCallbackBeepTypeDefault = 4
};

typedef NS_ENUM(NSInteger, FSAppProviderCallbackStringID) {
  FSAppProviderCallbackStringIDValidateFailed = 1,
  FSAppProviderCallbackStringIDCalcOverride = 2,
  FSAppProviderCallbackStringIDModifyField = 3,
  FSAppProviderCallbackStringIDNotModifyField = 4,
  FSAppProviderCallbackStringIDAppName = 5,
  FSAppProviderCallbackStringIDImageFilter = 6,
  FSAppProviderCallbackStringIDUnknownCaught = 7,
  FSAppProviderCallbackStringIDUnableToSet = 8,
  FSAppProviderCallbackStringIDValueExcalmatory = 9,
  FSAppProviderCallbackStringIDInvalidEnumValue = 10,
  FSAppProviderCallbackStringIDUnsupportMethod = 11,
  FSAppProviderCallbackStringIDUnsupportProperty = 12,
  FSAppProviderCallbackStringIDInvalidPropertySetOperation = 13,
  FSAppProviderCallbackStringIDNotDefaultValue = 14,
  FSAppProviderCallbackStringIDUnableSetLanguage = 15,
  FSAppProviderCallbackStringIDUnableSetNumPages = 16,
  FSAppProviderCallbackStringIDUnableSetPlatformValue = 17,
  FSAppProviderCallbackStringIDUnableSetValidationsEnabledValue = 18,
  FSAppProviderCallbackStringIDUnableSetValidationsValue = 19,
  FSAppProviderCallbackStringIDUnableSetVersion = 20,
  FSAppProviderCallbackStringIDUnableSetReady = 21,
  FSAppProviderCallbackStringIDNumberOfOccur = 22,
  FSAppProviderCallbackStringIDUnableSetClassName = 23,
  FSAppProviderCallbackStringIDUnableSetLengthValue = 24,
  FSAppProviderCallbackStringIDUnsupportChar = 25,
  FSAppProviderCallbackStringIDBadSuffix = 26,
  FSAppProviderCallbackStringIDExpectedIdent = 27,
  FSAppProviderCallbackStringIDExpectedString = 28,
  FSAppProviderCallbackStringIDInvalidateChar = 29,
  FSAppProviderCallbackStringIDRedefinition = 30,
  FSAppProviderCallbackStringIDInvalidToken = 31,
  FSAppProviderCallbackStringIDInvalidExpression = 32,
  FSAppProviderCallbackStringIDUndefineIdentifier = 33,
  FSAppProviderCallbackStringIDInvalidateLeftValue = 34,
  FSAppProviderCallbackStringIDCompilerError = 35,
  FSAppProviderCallbackStringIDCannotModifyValue = 36,
  FSAppProviderCallbackStringIDParametersError = 37,
  FSAppProviderCallbackStringIDExpectedEndIf = 38,
  FSAppProviderCallbackStringIDUnexpectedExpression = 39,
  FSAppProviderCallbackStringIDConditionIsNull = 40,
  FSAppProviderCallbackStringIDIllegalBreak = 41,
  FSAppProviderCallbackStringIDIllegalContinue = 42,
  FSAppProviderCallbackStringIDExpectedOperator = 43,
  FSAppProviderCallbackStringIDDivideZero = 44,
  FSAppProviderCallbackStringIDCannotCovertToObject = 45,
  FSAppProviderCallbackStringIDNotFoundContainer = 46,
  FSAppProviderCallbackStringIDNotFoundProperty = 47,
  FSAppProviderCallbackStringIDNotFoundMethod = 48,
  FSAppProviderCallbackStringIDNotFoundConst = 49,
  FSAppProviderCallbackStringIDNotAssignObject = 50,
  FSAppProviderCallbackStringIDInvalidateInstruction = 51,
  FSAppProviderCallbackStringIDExpectedNumber = 52,
  FSAppProviderCallbackStringIDValidateOutOfArray = 53,
  FSAppProviderCallbackStringIDCannotAssign = 54,
  FSAppProviderCallbackStringIDNotFoundFunction = 55,
  FSAppProviderCallbackStringIDIsNotArray = 56,
  FSAppProviderCallbackStringIDOutOfArrayRange = 57,
  FSAppProviderCallbackStringIDNotSupportArrayCalculate = 58,
  FSAppProviderCallbackStringIDArgumentNotArray = 59,
  FSAppProviderCallbackStringIDArgumentExpectContainer = 60,
  FSAppProviderCallbackStringIDAccessProertyInNotObject = 61,
  FSAppProviderCallbackStringIDFunctionBuildIn = 62,
  FSAppProviderCallbackStringIDErrorMessage = 63,
  FSAppProviderCallbackStringIDIndexValueOutOfBounds = 64,
  FSAppProviderCallbackStringIDIncorrectNumberOfMethod = 65,
  FSAppProviderCallbackStringIDArgumentMismatch = 66,
  FSAppProviderCallbackStringIDInvalidEnumerate = 67,
  FSAppProviderCallbackStringIDInvalidAppend = 68,
  FSAppProviderCallbackStringIDSOMExpectedList = 69,
  FSAppProviderCallbackStringIDNotHaveProperty = 70,
  FSAppProviderCallbackStringIDInvalidNodeType = 71,
  FSAppProviderCallbackStringIDViolateBoundary = 72,
  FSAppProviderCallbackStringIDServerDeny = 73,
  FSAppProviderCallbackStringIDWeekDaySun = 74,
  FSAppProviderCallbackStringIDWeekDayMon = 75,
  FSAppProviderCallbackStringIDWeekDayTue = 76,
  FSAppProviderCallbackStringIDWeekDayWed = 77,
  FSAppProviderCallbackStringIDWeekDayThu = 78,
  FSAppProviderCallbackStringIDWeekDayFri = 79,
  FSAppProviderCallbackStringIDWeekDaySat = 80,
  FSAppProviderCallbackStringIDMonthJan = 81,
  FSAppProviderCallbackStringIDMonthFeb = 82,
  FSAppProviderCallbackStringIDMonthMarch = 83,
  FSAppProviderCallbackStringIDMonthApril = 84,
  FSAppProviderCallbackStringIDMonthMay = 85,
  FSAppProviderCallbackStringIDMonthJune = 86,
  FSAppProviderCallbackStringIDMonthJuly = 87,
  FSAppProviderCallbackStringIDMonthAug = 88,
  FSAppProviderCallbackStringIDMonthSep = 89,
  FSAppProviderCallbackStringIDMonthOct = 90,
  FSAppProviderCallbackStringIDMonthNov = 91,
  FSAppProviderCallbackStringIDMonthDec = 92,
  FSAppProviderCallbackStringIDToday = 93,
  FSAppProviderCallbackStringIDValidateLimit = 94,
  FSAppProviderCallbackStringIDValidateNullWarning = 95,
  FSAppProviderCallbackStringIDValidateNullError = 96,
  FSAppProviderCallbackStringIDValidateWarning = 97,
  FSAppProviderCallbackStringIDValidateError = 98,
  FSAppProviderCallbackStringIDValidateNumberError = 99,
  FSAppProviderCallbackStringIDScriptFailedError = 100,
  FSAppProviderCallbackStringIDScriptInvalidValue = 101,
  FSAppProviderCallbackStringIDSubmitValidateNullError = 102,
  FSAppProviderCallbackStringIDInvalidBarcodeValue = 103,
  FSAppProviderCallbackStringIDScriptArgumentMismatch = 104
};

typedef NS_ENUM(NSInteger, FSAppProviderCallbackMsgBoxIconType) {
  FSAppProviderCallbackMsgBoxIconError = 0,
  FSAppProviderCallbackMsgBoxIconWarning = 1,
  FSAppProviderCallbackMsgBoxIconQuestion = 2,
  FSAppProviderCallbackMsgBoxIconStatus = 3
};

typedef NS_ENUM(NSInteger, FSAppProviderCallbackMsgBoxButtonType) {
  FSAppProviderCallbackMsgBtnTypeOK = 0,
  FSAppProviderCallbackMsgBtnTypeOKCancel = 1,
  FSAppProviderCallbackMsgBtnTypeYesNo = 2,
  FSAppProviderCallbackMsgBtnTypeYesNoCancel = 3
};

typedef NS_ENUM(NSInteger, FSAppProviderCallbackMsgBoxButtonID) {
  FSAppProviderCallbackMsgBtnIDOK = 1,
  FSAppProviderCallbackMsgBtnIDCancel = 2,
  FSAppProviderCallbackMsgBtnIDNo = 3,
  FSAppProviderCallbackMsgBtnIDYes = 4
};



typedef NS_ENUM(NSInteger, FSDocProviderCallbackInvalidateFlag) {
  FSDocProviderCallbackInvalidateFlagAllPages = 0,
  FSDocProviderCallbackInvalidateFlagCurrentPage = 1
};

typedef NS_ENUM(NSInteger, FSDocProviderCallbackPrintOption) {
  FSDocProviderCallbackPrintOptionShowDialog = 0x00000001,
  FSDocProviderCallbackPrintOptionCanCancel = 0x00000002,
  FSDocProviderCallbackPrintOptionShrinkPage = 0x00000004,
  FSDocProviderCallbackPrintOptionAsImage = 0x00000008,
  FSDocProviderCallbackPrintOptionReverseOrder = 0x00000010,
  FSDocProviderCallbackPrintOptionPrintAnnot = 0x00000020
};

typedef NS_ENUM(NSInteger, FSDocProviderCallbackSubmitFormat) {
  FSDocProviderCallbackSubmitInXDP = 0,
  FSDocProviderCallbackSubmitInPDF = 1,
  FSDocProviderCallbackSubmitInUrlEncoded = 2,
  FSDocProviderCallbackSubmitInXFD = 3,
  FSDocProviderCallbackSubmitInXML = 4
};

typedef NS_ENUM(NSInteger, FSDocProviderCallbackTextEncoding) {
  FSDocProviderCallbackTextEncodingNone = 0,
  FSDocProviderCallbackTextEncodingBig5 = 1,
  FSDocProviderCallbackTextEncodingFontSpecific = 2,
  FSDocProviderCallbackTextEncodingGBK = 3,
  FSDocProviderCallbackTextEncodingGB18030 = 4,
  FSDocProviderCallbackTextEncodingGB2312 = 5,
  FSDocProviderCallbackTextEncodingISO8859NN = 6,
  FSDocProviderCallbackTextEncodingKSC5601 = 7,
  FSDocProviderCallbackTextEncodingShiftJIS = 8,
  FSDocProviderCallbackTextEncodingUCS2 = 9,
  FSDocProviderCallbackTextEncodingUTF16 = 10,
  FSDocProviderCallbackTextEncodingUTF8 = 11
};

typedef NS_ENUM(NSInteger, FSDocProviderCallbackPageViewEventType) {
  FSDocProviderCallbackPageViewEventTypeAdded = 0,
  FSDocProviderCallbackPageViewEventTypeRemoved = 1,
  FSDocProviderCallbackPageViewEventTypeAllRemoved = 2
};

typedef NS_ENUM(NSInteger, FSDocProviderCallbackWidgetEventType) {
  FSDocProviderCallbackWidgetEventTypeAdded = 0,
  FSDocProviderCallbackWidgetEventTypeBeforeRemoved = 1
};



typedef NS_ENUM(NSInteger, FSXFADocEventType) {
  FSXFADocEventTypeUnknown = 0,
  FSXFADocEventTypePostPrint = 1,
  FSXFADocEventTypePrePrint = 2
};

typedef NS_ENUM(NSInteger, FSXFADocType) {
  FSXFADocDynamic = 0,
  FSXFADocStatic = 1,
  FSXFADocXDP = 2
};

typedef NS_ENUM(NSInteger, FSXFADocExportDataType) {
  FSXFADocExportDataTypeXML = 0,
  FSXFADocExportDataTypeStaticXDP = 1,
  FSXFADocExportDataTypeXDP = 2
};

@interface FSXFADoc : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document xfa_doc_provider_handler: (id<FSDocProviderCallback>)xfa_doc_provider_handler;
-(id)initWithDocument: (FSPDFDoc*)document;
-(id)initWithOther: (FSXFADoc*)other;
-(BOOL)isEmpty;
-(FSProgressive*)startLoad: (id<FSPauseCallback>)pause;
-(void)setDocProviderCallback: (id<FSDocProviderCallback>)doc_provider_callback;
-(FSXFADocType)getType;
-(int)getPageCount;
-(FSXFAPage*)getPage: (int)page_index;
-(BOOL)exportData: (NSString *)output_file_path export_type: (FSXFADocExportDataType)export_type;
-(void)setPDFPath: (NSString *)pdf_file_path;
-(BOOL)importData: (NSString *)file_path;
-(BOOL)importDataWithReader: (id<FSFileReaderCallback>)file_reader;
-(void)resetForm;
-(void)flattenTo: (NSString *)output_file_path;
-(void)flattenToWithStreamCallback: (id<FSStreamCallback>)stream;
-(void)processEvent: (FSXFADocEventType)event_type;
-(void)setFocus: (FSXFAWidget*)xfa_widget;
-(void)killFocus;
-(FSXFAWidget*)getWidgetByFullName: (NSString *)full_name;

-(void)dealloc;

@end

@interface FSXFAPage : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSXFAPage*)other;
-(BOOL)isEmpty;
-(FSMatrix2D*)getDisplayMatrix: (int)left top: (int)top width: (int)width height: (int)height rotate: (FSRotation)rotate;
-(float)getWidth;
-(float)getHeight;
-(FSXFAWidget*)getWidgetAtDevicePoint: (FSMatrix2D*)matrix device_point: (FSPointF*)device_point tolerance: (float)tolerance;
-(int)getIndex;
-(int)getWidgetCount;
-(FSXFAWidget*)getWidget: (int)widget_index;
-(FSXFAWidget*)getWidgetByFullName: (NSString *)full_name;
-(FSXFAWidget*)getFirstWidget;
-(FSXFAWidget*)getLastWidget;
-(FSXFAWidget*)getNextWidget: (FSXFAWidget*)widget;
-(FSXFAWidget*)getPrevWidget: (FSXFAWidget*)widget;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSXFAWidgetHitTestArea) {
  FSXFAWidgetHitTestAreaUnknown = 0,
  FSXFAWidgetHitTestAreaClient = 1,
  FSXFAWidgetHitTestAreaTitleBar = 2,
  FSXFAWidgetHitTestAreaHyperLink = 3
};

typedef NS_ENUM(NSInteger, FSXFAWidgetWidgetType) {
  FSXFAWidgetWidgetTypeBarcode = 0,
  FSXFAWidgetWidgetTypePushButton = 1,
  FSXFAWidgetWidgetTypeCheckButton = 2,
  FSXFAWidgetWidgetTypeArc = 3,
  FSXFAWidgetWidgetTypeDateTimeEdit = 4,
  FSXFAWidgetWidgetTypeNumericEdit = 5,
  FSXFAWidgetWidgetTypeSignature = 6,
  FSXFAWidgetWidgetTypeChoiceList = 7,
  FSXFAWidgetWidgetTypeImageEdit = 8,
  FSXFAWidgetWidgetTypeLine = 9,
  FSXFAWidgetWidgetTypePasswordEdit = 10,
  FSXFAWidgetWidgetTypeRadioButton = 11,
  FSXFAWidgetWidgetTypeRectangle = 12,
  FSXFAWidgetWidgetTypeTextEdit = 13,
  FSXFAWidgetWidgetTypeUnknown = 14,
  FSXFAWidgetWidgetTypeExclGroup = 15,
  FSXFAWidgetWidgetTypeImage = 16
};

typedef NS_ENUM(NSInteger, FSXFAWidgetPresenceProperty) {
  FSXFAWidgetPresenceUnknown = 0,
  FSXFAWidgetPresenceVisible = 1,
  FSXFAWidgetPresenceHidden = 2,
  FSXFAWidgetPresenceInactive = 3,
  FSXFAWidgetPresenceInvisible = 4
};

typedef NS_ENUM(NSInteger, FSXFAWidgetWidgetNameType) {
  FSXFAWidgetWidgetNameTypeField = 0,
  FSXFAWidgetWidgetNameTypeCaption = 1,
  FSXFAWidgetWidgetNameTypeFullName = 2
};

typedef NS_ENUM(NSInteger, FSXFAWidgetWidgetHAlignType) {
  FSXFAWidgetWidgethAlignTypeCenter = 128,
  FSXFAWidgetWidgethAlignTypeJustify = 156,
  FSXFAWidgetWidgethAlignTypeJustifyAll = 61,
  FSXFAWidgetWidgethAlignTypeLeft = 252,
  FSXFAWidgetWidgethAlignTypeRadix = 231,
  FSXFAWidgetWidgethAlignTypeRight = 54
};

typedef NS_ENUM(NSInteger, FSXFAWidgetWidgetVAlignType) {
  FSXFAWidgetWidgetvAlignTypeTop = 33,
  FSXFAWidgetWidgetvAlignTypeBottom = 85,
  FSXFAWidgetWidgetvAlignTypeMiddle = 161
};

typedef NS_ENUM(NSInteger, FSXFAWidgetWidgetEdgePosition) {
  FSXFAWidgetWidgetEdgePositionTop = 0,
  FSXFAWidgetWidgetEdgePositionRight = 1,
  FSXFAWidgetWidgetEdgePositionBottom = 2,
  FSXFAWidgetWidgetEdgePositionLeft = 3
};

@interface FSXFAWidget : FSBase
@property (nonatomic, copy, getter=getValue) NSString * value;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSXFAWidget*)other;
-(BOOL)isEmpty;
-(FSXFAPage*)getXFAPage;
-(int)getIndex;
-(void)resetData;
-(FSRectF*)getRect;
-(NSString *)getName: (FSXFAWidgetWidgetNameType)type;
-(FSWidgetChoiceOptionArray*)getOptions;
-(BOOL)isChecked;
-(FSXFAWidgetPresenceProperty)getPresence;
-(BOOL)onMouseEnter;
-(BOOL)onMouseExit;
-(BOOL)onLButtonDown: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onLButtonUp: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onLButtonDoubleClick: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onMouseMove: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onRButtonDown: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onRButtonUp: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onKeyDown: (unsigned int)key_code flags: (unsigned int)flags;
-(BOOL)onKeyUp: (unsigned int)key_code flags: (unsigned int)flags;
-(BOOL)onChar: (int)input_char flags: (unsigned int)flags;
-(FSXFAWidgetHitTestArea)onHitTest: (FSPointF*)point;
-(FSXFAWidgetWidgetType)getType;
-(FSXFAWidgetWidgetHAlignType)getHAlign;
-(FSXFAWidgetWidgetVAlignType)getVAlign;
-(BOOL)hasEdge: (FSXFAWidgetWidgetEdgePosition)edge_pos;
-(FSSignature*)getSignature;
-(NSString *)getToolTip;
-(FSBitmap*)getBitmap;

-(void)dealloc;

@end

@interface FSWidgetMenu : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithXfa_widget: (FSXFAWidget*)xfa_widget;
-(id)initWithOther: (FSWidgetMenu*)other;
-(BOOL)isEmpty;
-(BOOL)canCopy;
-(BOOL)canCut;
-(BOOL)canPaste;
-(BOOL)canSelectAll;
-(BOOL)canDelete;
-(BOOL)canDeSelect;
-(NSString *)copy;
-(NSString *)cut;
-(BOOL)paste: (NSString *)text;
-(BOOL)selectAll;
-(BOOL)delete;
-(BOOL)deSelect;
-(BOOL)canUndo;
-(BOOL)canRedo;
-(BOOL)undo;
-(BOOL)redo;
-(BOOL)bold;
-(BOOL)italic;
-(BOOL)underline;
-(BOOL)superscript;
-(BOOL)subscript;
-(BOOL)clearStyle;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSCompareResultInfoCompareResultType) {
  FSCompareResultInfoCompareResultTypeNone = -1,
  FSCompareResultInfoCompareResultTypeDeleteText = 0,
  FSCompareResultInfoCompareResultTypeInsertText = 1,
  FSCompareResultInfoCompareResultTypeReplaceText = 2,
  FSCompareResultInfoCompareResultTypeDeleteImage = 6,
  FSCompareResultInfoCompareResultTypeInsertImage = 7,
  FSCompareResultInfoCompareResultTypeReplaceImage = 8,
  FSCompareResultInfoCompareResultTypeDeletePath = 9,
  FSCompareResultInfoCompareResultTypeInsertPath = 10,
  FSCompareResultInfoCompareResultTypeReplacePath = 11,
  FSCompareResultInfoCompareResultTypeDeleteShading = 12,
  FSCompareResultInfoCompareResultTypeInsertShading = 13,
  FSCompareResultInfoCompareResultTypeReplaceShading = 14,
  FSCompareResultInfoCompareResultTypeDeleteAnnot = 15,
  FSCompareResultInfoCompareResultTypeInsertAnnot = 16,
  FSCompareResultInfoCompareResultTypeReplaceAnnot = 17,
  FSCompareResultInfoCompareResultTypeTextAttriChange = 18
};

@interface FSCompareResultInfo : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getType) FSCompareResultInfoCompareResultType type;
@property (nonatomic, copy, getter=getRect_array) FSRectFArray* rect_array;
@property (nonatomic, copy, getter=getDiff_contents) NSString * diff_contents;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithType: (FSCompareResultInfoCompareResultType)type rect_array: (FSRectFArray*)rect_array diff_contents: (NSString *)diff_contents;
-(id)initWithResult_info: (FSCompareResultInfo*)result_info;
-(void)dealloc;

@end

@interface FSCompareResultInfoArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSCompareResultInfoArray*)other;
-(unsigned long)getSize;
-(FSCompareResultInfo*)getAt: (unsigned long)index;
-(void)add: (FSCompareResultInfo*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSCompareResultInfo*)element;
-(void)removeAll;

-(void)dealloc;

@end

@interface FSCompareResults : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getBase_doc_results) FSCompareResultInfoArray* base_doc_results;
@property (nonatomic, copy, getter=getCompared_doc_results) FSCompareResultInfoArray* compared_doc_results;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithBase_doc_results: (FSCompareResultInfoArray*)base_doc_results compared_doc_results: (FSCompareResultInfoArray*)compared_doc_results;
-(id)initWithCompare_results: (FSCompareResults*)compare_results;
-(void)clear;
-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSComparisonCompareType) {
  FSComparisonCompareTypeAll = 0x00000000,
  FSComparisonCompareTypeText = 0x00000001
};

@interface FSComparison : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithBase_doc: (FSPDFDoc*)base_doc compared_doc: (FSPDFDoc*)compared_doc;
-(id)initWithOther: (FSComparison*)other;
-(BOOL)isEmpty;
-(FSCompareResults*)doCompare: (int)base_page_index compared_page_index: (int)compared_page_index compare_flags: (unsigned int)compare_flags;
-(FSPDFDoc*)generateComparedDoc: (unsigned int)compare_flags;

-(void)dealloc;

@end

@interface FSOptimizer : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSProgressive*)optimize: (FSPDFDoc*)doc settings: (FSOptimizerSettings*)settings pause: (id<FSPauseCallback>)pause;
+(FSProgressive*)startSubsetEmbedFont: (FSPDFDoc*)doc pause: (id<FSPauseCallback>)pause;
-(id)init;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSImageSettingsImageCompressMode) {
  FSImageSettingsImageCompressHigh = 10003,
  FSImageSettingsImageCompressjpeg = 10005,
  FSImageSettingsImageCompressjpeg2000 = 10006,
  FSImageSettingsImageCompressRetain = 10007
};

typedef NS_ENUM(NSInteger, FSImageSettingsImageCompressQuality) {
  FSImageSettingsImageCompressQualityMinimum = 1,
  FSImageSettingsImageCompressQualityLow = 2,
  FSImageSettingsImageCompressQualityMedium = 3,
  FSImageSettingsImageCompressQualityHigh = 4,
  FSImageSettingsImageCompressQualityMaximum = 5
};

typedef NS_ENUM(NSInteger, FSImageSettingsStretchMode) {
  FSImageSettingsStretchDefault = -1,
  FSImageSettingsStretchOff = 0x00,
  FSImageSettingsStretchInterpol = 0x20,
  FSImageSettingsStretchDownsample = 0x04,
  FSImageSettingsStretchBicubic = 0x80,
  FSImageSettingsStretchNoSmooth = 0x100
};

@interface FSImageSettings : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSImageSettings*)other;
-(BOOL)isEmpty;
-(void)setStretchMode: (FSImageSettingsStretchMode)mode;
-(void)setImageDPI: (int)dpi;
-(void)setImageDPILimit: (int)dpi_limit;
-(void)setCompressionMode: (FSImageSettingsImageCompressMode)mode;
-(void)setQuality: (FSImageSettingsImageCompressQuality)quality;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSMonoImageSettingsMonoImageCompressMode) {
  FSMonoImageSettingsImageCompressCCITT3 = 10001,
  FSMonoImageSettingsImageCompressCCITT4 = 10002,
  FSMonoImageSettingsImageCompressHigh = 10003,
  FSMonoImageSettingsImageCompressjbig2 = 10004,
  FSMonoImageSettingsImageCompressRetain = 10007,
  FSMonoImageSettingsImageCompressRunLength = 10008
};

typedef NS_ENUM(NSInteger, FSMonoImageSettingsMonoImageCompressQuality) {
  FSMonoImageSettingsImageCompressQualityLossless = 1,
  FSMonoImageSettingsImageCompressQualityLossy = 2
};

typedef NS_ENUM(NSInteger, FSMonoImageSettingsStretchMode) {
  FSMonoImageSettingsStretchDefault = -1,
  FSMonoImageSettingsStretchOff = 0x00,
  FSMonoImageSettingsStretchInterpol = 0x20,
  FSMonoImageSettingsStretchDownsample = 0x04,
  FSMonoImageSettingsStretchBicubic = 0x80,
  FSMonoImageSettingsStretchNoSmooth = 0x100
};

@interface FSMonoImageSettings : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSMonoImageSettings*)other;
-(BOOL)isEmpty;
-(void)setImageDPI: (int)dpi;
-(void)setImageDPILimit: (int)dpi_limit;
-(void)setCompressionMode: (FSMonoImageSettingsMonoImageCompressMode)mode;
-(void)setStretchMode: (FSMonoImageSettingsStretchMode)mode;
-(void)setQuality: (FSMonoImageSettingsMonoImageCompressQuality)quality;

-(void)dealloc;

@end

@interface FSUnembeddedFontSettings : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSUnembeddedFontSettings*)other;
-(BOOL)isEmpty;
-(void)setUnembeddedFontNameArray: (NSArray<NSString *> *)font_name_array;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSOptimizerSettingsOptimizerOptions) {
  FSOptimizerSettingsOptimizerCompressImages = 0x01,
  FSOptimizerSettingsOptimizerCleanUp = 0x02,
  FSOptimizerSettingsOptimizerDiscardObjects = 0x04,
  FSOptimizerSettingsOptimizerUnembeddedFonts = 0x08,
  FSOptimizerSettingsOptimizerDiscardUserData = 0x10
};

typedef NS_ENUM(NSInteger, FSOptimizerSettingsCleanUpOptions) {
  FSOptimizerSettingsCleanUpUseFlateForNonEncodedStream = 0x01,
  FSOptimizerSettingsCleanUpUseFlateInsteadOfLZW = 0x02,
  FSOptimizerSettingsCleanUpRemoveInvalidBookmarks = 0x04,
  FSOptimizerSettingsCleanUpRemoveInvalidLinks = 0x08
};

typedef NS_ENUM(NSInteger, FSOptimizerSettingsDiscardObjectsOptions) {
  FSOptimizerSettingsDiscardObjectsFormActions = 0x01,
  FSOptimizerSettingsDiscardObjectsFlattenFormFields = 0x02,
  FSOptimizerSettingsDiscardObjectsJavaScriptActions = 0x04,
  FSOptimizerSettingsDiscardObjectsEmbeddedPageThumbnails = 0x08,
  FSOptimizerSettingsDiscardObjectsEmbeddedPrintSettings = 0x10,
  FSOptimizerSettingsDiscardObjectsBookmarks = 0x20,
  FSOptimizerSettingsDiscardObjectsAlternateImages = 0x40,
  FSOptimizerSettingsDiscardObjectsDocumentTags = 0x80,
  FSOptimizerSettingsDiscardObjectsEmbeddedSearchIndex = 0x100
};

typedef NS_ENUM(NSInteger, FSOptimizerSettingsDiscardUserDataOptions) {
  FSOptimizerSettingsDiscardUserDataAllAnnotsFormsAndMultimedia = 0x01,
  FSOptimizerSettingsDiscardUserDataExternalCrossReferences = 0x02,
  FSOptimizerSettingsDiscardUserDataDocumentInfoAndMetaData = 0x04,
  FSOptimizerSettingsDiscardUserDataFileAttchments = 0x08,
  FSOptimizerSettingsDiscardUserDataPrivateDataOfOtherApp = 0x10,
  FSOptimizerSettingsDiscardUserDataLayer = 0x20
};

@interface FSOptimizerSettings : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSOptimizerSettings*)other;
-(BOOL)isEmpty;
-(void)setOptimizerOptions: (unsigned int)optimize_options;
-(void)setColorGrayImageSettings: (FSImageSettings*)settings;
-(void)setMonoImageSettings: (FSMonoImageSettings*)settings;
-(void)setUnembeddedFontSettings: (FSUnembeddedFontSettings*)settings;
-(void)setCleanUpOptions: (unsigned int)clean_up_options;
-(void)setDiscardObjectsOptions: (unsigned int)discard_objects_options;
-(void)setDiscardUserDataOptions: (unsigned int)discard_userdata_options;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSFDFDocType) {
  FSFDFDocFDF = 0,
  FSFDFDocXFDF = 1
};

@interface FSFDFDoc : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithFile_read: (id<FSFileReaderCallback>)file_read;
-(id)initWithType: (FSFDFDocType)type;
-(id)initWithPath: (NSString *)path;
-(id)initWithOther: (FSFDFDoc*)other;
-(BOOL)isEmpty;
-(FSFDFDocType)getType;
-(NSString *)getPDFPath;
-(BOOL)setPDFPath: (NSString *)pdf_path;
-(BOOL)saveAs: (NSString *)file_path;
-(FSPDFDictionary*)getCatalog;
-(FSPDFDictionary*)getFDFDict;
-(id)initWithBuffer: (NSData *)buffer;

-(void)dealloc;

@end

@interface FSMenuList : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getLevel) int level;
@property (nonatomic, copy, getter=getName) NSString * name;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithLevel: (int)level name: (NSString *)name;
-(id)initWithMenu_list: (FSMenuList*)menu_list;
-(void)set: (int)level name: (NSString *)name;
-(void)dealloc;

@end

@interface FSMenuListArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSMenuListArray*)other;
-(unsigned long)getSize;
-(FSMenuList*)getAt: (unsigned long)index;
-(void)add: (FSMenuList*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSMenuList*)element;
-(void)removeAll;

-(void)dealloc;

@end

@interface FSIdentityProperties : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getCorporation) NSString * corporation;
@property (nonatomic, copy, getter=getEmail) NSString * email;
@property (nonatomic, copy, getter=getLogin_name) NSString * login_name;
@property (nonatomic, copy, getter=getName) NSString * name;
@property (nonatomic, copy, getter=getFirst_name) NSString * first_name;
@property (nonatomic, copy, getter=getLast_name) NSString * last_name;
@property (nonatomic, copy, getter=getTitle) NSString * title;
@property (nonatomic, copy, getter=getDepartment) NSString * department;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithCorporation: (NSString *)corporation email: (NSString *)email login_name: (NSString *)login_name name: (NSString *)name first_name: (NSString *)first_name last_name: (NSString *)last_name title: (NSString *)title department: (NSString *)department;
-(id)initWithId_properities: (FSIdentityProperties*)id_properities;
-(void)set: (NSString *)corporation email: (NSString *)email login_name: (NSString *)login_name name: (NSString *)name first_name: (NSString *)first_name last_name: (NSString *)last_name title: (NSString *)title department: (NSString *)department;
-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSActionCallbackLanguage) {
  FSActionCallbackLanguageUnknown = 0,
  FSActionCallbackLanguageCHS = 1,
  FSActionCallbackLanguageCHT = 2,
  FSActionCallbackLanguageDAN = 3,
  FSActionCallbackLanguageDEU = 4,
  FSActionCallbackLanguageENU = 5,
  FSActionCallbackLanguageESP = 6,
  FSActionCallbackLanguageFRA = 7,
  FSActionCallbackLanguageITA = 8,
  FSActionCallbackLanguageKOR = 9,
  FSActionCallbackLanguageJPN = 10,
  FSActionCallbackLanguageNLD = 11,
  FSActionCallbackLanguageNOR = 12,
  FSActionCallbackLanguagePTB = 13,
  FSActionCallbackLanguageSUO = 14,
  FSActionCallbackLanguageSVE = 15
};

typedef NS_ENUM(NSInteger, FSActionCallbackAppInfoType) {
  FSActionCallbackAppInfoTypeFormsVersion = 0x0,
  FSActionCallbackAppInfoTypeViewerType = 0x01,
  FSActionCallbackAppInfoTypeViewerVariation = 0x02,
  FSActionCallbackAppInfoTypeViewerVersion = 0x03,
  FSActionCallbackAppInfoTypeAppVersion = 0x04
};

typedef NS_ENUM(NSInteger, FSActionCallbackMailType) {
  FSActionCallbackMailTypeDoc = 0,
  FSActionCallbackMailTypeForm = 1,
  FSActionCallbackMailTypeMsg = 2
};





@interface FSDocumentsSource : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDirectory: (NSString *)directory;
-(id)initWithOther: (FSDocumentsSource*)other;
-(BOOL)isEmpty;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSFullTextSearchRankMode) {
  FSFullTextSearchRankNone = 0,
  FSFullTextSearchRankHitCountASC = 1,
  FSFullTextSearchRankHitCountDESC = 2
};

@interface FSFullTextSearch : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSFullTextSearch*)other;
-(BOOL)isEmpty;
-(void)setDataBasePath: (NSString *)path_of_data_base;
-(FSProgressive*)startUpdateIndex: (FSDocumentsSource*)source pause: (id<FSPauseCallback>)pause reupdate: (BOOL)reupdate;
-(BOOL)updateIndexWithFilePath: (NSString *)file_path;
-(BOOL)searchOf: (NSString *)match_string rank_mode: (FSFullTextSearchRankMode)rank_mode callback: (id<FSSearchCallback>)callback;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSPDFNameTreeType) {
  FSPDFNameTreeDests = 1,
  FSPDFNameTreeJavaScript = 2,
  FSPDFNameTreeEmbeddedFiles = 3,
  FSPDFNameTreePages = 4,
  FSPDFNameTreeTemplates = 5
};

@interface FSPDFNameTree : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document type: (FSPDFNameTreeType)type;
-(id)initWithOther: (FSPDFNameTree*)other;
-(BOOL)isEmpty;
-(FSPDFNameTreeType)getType;
-(BOOL)hasName: (NSString *)name;
-(int)getCount;
-(NSString *)getName: (int)index;
-(FSPDFObject*)getObj: (NSString *)name;
-(BOOL)setObj: (NSString *)name pdf_object: (FSPDFObject*)pdf_object;
-(BOOL)rename: (NSString *)old_name new_name: (NSString *)new_name;
-(BOOL)add: (NSString *)name pdf_object: (FSPDFObject*)pdf_object;
-(BOOL)removeObj: (NSString *)name;
-(BOOL)removeAllObjs;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSPDFObjectType) {
  FSPDFObjectInvalidType = 0,
  FSPDFObjectBoolean = 1,
  FSPDFObjectNumber = 2,
  FSPDFObjectString = 3,
  FSPDFObjectName = 4,
  FSPDFObjectArray = 5,
  FSPDFObjectDictionary = 6,
  FSPDFObjectStream = 7,
  FSPDFObjectNull = 8,
  FSPDFObjectReference = 9
};

@interface FSPDFObject : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSPDFObject*)createFromBoolean: (BOOL)boolean_value;
+(FSPDFObject*)createFromFloat: (float)float_value;
+(FSPDFObject*)createFromInteger: (int)integer_value;
+(FSPDFObject*)createFromString: (NSString *)string_value;
+(FSPDFObject*)createFromName: (NSString *)name;
+(FSPDFObject*)createFromDateTime: (FSDateTime*)date_time;
+(FSPDFObject*)createReference: (FSPDFDoc*)document object_number: (unsigned int)object_number;
-(void)destroy;
-(FSPDFObject*)cloneObject;
-(FSPDFObject*)deepCloneObject;
-(BOOL)isIdentical: (FSPDFObject*)pdf_obj;
-(FSPDFObjectType)getType;
-(unsigned int)getObjNum;
-(int)getInteger;
-(float)getFloat;
-(BOOL)getBoolean;
-(FSMatrix2D*)getMatrix;
-(FSRectF*)getRect;
-(FSPDFObject*)getDirectObject;
-(FSDateTime*)getDateTime;
-(NSString *)getName;
-(NSData *)getString;
-(NSString *)getWideString;
-(FSPDFArray*)getArray;
-(FSPDFDictionary*)getDict;
-(FSPDFStream*)getStream;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSPDFStreamFilter) {
  FSPDFStreamUnknown = -1,
  FSPDFStreamNoneDecode = 0,
  FSPDFStreamASCIIHexDecode = 1,
  FSPDFStreamASCII85Decode = 2,
  FSPDFStreamLZWDecode = 3,
  FSPDFStreamFlateDecode = 4,
  FSPDFStreamRunLengthDecode = 5,
  FSPDFStreamCCITTFaxDecode = 6,
  FSPDFStreamJBIG2Decode = 7,
  FSPDFStreamDCTDecode = 8,
  FSPDFStreamJPXDecode = 9,
  FSPDFStreamCrypt = 10
};

@interface FSPDFStream : FSPDFObject
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSPDFStream*)create: (FSPDFDictionary*)dictionary;
-(FSPDFDictionary*)getDictionary;
-(FSPDFStreamFilter)getStreamFilter;
-(unsigned long long)getDataSize: (BOOL)is_raw_data;
-(void)importData: (id<FSFileReaderCallback>)file_read stream_filter: (FSPDFStreamFilter)stream_filter;
-(id<FSFileReaderCallback>)exportData: (BOOL)is_raw_data;
-(NSData *)getData: (BOOL)is_raw_data;
-(void)setData: (NSData *)buffer;

-(void)dealloc;

@end

@interface FSPDFArray : FSPDFObject
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSPDFArray*)create;
+(FSPDFArray*)createFromMatrix: (FSMatrix2D*)matrix;
+(FSPDFArray*)createFromRect: (FSRectF*)rect;
-(int)getElementCount;
-(FSPDFObject*)getElement: (int)index;
-(void)addElement: (FSPDFObject*)element;
-(void)addBoolean: (BOOL)boolean_value;
-(void)addDateTime: (FSDateTime*)date_time;
-(void)addFloat: (float)float_value;
-(void)addInteger: (int)integer_value;
-(void)addMatrix: (FSMatrix2D*)matrix;
-(void)addRect: (FSRectF*)rect;
-(void)addName: (NSString *)name;
-(void)addString: (NSString *)new_string;
-(void)insertAt: (int)index element: (FSPDFObject*)element;
-(void)setAt: (int)index element: (FSPDFObject*)element;
-(void)removeAt: (int)index;

-(void)dealloc;

@end

@interface FSPDFDictionary : FSPDFObject
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSPDFDictionary*)create;
-(BOOL)hasKey: (NSString *)key;
-(FSPDFObject*)getElement: (NSString *)key;
-(long)moveNext: (long)position;
-(NSString *)getKey: (long)position;
-(FSPDFObject*)getValue: (long)position;
-(void)setAt: (NSString *)key pdf_object: (FSPDFObject*)pdf_object;
-(void)setAtReference: (NSString *)key pdf_object: (FSPDFObject*)pdf_object document: (FSPDFDoc*)document;
-(void)setAtBoolean: (NSString *)key value: (BOOL)value;
-(void)setAtDateTime: (NSString *)key value: (FSDateTime*)value;
-(void)setAtFloat: (NSString *)key value: (float)value;
-(void)setAtInteger: (NSString *)key value: (int)value;
-(void)setAtMatrix: (NSString *)key value: (FSMatrix2D*)value;
-(void)setAtRect: (NSString *)key value: (FSRectF*)value;
-(void)setAtName: (NSString *)key value: (NSString *)value;
-(void)setAtString: (NSString *)key value: (NSString *)value;
-(void)removeAt: (NSString *)key;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSPDFNumberTreeType) {
  FSPDFNumberTreePageLabels = 1
};

@interface FSPDFNumberTree : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document type: (FSPDFNumberTreeType)type;
-(id)initWithOther: (FSPDFNumberTree*)other;
-(BOOL)isEmpty;
-(FSPDFNumberTreeType)getType;
-(BOOL)hasNumber: (int)number;
-(FSPDFObject*)getObj: (int)number;
-(BOOL)setObj: (int)number pdf_object: (FSPDFObject*)pdf_object;
-(BOOL)removeObj: (int)number;
-(BOOL)removeAllObjs;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSRenditionMediaOptionType) {
  FSRenditionMediaOptionMustBeHonored = 0,
  FSRenditionMediaOptionBestEffort = 1
};

typedef NS_ENUM(NSInteger, FSRenditionMediaPermission) {
  FSRenditionMediaPermTempNever = 0,
  FSRenditionMediaPermTempExtract = 1,
  FSRenditionMediaPermTempAccess = 2,
  FSRenditionMediaPermTempAlways = 3
};

typedef NS_ENUM(NSInteger, FSRenditionMediaPlayerType) {
  FSRenditionMediaPlayerMustUsed = 0,
  FSRenditionMediaPlayerAvailable = 1,
  FSRenditionMediaPlayerNotUsed = 2
};

typedef NS_ENUM(NSInteger, FSRenditionMediaPlayerFitStyle) {
  FSRenditionMediaPlayerFitStyleMeet = 0,
  FSRenditionMediaPlayerFitStyleSlice = 1,
  FSRenditionMediaPlayerFitStyleFill = 2,
  FSRenditionMediaPlayerFitStyleScroll = 3,
  FSRenditionMediaPlayerFitStyleHidden = 4,
  FSRenditionMediaPlayerFitStyleDefault = 5
};

typedef NS_ENUM(NSInteger, FSRenditionWindowType) {
  FSRenditionWindowTypeFloating = 0,
  FSRenditionWindowTypeFullScreen = 1,
  FSRenditionWindowTypeHidden = 2,
  FSRenditionWindowTypeAnnotRect = 3
};

typedef NS_ENUM(NSInteger, FSRenditionMonitorSpecifier) {
  FSRenditionMonitorSpecifierLargest = 0,
  FSRenditionMonitorSpecifierSmallest = 1,
  FSRenditionMonitorSpecifierPrimary = 2,
  FSRenditionMonitorSpecifierGreatestColorDepth = 3,
  FSRenditionMonitorSpecifierGreatestArea = 4,
  FSRenditionMonitorSpecifierGreatestHeight = 5,
  FSRenditionMonitorSpecifierGreatestWidth = 6
};

typedef NS_ENUM(NSInteger, FSRenditionFloatingWindowRelatedWindowType) {
  FSRenditionFloatingWindowRelatedWindowDocument = 0,
  FSRenditionFloatingWindowRelatedWindowApplication = 1,
  FSRenditionFloatingWindowRelatedWindowFullDesktop = 2,
  FSRenditionFloatingWindowRelatedWindowMonitor = 3
};

typedef NS_ENUM(NSInteger, FSRenditionFloatingWindowResizeType) {
  FSRenditionFloatingWindowResizeTypeNo = 0,
  FSRenditionFloatingWindowResizeTypeAspectRatio = 1,
  FSRenditionFloatingWindowResizeTypeAnyway = 2
};

typedef NS_ENUM(NSInteger, FSRenditionFloatingWindowOffscreenEvent) {
  FSRenditionFloatingWindowOffscreenEventNone = 0,
  FSRenditionFloatingWindowOffscreenEventMoveResize = 1,
  FSRenditionFloatingWindowOffscreenEventNonViable = 2
};

@interface FSRendition : FSBase
@property (nonatomic, copy, getter=getRenditionName) NSString * renditionName;
@property (nonatomic, copy, getter=getMediaClipName) NSString * mediaClipName;
@property (nonatomic, copy, getter=getMediaClipFile) FSFileSpec* mediaClipFile;
@property (nonatomic, copy, getter=getMediaClipContentType) NSString * mediaClipContentType;
@property (nonatomic, getter=getPermission) FSRenditionMediaPermission permission;
@property (nonatomic, copy, getter=getMediaDescriptions) NSArray<NSString *> * mediaDescriptions;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithPdf_doc: (FSPDFDoc*)pdf_doc rendition_dict: (FSPDFDictionary*)rendition_dict;
-(id)initWithOther: (FSRendition*)other;
-(BOOL)isEmpty;
-(FSPDFDictionary*)getDict;
-(BOOL)hasMediaClip;
-(NSString *)getMediaBaseURL;
-(void)setMediaBaseURL: (NSString *)base_url opt_type: (FSRenditionMediaOptionType)opt_type;
-(int)getMediaPlayerCount: (FSRenditionMediaPlayerType)type;
-(FSMediaPlayer*)getMediaPlayer: (FSRenditionMediaPlayerType)type index: (int)index;
-(int)addMediaPlayer: (FSRenditionMediaPlayerType)type player: (FSMediaPlayer*)player;
-(void)removeMediaPlayer: (FSRenditionMediaPlayerType)type player: (FSMediaPlayer*)player;
-(int)getVolume;
-(void)setVolume: (int)volume opt_type: (FSRenditionMediaOptionType)opt_type;
-(BOOL)isControlBarVisible;
-(void)enableControlBarVisible: (BOOL)is_visible opt_type: (FSRenditionMediaOptionType)opt_type;
-(FSRenditionMediaPlayerFitStyle)getFitStyle;
-(void)setFitStyle: (FSRenditionMediaPlayerFitStyle)fit_style opt_type: (FSRenditionMediaOptionType)opt_type;
-(int)getDuration;
-(void)setDuration: (int)duration opt_type: (FSRenditionMediaOptionType)opt_type;
-(BOOL)isAutoPlay;
-(void)enableAutoPlay: (BOOL)is_auto_play opt_type: (FSRenditionMediaOptionType)opt_type;
-(int)getRepeatCount;
-(void)setRepeatCount: (int)count opt_type: (FSRenditionMediaOptionType)opt_type;
-(FSRenditionWindowType)getWindowType;
-(void)setWindowType: (FSRenditionWindowType)window_type opt_type: (FSRenditionMediaOptionType)opt_type;
-(unsigned int)getBackgroundColor;
-(void)setBackgroundColor: (unsigned int)color opt_type: (FSRenditionMediaOptionType)opt_type;
-(float)getBackgroundOpacity;
-(void)setBackgroundOpacity: (float)opacity opt_type: (FSRenditionMediaOptionType)opt_type;
-(FSRenditionMonitorSpecifier)getMonitorSpecifier;
-(void)setMonitorSpecifier: (FSRenditionMonitorSpecifier)monitor_specifier opt_type: (FSRenditionMediaOptionType)opt_type;
-(int)getFloatingWindowWidth;
-(int)getFloatingWindowHeight;
-(void)setFloatingWindowSize: (int)width height: (int)height opt_type: (FSRenditionMediaOptionType)opt_type;
-(FSRenditionFloatingWindowRelatedWindowType)getFloatingWindowRelatedWindowType;
-(void)setFloatingWindowRelatedWindowType: (FSRenditionFloatingWindowRelatedWindowType)window_type opt_type: (FSRenditionMediaOptionType)opt_type;
-(FSPosition)getFloatingWindowPosition;
-(void)setFloatingWindowPosition: (FSPosition)position opt_type: (FSRenditionMediaOptionType)opt_type;
-(FSRenditionFloatingWindowOffscreenEvent)getFloatingWindowOffscreenEvent;
-(void)setFloatingWindowOffscreenEvent: (FSRenditionFloatingWindowOffscreenEvent)offscreen_event opt_type: (FSRenditionMediaOptionType)opt_type;
-(BOOL)hasFloatingWindowTitleBar;
-(void)enableFloatingWindowTitleBar: (BOOL)is_visible opt_type: (FSRenditionMediaOptionType)opt_type;
-(BOOL)hasFloatingWindowCloseButton;
-(void)enableFloatingWindowCloseButton: (BOOL)is_visible opt_type: (FSRenditionMediaOptionType)opt_type;
-(FSRenditionFloatingWindowResizeType)getFloatingWindowResizeType;
-(void)setFloatingWindowResizeType: (FSRenditionFloatingWindowResizeType)resize_type opt_type: (FSRenditionMediaOptionType)opt_type;
-(NSArray<NSString *> *)getFloatingWindowTitles;
-(void)setFloatingWindowTitles: (NSArray<NSString *> *)titles opt_type: (FSRenditionMediaOptionType)opt_type;

-(void)dealloc;

@end

@interface FSMediaPlayer : FSBase
@property (nonatomic, copy, getter=getSoftwareURI) NSString * softwareURI;
@property (nonatomic, copy, getter=getOSIdentifiers) NSArray<NSData *> * oSIdentifiers;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithMedia_player_dict: (FSPDFDictionary*)media_player_dict;
-(id)initWithOther: (FSMediaPlayer*)other;
-(BOOL)isEmpty;
-(FSPDFDictionary*)getDict;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSDestinationZoomMode) {
  FSDestinationZoomXYZ = 1,
  FSDestinationZoomFitPage = 2,
  FSDestinationZoomFitHorz = 3,
  FSDestinationZoomFitVert = 4,
  FSDestinationZoomFitRect = 5,
  FSDestinationZoomFitBBox = 6,
  FSDestinationZoomFitBHorz = 7,
  FSDestinationZoomFitBVert = 8
};

@interface FSDestination : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSDestination*)createXYZ: (FSPDFDoc*)document page_index: (int)page_index left: (float)left top: (float)top zoom_factor: (float)zoom_factor;
+(FSDestination*)createFitPage: (FSPDFDoc*)document page_index: (int)page_index;
+(FSDestination*)createFitHorz: (FSPDFDoc*)document page_index: (int)page_index top: (float)top;
+(FSDestination*)createFitVert: (FSPDFDoc*)document page_index: (int)page_index left: (float)left;
+(FSDestination*)createFitRect: (FSPDFDoc*)document page_index: (int)page_index left: (float)left bottom: (float)bottom right: (float)right top: (float)top;
+(FSDestination*)createFitBBox: (FSPDFDoc*)document page_index: (int)page_index;
+(FSDestination*)createFitBHorz: (FSPDFDoc*)document page_index: (int)page_index top: (float)top;
+(FSDestination*)createFitBVert: (FSPDFDoc*)document page_index: (int)page_index left: (float)left;
+(FSDestination*)createFromPDFArray: (FSPDFDoc*)document pdf_array: (FSPDFArray*)pdf_array;
-(id)initWithDest_array: (FSPDFArray*)dest_array;
-(id)initWithOther: (FSDestination*)other;
-(BOOL)isEmpty;
-(int)getPageIndex: (FSPDFDoc*)document;
-(FSDestinationZoomMode)getZoomMode;
-(float)getLeft;
-(BOOL)isLeftNull;
-(float)getTop;
-(BOOL)isTopNull;
-(float)getRight;
-(float)getBottom;
-(float)getZoomFactor;
-(FSPDFArray*)getDestArray;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSActionType) {
  FSActionTypeUnknown = 0,
  FSActionTypeGoto = 1,
  FSActionTypeGoToR = 2,
  FSActionTypeGoToE = 3,
  FSActionTypeLaunch = 4,
  FSActionTypeThread = 5,
  FSActionTypeURI = 6,
  FSActionTypeSound = 7,
  FSActionTypeMovie = 8,
  FSActionTypeHide = 9,
  FSActionTypeNamed = 10,
  FSActionTypeSubmitForm = 11,
  FSActionTypeResetForm = 12,
  FSActionTypeImportData = 13,
  FSActionTypeJavaScript = 14,
  FSActionTypeSetOCGState = 15,
  FSActionTypeRendition = 16,
  FSActionTypeTrans = 17,
  FSActionTypeGoTo3DView = 18
};

typedef NS_ENUM(NSInteger, FSActionNewWindowFlag) {
  FSActionNewWindowFlagFalse = 0,
  FSActionNewWindowFlagTrue = 1,
  FSActionNewWindowFlagNone = 2
};

@interface FSAction : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSAction*)create: (FSPDFDoc*)document action_type: (FSActionType)action_type;
-(id)initWithDocument: (FSPDFDoc*)document action_dict: (FSPDFDictionary*)action_dict;
-(id)initWithAction: (FSAction*)action;
-(BOOL)isEmpty;
-(FSActionType)getType;
-(FSPDFDoc*)getDocument;
-(FSPDFDictionary*)getDict;
-(int)getSubActionCount;
-(FSAction*)getSubAction: (int)index;
-(void)setSubAction: (int)index sub_action: (FSAction*)sub_action;
-(void)insertSubAction: (int)index sub_action: (FSAction*)sub_action;
-(void)removeSubAction: (int)index;
-(void)removeAllSubActions;

-(void)dealloc;

@end

@interface FSGotoAction : FSAction
@property (nonatomic, copy, getter=getDestination) FSDestination* destination;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAction: (FSAction*)action;

-(void)dealloc;

@end

@interface FSURIAction : FSAction
@property (nonatomic, copy, getter=getURI) NSString * uRI;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAction: (FSAction*)action;
-(BOOL)isTrackPosition;
-(void)setTrackPositionFlag: (BOOL)is_track_position;

-(void)dealloc;

@end

@interface FSJavaScriptAction : FSAction
@property (nonatomic, copy, getter=getScript) NSString * script;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAction: (FSAction*)action;

-(void)dealloc;

@end

@interface FSNamedAction : FSAction
@property (nonatomic, copy, getter=getName) NSString * name;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAction: (FSAction*)action;

-(void)dealloc;

@end

@interface FSRemoteGotoAction : FSAction
@property (nonatomic, copy, getter=getDestination) FSDestination* destination;
@property (nonatomic, copy, getter=getDestinationName) NSString * destinationName;
@property (nonatomic, copy, getter=getFileSpec) FSFileSpec* fileSpec;
@property (nonatomic, getter=getNewWindowFlag) FSActionNewWindowFlag newWindowFlag;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAction: (FSAction*)action;

-(void)dealloc;

@end

@interface FSEmbeddedGotoTarget : FSBase
@property (nonatomic, copy, getter=getRelationship) NSString * relationship;
@property (nonatomic, copy, getter=getAttachedFileName) NSString * attachedFileName;
@property (nonatomic, getter=getPageIndex) int pageIndex;
@property (nonatomic, getter=getFileAttachmentAnnotIndex) int fileAttachmentAnnotIndex;
@property (nonatomic, copy, getter=getTarget) FSEmbeddedGotoTarget* target;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document;
-(id)initWithDocument: (FSPDFDoc*)document target_object: (FSPDFDictionary*)target_object;
-(id)initWithAction: (FSEmbeddedGotoTarget*)action;
-(FSPDFDictionary*)getDict;
-(BOOL)isEmpty;

-(void)dealloc;

@end

@interface FSEmbeddedGotoAction : FSAction
@property (nonatomic, copy, getter=getDestination) FSDestination* destination;
@property (nonatomic, copy, getter=getDestinationName) NSString * destinationName;
@property (nonatomic, copy, getter=getRootFile) FSFileSpec* rootFile;
@property (nonatomic, getter=getNewWindowFlag) FSActionNewWindowFlag newWindowFlag;
@property (nonatomic, copy, getter=getTarget) FSEmbeddedGotoTarget* target;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAction: (FSAction*)action;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSSubmitFormActionFlags) {
  FSSubmitFormActionFlagExclude = 0x0001,
  FSSubmitFormActionFlagIncludeNoValueFields = 0x0002,
  FSSubmitFormActionFlagExportFormat = 0x0004,
  FSSubmitFormActionFlagGetMethod = 0x0008,
  FSSubmitFormActionFlagWithCoordinates = 0x0010,
  FSSubmitFormActionFlagAsXFDF = 0x0020,
  FSSubmitFormActionFlagIncludeAppendSaves = 0x0040,
  FSSubmitFormActionFlagIncludeAnnotations = 0x0080,
  FSSubmitFormActionFlagSubmitAsPDF = 0x0100,
  FSSubmitFormActionFlagCanonicalFormat = 0x0200,
  FSSubmitFormActionFlagExclNonUserAnnots = 0x0400,
  FSSubmitFormActionFlagExclFKey = 0x0800,
  FSSubmitFormActionFlagEmbedForm = 0x2000
};

@interface FSSubmitFormAction : FSAction
@property (nonatomic, copy, getter=getURL) NSString * uRL;
@property (nonatomic, copy, getter=getFieldNames) NSArray<NSString *> * fieldNames;
@property (nonatomic, getter=getFlags) unsigned int flags;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAction: (FSAction*)action;

-(void)dealloc;

@end

@interface FSResetFormAction : FSAction
@property (nonatomic, copy, getter=getFieldNames) NSArray<NSString *> * fieldNames;
@property (nonatomic, getter=getFlags) unsigned int flags;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAction: (FSAction*)action;

-(void)dealloc;

@end

@interface FSImportDataAction : FSAction
@property (nonatomic, copy, getter=getFDFFileSpec) FSFileSpec* fDFFileSpec;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAction: (FSAction*)action;

-(void)dealloc;

@end

@interface FSHideAction : FSAction
@property (nonatomic, copy, getter=getFieldNames) NSArray<NSString *> * fieldNames;
@property (nonatomic, getter=getHideState) BOOL hideState;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAction: (FSAction*)action;

-(void)dealloc;

@end

@interface FSLaunchAction : FSAction
@property (nonatomic, copy, getter=getFileSpec) FSFileSpec* fileSpec;
@property (nonatomic, getter=getNewWindowFlag) FSActionNewWindowFlag newWindowFlag;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAction: (FSAction*)action;
-(NSString *)getWinFileName;
-(NSString *)getWinDefaultDirectory;
-(NSString *)getWinAppOperation;
-(NSString *)getWinAppParameter;
-(void)setWinLaunchParameter: (NSString *)file_name default_directory: (NSString *)default_directory operation: (NSString *)operation app_parameter: (NSString *)app_parameter;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSRenditionActionOperationType) {
  FSRenditionActionOpTypeNone = -1,
  FSRenditionActionOpTypeAssociate = 0,
  FSRenditionActionOpTypeStop = 1,
  FSRenditionActionOpTypePause = 2,
  FSRenditionActionOpTypeResume = 3,
  FSRenditionActionOpTypePlay = 4
};

@interface FSRenditionAction : FSAction
@property (nonatomic, getter=getOperationType) FSRenditionActionOperationType operationType;
@property (nonatomic, copy, getter=getScreenAnnot) FSScreen* screenAnnot;
@property (nonatomic, copy, getter=getJavaScript) NSString * javaScript;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAction: (FSAction*)action;
-(int)getRenditionCount;
-(FSRendition*)getRendition: (int)index;
-(void)insertRendition: (FSRendition*)rendition index: (int)index;
-(void)removeRendition: (FSRendition*)rendition;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSAdditionalActionTriggerEvent) {
  FSAdditionalActionTriggerPageOpened = 0,
  FSAdditionalActionTriggerPageClosed = 1,
  FSAdditionalActionTriggerDocWillClose = 2,
  FSAdditionalActionTriggerDocWillSave = 3,
  FSAdditionalActionTriggerDocSaved = 4,
  FSAdditionalActionTriggerDocWillPrint = 5,
  FSAdditionalActionTriggerDocPrinted = 6,
  FSAdditionalActionTriggerFieldKeyStroke = 7,
  FSAdditionalActionTriggerFieldWillFormat = 8,
  FSAdditionalActionTriggerFieldValueChanged = 9,
  FSAdditionalActionTriggerFieldRecalculateValue = 10,
  FSAdditionalActionTriggerAnnotCursorEnter = 11,
  FSAdditionalActionTriggerAnnotCursorExit = 12,
  FSAdditionalActionTriggerAnnotMouseButtonPressed = 13,
  FSAdditionalActionTriggerAnnotMouseButtonReleased = 14,
  FSAdditionalActionTriggerAnnotReceiveInputFocus = 15,
  FSAdditionalActionTriggerAnnotLoseInputFocus = 16,
  FSAdditionalActionTriggerAnnotPageOpened = 17,
  FSAdditionalActionTriggerAnnotPageClosed = 18,
  FSAdditionalActionTriggerAnnotPageVisible = 19,
  FSAdditionalActionTriggerAnnotPageInvisible = 20
};

@interface FSAdditionalAction : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDoc: (FSPDFDoc*)doc pdf_dict: (FSPDFDictionary*)pdf_dict;
-(id)initWithField: (FSField*)field;
-(id)initWithAnnot: (FSAnnot*)annot;
-(id)initWithOther: (FSAdditionalAction*)other;
-(BOOL)isEmpty;
-(FSAction*)getAction: (FSAdditionalActionTriggerEvent)trigger;
-(void)setAction: (FSAdditionalActionTriggerEvent)trigger action: (FSAction*)action;
-(BOOL)removeAction: (FSAdditionalActionTriggerEvent)trigger;
-(BOOL)removeAllActions;
-(BOOL)doJSAction: (FSAdditionalActionTriggerEvent)trigger;
-(FSPDFDictionary*)getDict;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSDefaultAppearanceDefAPFlags) {
  FSDefaultAppearanceFlagFont = 0x0001,
  FSDefaultAppearanceFlagTextColor = 0x0002,
  FSDefaultAppearanceFlagFontSize = 0x0004
};

@interface FSDefaultAppearance : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getFlags) unsigned int flags;
@property (nonatomic, getter=getText_size) float text_size;
@property (nonatomic, getter=getText_color) unsigned int text_color;
@property (nonatomic, copy, getter=getFont) FSFont* font;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithFlags: (unsigned int)flags font: (FSFont*)font text_size: (float)text_size text_color: (unsigned int)text_color;
-(id)init;
-(id)initWithDefault_appearance: (FSDefaultAppearance*)default_appearance;
-(void)set: (unsigned int)flags font: (FSFont*)font text_size: (float)text_size text_color: (unsigned int)text_color;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSRichTextStyleCornerMarkStyle) {
  FSRichTextStyleCornerMarkNone = 1,
  FSRichTextStyleCornerMarkSuperscript = 2,
  FSRichTextStyleCornerMarkSubscript = 3
};

@interface FSRichTextStyle : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getFont) FSFont* font;
@property (nonatomic, getter=getText_size) float text_size;
@property (nonatomic, getter=getText_alignment) FSAlignment text_alignment;
@property (nonatomic, getter=getText_color) unsigned int text_color;
@property (nonatomic, getter=getIs_bold) BOOL is_bold;
@property (nonatomic, getter=getIs_italic) BOOL is_italic;
@property (nonatomic, getter=getIs_underline) BOOL is_underline;
@property (nonatomic, getter=getIs_strikethrough) BOOL is_strikethrough;
@property (nonatomic, getter=getMark_style) FSRichTextStyleCornerMarkStyle mark_style;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithFont: (FSFont*)font text_size: (float)text_size text_alignment: (FSAlignment)text_alignment text_color: (unsigned int)text_color is_bold: (BOOL)is_bold is_italic: (BOOL)is_italic is_underline: (BOOL)is_underline is_strikethrough: (BOOL)is_strikethrough mark_style: (FSRichTextStyleCornerMarkStyle)mark_style;
-(id)initWithStyle: (FSRichTextStyle*)style;
-(void)set: (FSFont*)font text_size: (float)text_size text_alignment: (FSAlignment)text_alignment text_color: (unsigned int)text_color is_bold: (BOOL)is_bold is_italic: (BOOL)is_italic is_underline: (BOOL)is_underline is_strikethrough: (BOOL)is_strikethrough mark_style: (FSRichTextStyleCornerMarkStyle)mark_style;
-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSBorderInfoStyle) {
  FSBorderInfoSolid = 0,
  FSBorderInfoDashed = 1,
  FSBorderInfoUnderLine = 2,
  FSBorderInfoBeveled = 3,
  FSBorderInfoInset = 4,
  FSBorderInfoCloudy = 5
};

@interface FSBorderInfo : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getWidth) float width;
@property (nonatomic, getter=getStyle) FSBorderInfoStyle style;
@property (nonatomic, getter=getCloud_intensity) float cloud_intensity;
@property (nonatomic, getter=getDash_phase) float dash_phase;
@property (nonatomic, copy, getter=getDashes) FSFloatArray* dashes;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithWidth: (float)width style: (FSBorderInfoStyle)style intensity: (float)intensity dash_phase: (float)dash_phase dashes: (FSFloatArray*)dashes;
-(id)init;
-(id)initWithBorder_info: (FSBorderInfo*)border_info;
-(void)set: (float)width style: (FSBorderInfoStyle)style intensity: (float)intensity dash_phase: (float)dash_phase dashes: (FSFloatArray*)dashes;
-(void)dealloc;

@end

@interface FSQuadPoints : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getFirst) FSPointF* first;
@property (nonatomic, copy, getter=getSecond) FSPointF* second;
@property (nonatomic, copy, getter=getThird) FSPointF* third;
@property (nonatomic, copy, getter=getFourth) FSPointF* fourth;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithFirst: (FSPointF*)first second: (FSPointF*)second third: (FSPointF*)third fourth: (FSPointF*)fourth;
-(id)init;
-(id)initWithQuad_points: (FSQuadPoints*)quad_points;
-(void)set: (FSPointF*)first second: (FSPointF*)second third: (FSPointF*)third fourth: (FSPointF*)fourth;

-(void)dealloc;

@end

@interface FSQuadPointsArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSQuadPointsArray*)other;
-(unsigned long)getSize;
-(FSQuadPoints*)getAt: (unsigned long)index;
-(void)add: (FSQuadPoints*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSQuadPoints*)element;
-(void)removeAll;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSIconFitScaleWayType) {
  FSIconFitScaleWayNone = 0,
  FSIconFitScaleWayAlways = 1,
  FSIconFitScaleWayBigger = 2,
  FSIconFitScaleWaySmaller = 3,
  FSIconFitScaleWayNever = 4
};

@interface FSIconFit : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getScale_way_type) FSIconFitScaleWayType scale_way_type;
@property (nonatomic, getter=getIs_proportional_scaling) BOOL is_proportional_scaling;
@property (nonatomic, getter=getHorizontal_fraction) float horizontal_fraction;
@property (nonatomic, getter=getVertical_fraction) float vertical_fraction;
@property (nonatomic, getter=getFit_bounds) BOOL fit_bounds;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithType: (FSIconFitScaleWayType)type is_proportional_scaling: (BOOL)is_proportional_scaling horizontal_fraction: (float)horizontal_fraction vertical_fraction: (float)vertical_fraction fit_bounds: (BOOL)fit_bounds;
-(id)initWithIcon_fit: (FSIconFit*)icon_fit;
-(void)set: (FSIconFitScaleWayType)type is_proportional_scaling: (BOOL)is_proportional_scaling horizontal_fraction: (float)horizontal_fraction vertical_fraction: (float)vertical_fraction fit_bounds: (BOOL)fit_bounds;
-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSAnnotType) {
  FSAnnotUnknownType = 0,
  FSAnnotNote = 1,
  FSAnnotLink = 2,
  FSAnnotFreeText = 3,
  FSAnnotLine = 4,
  FSAnnotSquare = 5,
  FSAnnotCircle = 6,
  FSAnnotPolygon = 7,
  FSAnnotPolyLine = 8,
  FSAnnotHighlight = 9,
  FSAnnotUnderline = 10,
  FSAnnotSquiggly = 11,
  FSAnnotStrikeOut = 12,
  FSAnnotStamp = 13,
  FSAnnotCaret = 14,
  FSAnnotInk = 15,
  FSAnnotPSInk = 16,
  FSAnnotFileAttachment = 17,
  FSAnnotSound = 18,
  FSAnnotMovie = 19,
  FSAnnotWidget = 20,
  FSAnnotScreen = 21,
  FSAnnotPrinterMark = 22,
  FSAnnotTrapNet = 23,
  FSAnnotWatermark = 24,
  FSAnnot3D = 25,
  FSAnnotPopup = 26,
  FSAnnotRedact = 27,
  FSAnnotRichMedia = 28
};

typedef NS_ENUM(NSInteger, FSAnnotFlags) {
  FSAnnotFlagInvisible = 0x0001,
  FSAnnotFlagHidden = 0x0002,
  FSAnnotFlagPrint = 0x0004,
  FSAnnotFlagNoZoom = 0x0008,
  FSAnnotFlagNoRotate = 0x0010,
  FSAnnotFlagNoView = 0x0020,
  FSAnnotFlagReadOnly = 0x0040,
  FSAnnotFlagLocked = 0x0080,
  FSAnnotFlagToggleNoView = 0x0100,
  FSAnnotFlagLockedContents = 0x0200
};

typedef NS_ENUM(NSInteger, FSAnnotHighlightingMode) {
  FSAnnotHighlightingNone = 0,
  FSAnnotHighlightingInvert = 1,
  FSAnnotHighlightingOutline = 2,
  FSAnnotHighlightingPush = 3,
  FSAnnotHighlightingToggle = 4
};

typedef NS_ENUM(NSInteger, FSAnnotProperty) {
  FSAnnotPropertyModifiedDate = 0,
  FSAnnotPropertyCreationDate = 1,
  FSAnnotPropertyBorderColor = 2,
  FSAnnotPropertyFillColor = 3
};

typedef NS_ENUM(NSInteger, FSAnnotMKEntry) {
  FSAnnotMKEntryRotation = 0,
  FSAnnotMKEntryBorderColor = 1,
  FSAnnotMKEntryBackgroundColor = 2,
  FSAnnotMKEntryNormalCaption = 3,
  FSAnnotMKEntryRolloverCaption = 4,
  FSAnnotMKEntryDownCaption = 5,
  FSAnnotMKEntryNormalIcon = 6,
  FSAnnotMKEntryRolloverIcon = 7,
  FSAnnotMKEntryDownIcon = 8,
  FSAnnotMKEntryIconFit = 9,
  FSAnnotMKEntryIconCaptionRelation = 10
};

typedef NS_ENUM(NSInteger, FSAnnotMKIconCaptionRelation) {
  FSAnnotMKRelationNoIcon = 0,
  FSAnnotMKRelationNoCaption = 1,
  FSAnnotMKRelationCaptionBelowIcon = 2,
  FSAnnotMKRelationCaptionAboveIcon = 3,
  FSAnnotMKRelationCaptionRight = 4,
  FSAnnotMKRelationCaptionLeft = 5,
  FSAnnotMKRelationCaptionOvrlayOnIcon = 6
};

typedef NS_ENUM(NSInteger, FSAnnotAppearanceType) {
  FSAnnotAppearanceTypeNormal = 0,
  FSAnnotAppearanceTypeRollover = 1,
  FSAnnotAppearanceTypeDown = 2
};

@interface FSAnnot : FSBase
@property (nonatomic, copy, getter=getContent) NSString * content;
@property (nonatomic, copy, getter=getModifiedDateTime) FSDateTime* modifiedDateTime;
@property (nonatomic, getter=getFlags) unsigned int flags;
@property (nonatomic, copy, getter=getUniqueID) NSString * uniqueID;
@property (nonatomic, copy, getter=getBorderInfo) FSBorderInfo* borderInfo;
@property (nonatomic, getter=getBorderColor) unsigned int borderColor;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithPage: (FSPDFPage*)page annot_dict: (FSPDFDictionary*)annot_dict;
-(id)initWithAnnot: (FSAnnot*)annot;
-(BOOL)isEmpty;
-(FSPDFPage*)getPage;
-(BOOL)isMarkup;
-(FSAnnotType)getType;
-(int)getIndex;
-(FSRectF*)getRect;
-(FSMatrix2D*)getDisplayMatrix: (FSMatrix2D*)page_display_matrix;
-(BOOL)move: (FSRectF*)rect;
-(BOOL)resetAppearanceStream;
-(FSRectI*)getDeviceRect: (FSMatrix2D*)matrix;
-(FSPDFDictionary*)getDict;
-(BOOL)hasProperty: (FSAnnotProperty)property;
-(BOOL)removeProperty: (FSAnnotProperty)property;
-(FSPDFDictionary*)getOptionalContent;
-(FSPDFStream*)getAppearanceStream: (FSAnnotAppearanceType)type appearance_state: (NSString *)appearance_state;

-(void)dealloc;

@end

@interface FSAnnotArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSAnnotArray*)other;
-(unsigned long)getSize;
-(FSAnnot*)getAt: (unsigned long)index;
-(void)add: (FSAnnot*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSAnnot*)element;
-(void)removeAll;

-(void)dealloc;

@end

@interface FSShadingColor : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getFirst_color) unsigned int first_color;
@property (nonatomic, getter=getSecond_color) unsigned int second_color;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithFirstcolor: (unsigned int)firstcolor secondcolor: (unsigned int)secondcolor;
-(id)init;
-(id)initWithShading_color: (FSShadingColor*)shading_color;
-(void)set: (unsigned int)firstcolor secondcolor: (unsigned int)secondcolor;
-(void)dealloc;

@end



@interface FSMarkupArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSMarkupArray*)other;
-(unsigned long)getSize;
-(FSMarkup*)getAt: (unsigned long)index;
-(void)add: (FSMarkup*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSMarkup*)element;
-(void)removeAll;

-(void)dealloc;

@end

@interface FSNoteArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSNoteArray*)other;
-(unsigned long)getSize;
-(FSNote*)getAt: (unsigned long)index;
-(void)add: (FSNote*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSNote*)element;
-(void)removeAll;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSMarkupStateModel) {
  FSMarkupStateModelMarked = 1,
  FSMarkupStateModelReview = 2
};

typedef NS_ENUM(NSInteger, FSMarkupState) {
  FSMarkupStateNone = 0,
  FSMarkupStateMarked = 1,
  FSMarkupStateUnmarked = 2,
  FSMarkupStateAccepted = 3,
  FSMarkupStateRejected = 4,
  FSMarkupStateCancelled = 5,
  FSMarkupStateCompleted = 6,
  FSMarkupStateDeferred = 7,
  FSMarkupStateFuture = 8
};

typedef NS_ENUM(NSInteger, FSMarkupEndingStyle) {
  FSMarkupEndingStyleNone = 0,
  FSMarkupEndingStyleSquare = 1,
  FSMarkupEndingStyleCircle = 2,
  FSMarkupEndingStyleDiamond = 3,
  FSMarkupEndingStyleOpenArrow = 4,
  FSMarkupEndingStyleClosedArrow = 5,
  FSMarkupEndingStyleButt = 6,
  FSMarkupEndingStyleROpenArrow = 7,
  FSMarkupEndingStyleRClosedArrow = 8,
  FSMarkupEndingStyleSlash = 9
};

typedef NS_ENUM(NSInteger, FSMarkupMeasureType) {
  FSMarkupMeasureTypeX = 0,
  FSMarkupMeasureTypeY = 1,
  FSMarkupMeasureTypeD = 2,
  FSMarkupMeasureTypeA = 3,
  FSMarkupMeasureTypeT = 4,
  FSMarkupMeasureTypeS = 5
};

@interface FSMarkup : FSAnnot
@property (nonatomic, copy, getter=getPopup) FSPopup* popup;
@property (nonatomic, copy, getter=getTitle) NSString * title;
@property (nonatomic, copy, getter=getSubject) NSString * subject;
@property (nonatomic, getter=getOpacity) float opacity;
@property (nonatomic, copy, getter=getIntent) NSString * intent;
@property (nonatomic, copy, getter=getCreationDateTime) FSDateTime* creationDateTime;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAnnot: (FSAnnot*)annot;
-(BOOL)removePopup;
-(int)getReplyCount;
-(FSNote*)getReply: (int)index;
-(FSNote*)addReply;
-(BOOL)removeReply: (int)index;
-(BOOL)removeAllReplies;
-(BOOL)isGrouped;
-(FSMarkup*)getGroupHeader;
-(FSMarkupArray*)getGroupElements;
-(BOOL)ungroup;
-(FSNoteArray*)getStateAnnots: (FSMarkupStateModel)model;
-(FSNote*)addStateAnnot: (NSString *)title model: (FSMarkupStateModel)model state: (FSMarkupState)state;
-(BOOL)removeAllStateAnnots;
-(int)getRichTextCount;
-(NSString *)getRichTextContent: (int)index;
-(void)setRichTextContent: (int)index content: (NSString *)content;
-(FSRichTextStyle*)getRichTextStyle: (int)index;
-(void)setRichTextStyle: (int)index style: (FSRichTextStyle*)style;
-(void)addRichText: (NSString *)content style: (FSRichTextStyle*)style;
-(void)insertRichText: (int)index content: (NSString *)content style: (FSRichTextStyle*)style;
-(void)removeRichText: (int)index;

-(void)dealloc;

@end

@interface FSNote : FSMarkup
@property (nonatomic, getter=getOpenStatus) BOOL openStatus;
@property (nonatomic, copy, getter=getIconName) NSString * iconName;
@property (nonatomic, getter=getState) FSMarkupState state;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(FSMarkup*)getReplyTo;
-(BOOL)isStateAnnot;
-(FSMarkupStateModel)getStateModel;

-(void)dealloc;

@end

@interface FSTextMarkup : FSMarkup
@property (nonatomic, copy, getter=getQuadPoints) FSQuadPointsArray* quadPoints;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithAnnot: (FSAnnot*)annot;

-(void)dealloc;

@end

@interface FSHighlight : FSTextMarkup
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;

-(void)dealloc;

@end

@interface FSUnderline : FSTextMarkup
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;

-(void)dealloc;

@end

@interface FSStrikeOut : FSTextMarkup
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;

-(void)dealloc;

@end

@interface FSSquiggly : FSTextMarkup
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;

-(void)dealloc;

@end

@interface FSLink : FSAnnot
@property (nonatomic, copy, getter=getQuadPoints) FSQuadPointsArray* quadPoints;
@property (nonatomic, getter=getHighlightingMode) FSAnnotHighlightingMode highlightingMode;
@property (nonatomic, copy, getter=getAction) FSAction* action;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(BOOL)removeAction;

-(void)dealloc;

@end

@interface FSSquare : FSMarkup
@property (nonatomic, getter=getFillColor) unsigned int fillColor;
@property (nonatomic, copy, getter=getInnerRect) FSRectF* innerRect;
@property (nonatomic, copy, getter=getMeasureRatio) NSString * measureRatio;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(NSString *)getMeasureRatioW;
-(void)setMeasureUnit: (FSMarkupMeasureType)measure_type unit: (NSString *)unit;
-(NSString *)getMeasureUnit: (FSMarkupMeasureType)measure_type;
-(NSString *)getMeasureUnitW: (FSMarkupMeasureType)measure_type;
-(void)setMeasureConversionFactor: (FSMarkupMeasureType)measure_type factor: (float)factor;
-(float)getMeasureConversionFactor: (FSMarkupMeasureType)measure_type;

-(void)dealloc;

@end

@interface FSCircle : FSMarkup
@property (nonatomic, getter=getFillColor) unsigned int fillColor;
@property (nonatomic, copy, getter=getInnerRect) FSRectF* innerRect;
@property (nonatomic, copy, getter=getMeasureRatio) NSString * measureRatio;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(NSString *)getMeasureRatioW;
-(void)setMeasureUnit: (FSMarkupMeasureType)measure_type unit: (NSString *)unit;
-(NSString *)getMeasureUnit: (FSMarkupMeasureType)measure_type;
-(NSString *)getMeasureUnitW: (FSMarkupMeasureType)measure_type;
-(void)setMeasureConversionFactor: (FSMarkupMeasureType)measure_type factor: (float)factor;
-(float)getMeasureConversionFactor: (FSMarkupMeasureType)measure_type;

-(void)dealloc;

@end

@interface FSFreeText : FSMarkup
@property (nonatomic, getter=getFillColor) unsigned int fillColor;
@property (nonatomic, getter=getAlignment) FSAlignment alignment;
@property (nonatomic, copy, getter=getInnerRect) FSRectF* innerRect;
@property (nonatomic, getter=getCalloutLineEndingStyle) FSMarkupEndingStyle calloutLineEndingStyle;
@property (nonatomic, copy, getter=getCalloutLinePoints) FSPointFArray* calloutLinePoints;
@property (nonatomic, copy, getter=getTextMatrix) FSMatrix2D* textMatrix;
@property (nonatomic, getter=getRotation) FSRotation rotation;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(FSDefaultAppearance*)getDefaultAppearance;
-(BOOL)setDefaultAppearance: (FSDefaultAppearance*)default_ap;
-(void)rotate: (FSRotation)rotation;
-(void)allowTextOverflow: (BOOL)is_text_overflow;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSLineCapPos) {
  FSLineCapPosInline = 0,
  FSLineCapPosTop = 1
};

@interface FSLine : FSMarkup
@property (nonatomic, getter=getLineStartStyle) FSMarkupEndingStyle lineStartStyle;
@property (nonatomic, getter=getLineEndStyle) FSMarkupEndingStyle lineEndStyle;
@property (nonatomic, getter=getStyleFillColor) unsigned int styleFillColor;
@property (nonatomic, copy, getter=getStartPoint) FSPointF* startPoint;
@property (nonatomic, copy, getter=getEndPoint) FSPointF* endPoint;
@property (nonatomic, getter=getCaptionPositionType) FSLineCapPos captionPositionType;
@property (nonatomic, copy, getter=getCaptionOffset) FSPointF* captionOffset;
@property (nonatomic, getter=getLeaderLineLength) float leaderLineLength;
@property (nonatomic, getter=getLeaderLineExtensionLength) float leaderLineExtensionLength;
@property (nonatomic, getter=getLeaderLineOffset) float leaderLineOffset;
@property (nonatomic, copy, getter=getMeasureRatio) NSString * measureRatio;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(BOOL)hasCaption;
-(void)enableCaption: (BOOL)cap;
-(NSString *)getMeasureRatioW;
-(void)setMeasureUnit: (FSMarkupMeasureType)measure_type unit: (NSString *)unit;
-(NSString *)getMeasureUnit: (FSMarkupMeasureType)measure_type;
-(NSString *)getMeasureUnitW: (FSMarkupMeasureType)measure_type;
-(void)setMeasureConversionFactor: (FSMarkupMeasureType)measure_type factor: (float)factor;
-(float)getMeasureConversionFactor: (FSMarkupMeasureType)measure_type;

-(void)dealloc;

@end

@interface FSInk : FSMarkup
@property (nonatomic, copy, getter=getInkList) FSPath* inkList;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(void)enableUseBezier: (BOOL)use_bezier;
-(FSPathArray*)getEiaInkList;

-(void)dealloc;

@end

@interface FSStamp : FSMarkup
@property (nonatomic, copy, getter=getIconName) NSString * iconName;
@property (nonatomic, getter=getRotation) int rotation;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(void)setBitmap: (FSBitmap*)bitmap;
-(void)setImage: (FSImage*)image frame_index: (int)frame_index compress: (int)compress;
-(void)rotate: (int)angle;

-(void)dealloc;

@end

@interface FSScreen : FSAnnot
@property (nonatomic, copy, getter=getMKDict) FSPDFDictionary* mKDict;
@property (nonatomic, getter=getRotation) FSRotation rotation;
@property (nonatomic, getter=getOpacity) float opacity;
@property (nonatomic, copy, getter=getTitle) NSString * title;
@property (nonatomic, copy, getter=getAction) FSAction* action;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(void)setImage: (FSImage*)image frame_index: (int)frame_index compress: (int)compress;
-(FSBitmap*)getBitmap;
-(void)removeAction;

-(void)dealloc;

@end

@interface FSPolygon : FSMarkup
@property (nonatomic, getter=getFillColor) unsigned int fillColor;
@property (nonatomic, copy, getter=getVertexes) FSPointFArray* vertexes;
@property (nonatomic, copy, getter=getMeasureRatio) NSString * measureRatio;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(NSString *)getMeasureRatioW;
-(void)setMeasureUnit: (FSMarkupMeasureType)measure_type unit: (NSString *)unit;
-(NSString *)getMeasureUnit: (FSMarkupMeasureType)measure_type;
-(NSString *)getMeasureUnitW: (FSMarkupMeasureType)measure_type;
-(void)setMeasureConversionFactor: (FSMarkupMeasureType)measure_type factor: (float)factor;
-(float)getMeasureConversionFactor: (FSMarkupMeasureType)measure_type;

-(void)dealloc;

@end

@interface FSPolyLine : FSMarkup
@property (nonatomic, getter=getStyleFillColor) unsigned int styleFillColor;
@property (nonatomic, copy, getter=getVertexes) FSPointFArray* vertexes;
@property (nonatomic, getter=getLineStartStyle) FSMarkupEndingStyle lineStartStyle;
@property (nonatomic, getter=getLineEndStyle) FSMarkupEndingStyle lineEndStyle;
@property (nonatomic, copy, getter=getMeasureRatio) NSString * measureRatio;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(NSString *)getMeasureRatioW;
-(void)setMeasureUnit: (FSMarkupMeasureType)measure_type unit: (NSString *)unit;
-(NSString *)getMeasureUnit: (FSMarkupMeasureType)measure_type;
-(NSString *)getMeasureUnitW: (FSMarkupMeasureType)measure_type;
-(void)setMeasureConversionFactor: (FSMarkupMeasureType)measure_type factor: (float)factor;
-(float)getMeasureConversionFactor: (FSMarkupMeasureType)measure_type;

-(void)dealloc;

@end

@interface FSCaret : FSMarkup
@property (nonatomic, copy, getter=getInnerRect) FSRectF* innerRect;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;

-(void)dealloc;

@end

@interface FSFileAttachment : FSMarkup
@property (nonatomic, copy, getter=getIconName) NSString * iconName;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(BOOL)setFileSpec: (FSFileSpec*)file_spec;
-(FSFileSpec*)getFileSpec;

-(void)dealloc;

@end

@interface FSPopup : FSAnnot
@property (nonatomic, getter=getOpenStatus) BOOL openStatus;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(FSMarkup*)getParent;

-(void)dealloc;

@end

@interface FSPSInk : FSAnnot
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSWidgetLineSpacingStyle) {
  FSWidgetLineSpacingSingle = 0,
  FSWidgetLineSpacingOneAndHalf = 1,
  FSWidgetLineSpacingDouble = 2,
  FSWidgetLineSpacingExactValue = 3,
  FSWidgetLineSpacingAuto = 4
};

@interface FSWidget : FSAnnot
@property (nonatomic, getter=getHighlightingMode) FSAnnotHighlightingMode highlightingMode;
@property (nonatomic, copy, getter=getAction) FSAction* action;
@property (nonatomic, getter=getMKRotation) FSRotation mKRotation;
@property (nonatomic, getter=getMKBorderColor) unsigned int mKBorderColor;
@property (nonatomic, getter=getMKBackgroundColor) unsigned int mKBackgroundColor;
@property (nonatomic, copy, getter=getMKNormalCaption) NSString * mKNormalCaption;
@property (nonatomic, copy, getter=getMKRolloverCaption) NSString * mKRolloverCaption;
@property (nonatomic, copy, getter=getMKDownCaption) NSString * mKDownCaption;
@property (nonatomic, copy, getter=getMKNormalIconBitmap) FSBitmap* mKNormalIconBitmap;
@property (nonatomic, copy, getter=getMKRolloverIconBitmap) FSBitmap* mKRolloverIconBitmap;
@property (nonatomic, copy, getter=getMKDownIconBitmap) FSBitmap* mKDownIconBitmap;
@property (nonatomic, copy, getter=getMKIconFit) FSIconFit* mKIconFit;
@property (nonatomic, getter=getMKIconCaptionRelation) FSAnnotMKIconCaptionRelation mKIconCaptionRelation;
@property (nonatomic, copy, getter=getAppearanceState) NSString * appearanceState;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(FSField*)getField;
-(FSControl*)getControl;
-(void)removeAction;
-(BOOL)hasMKEntry: (FSAnnotMKEntry)mk_entry;
-(void)removeMKEntry: (FSAnnotMKEntry)mk_entry;
-(void)setMKNormalIconImage: (FSImage*)image frame_index: (int)frame_index;
-(void)setMKRolloverIconImage: (FSImage*)image frame_index: (int)frame_index;
-(void)setMKDownIconImage: (FSImage*)image frame_index: (int)frame_index;
-(NSString *)getAppearanceOnStateName;
-(FSWidgetLineSpacingStyle)getLineSpacing: (float *)line_spacing_value;
-(void)setLineSpacing: (FSWidgetLineSpacingStyle)line_spacing_style line_spacing_value: (float)line_spacing_value;

-(void)dealloc;

@end

@interface FSRedact : FSMarkup
@property (nonatomic, copy, getter=getQuadPoints) FSQuadPointsArray* quadPoints;
@property (nonatomic, getter=getFillColor) unsigned int fillColor;
@property (nonatomic, getter=getApplyFillColor) unsigned int applyFillColor;
@property (nonatomic, copy, getter=getOverlayText) NSString * overlayText;
@property (nonatomic, getter=getOverlayTextAlignment) FSAlignment overlayTextAlignment;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(FSDefaultAppearance*)getDefaultAppearance;
-(BOOL)setDefaultAppearance: (FSDefaultAppearance*)default_ap;
-(BOOL)apply;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSSoundSampleEncodingFormat) {
  FSSoundSampleEncodingFormatRaw = 0,
  FSSoundSampleEncodingFormatSigned = 1,
  FSSoundSampleEncodingFormatMuLaw = 2,
  FSSoundSampleEncodingFormatALaw = 3
};

@interface FSSound : FSMarkup
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithAnnot: (FSAnnot*)annot;
-(FSPDFStream*)getSoundStream;
-(float)getSamplingRate;
-(int)getChannelCount;
-(int)getBits;
-(FSSoundSampleEncodingFormat)getSampleEncodingFormat;
-(NSString *)getCompressionFormat;
-(FSFileSpec*)getFileSpec;

-(void)dealloc;

@end

@interface FSRichMedia : FSAnnot
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(void)saveMediaFile: (NSString *)file_path;
-(FSFileSpec*)getFileSpec;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSBookmarkStyle) {
  FSBookmarkStyleNormal = 0x00,
  FSBookmarkStyleItalic = 0x01,
  FSBookmarkStyleBold = 0x02
};

typedef NS_ENUM(NSInteger, FSBookmarkPosition) {
  FSBookmarkPosFirstChild = 0,
  FSBookmarkPosLastChild = 1,
  FSBookmarkPosPrevSibling = 2,
  FSBookmarkPosNextSibling = 3,
  FSBookmarkPosFirstSibling = 4,
  FSBookmarkPosLastSibling = 5
};

@interface FSBookmark : FSBase
@property (nonatomic, copy, getter=getDestination) FSDestination* destination;
@property (nonatomic, copy, getter=getTitle) NSString * title;
@property (nonatomic, getter=getColor) unsigned int color;
@property (nonatomic, getter=getStyle) unsigned int style;
@property (nonatomic, copy, getter=getAction) FSAction* action;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithPdf_doc: (FSPDFDoc*)pdf_doc bookmark_dict: (FSPDFDictionary*)bookmark_dict;
-(id)initWithOther: (FSBookmark*)other;
-(BOOL)isEmpty;
-(FSBookmark*)getParent;
-(BOOL)hasChild;
-(FSBookmark*)getFirstChild;
-(FSBookmark*)getNextSibling;
-(FSBookmark*)insert: (NSString *)title position: (FSBookmarkPosition)position;
-(BOOL)moveTo: (FSBookmark*)dest_bookmark position: (FSBookmarkPosition)position;
-(BOOL)removeAction;
-(BOOL)isRoot;
-(BOOL)isFirstChild;
-(BOOL)isLastChild;
-(FSPDFDictionary*)getDict;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSAssociatedFilesRelationship) {
  FSAssociatedFilesRelationshipUnspecified = 0,
  FSAssociatedFilesRelationshipSource = 1,
  FSAssociatedFilesRelationshipData = 2,
  FSAssociatedFilesRelationshipAlternative = 3,
  FSAssociatedFilesRelationshipSupplement = 4,
  FSAssociatedFilesRelationshipEncryptedPayload = 5,
  FSAssociatedFilesRelationshipFormData = 6,
  FSAssociatedFilesRelationshipSchema = 7
};

@interface FSAssociatedFiles : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSAssociatedFiles*)other;
-(id)initWithPdf_doc: (FSPDFDoc*)pdf_doc;
-(BOOL)isEmpty;
-(int)getAssociatedFilesCount: (FSPDFObject*)pdf_object;
-(FSFileSpec*)getAssociatedFile: (FSPDFObject*)pdf_object index: (int)index;
-(void)associateFile: (FSPDFObject*)pdf_object file_spec: (FSFileSpec*)file_spec;
-(void)removeAssociatedFile: (FSPDFObject*)pdf_object index: (int)index;

-(void)dealloc;

@end

@interface FSAttachments : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDoc: (FSPDFDoc*)doc nametree: (FSPDFNameTree*)nametree;
-(id)initWithOther: (FSAttachments*)other;
-(BOOL)isEmpty;
-(int)getCount;
-(NSString *)getKey: (int)index;
-(FSFileSpec*)getEmbeddedFile: (NSString *)key;
-(BOOL)setEmbeddedFile: (NSString *)key file_spec: (FSFileSpec*)file_spec;
-(BOOL)addEmbeddedFile: (NSString *)key file_spec: (FSFileSpec*)file_spec;
-(BOOL)addFromFilePath: (NSString *)key file_path: (NSString *)file_path;
-(BOOL)removeEmbeddedFile: (NSString *)key;
-(BOOL)removeAllEmbeddedFiles;
-(BOOL)extractEmbeddedFileTo: (NSString *)key dst_file_path: (NSString *)dst_file_path;
-(FSPDFNameTree*)getNameTree;

-(void)dealloc;

@end

@interface FSPageNumberRange : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getStart_number) int start_number;
@property (nonatomic, getter=getEnd_number) int end_number;
@property (nonatomic, getter=getFilter) FSRangeFilter filter;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithStart_number: (int)start_number end_number: (int)end_number filter: (FSRangeFilter)filter;
-(id)initWithPage_range: (FSPageNumberRange*)page_range;
-(void)set: (int)start_number end_number: (int)end_number filter: (FSRangeFilter)filter;
-(void)dealloc;

@end

@interface FSHeaderFooterContent : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getHeader_left_content) NSString * header_left_content;
@property (nonatomic, copy, getter=getHeader_center_content) NSString * header_center_content;
@property (nonatomic, copy, getter=getHeader_right_content) NSString * header_right_content;
@property (nonatomic, copy, getter=getFooter_left_content) NSString * footer_left_content;
@property (nonatomic, copy, getter=getFooter_center_content) NSString * footer_center_content;
@property (nonatomic, copy, getter=getFooter_right_content) NSString * footer_right_content;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithHeader_left_content: (NSString *)header_left_content header_center_content: (NSString *)header_center_content header_right_content: (NSString *)header_right_content footer_left_content: (NSString *)footer_left_content footer_center_content: (NSString *)footer_center_content footer_right_content: (NSString *)footer_right_content;
-(id)initWithOther: (FSHeaderFooterContent*)other;
-(void)set: (NSString *)header_left_content header_center_content: (NSString *)header_center_content header_right_content: (NSString *)header_right_content footer_left_content: (NSString *)footer_left_content footer_center_content: (NSString *)footer_center_content footer_right_content: (NSString *)footer_right_content;
-(void)dealloc;

@end

@interface FSHeaderFooter : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getFont) FSFont* font;
@property (nonatomic, getter=getText_size) float text_size;
@property (nonatomic, getter=getText_color) unsigned int text_color;
@property (nonatomic, copy, getter=getPage_range) FSPageNumberRange* page_range;
@property (nonatomic, copy, getter=getPage_margin) FSRectF* page_margin;
@property (nonatomic, getter=getHas_text_shrinked) BOOL has_text_shrinked;
@property (nonatomic, getter=getHas_fixedsize_for_print) BOOL has_fixedsize_for_print;
@property (nonatomic, getter=getStart_page_number) int start_page_number;
@property (nonatomic, copy, getter=getContent) FSHeaderFooterContent* content;
@property (nonatomic, getter=getIs_to_embed_font) BOOL is_to_embed_font;
@property (nonatomic, getter=getIs_underline) BOOL is_underline;
@property (nonatomic, getter=getIs_replace_font) BOOL is_replace_font;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithFont: (FSFont*)font text_size: (float)text_size text_color: (unsigned int)text_color page_range: (FSPageNumberRange*)page_range page_margin: (FSRectF*)page_margin has_text_shrinked: (BOOL)has_text_shrinked has_fixedsize_for_print: (BOOL)has_fixedsize_for_print start_page_number: (int)start_page_number content: (FSHeaderFooterContent*)content is_to_embed_font: (BOOL)is_to_embed_font is_underline: (BOOL)is_underline;
-(id)initWithOther: (FSHeaderFooter*)other;
-(void)set: (FSFont*)font text_size: (float)text_size text_color: (unsigned int)text_color page_range: (FSPageNumberRange*)page_range page_margin: (FSRectF*)page_margin has_text_shrinked: (BOOL)has_text_shrinked has_fixedsize_for_print: (BOOL)has_fixedsize_for_print start_page_number: (int)start_page_number content: (FSHeaderFooterContent*)content is_to_embed_font: (BOOL)is_to_embed_font is_underline: (BOOL)is_underline;
-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSHeaderFooterContentGeneratorDateFormatType) {
  FSHeaderFooterContentGeneratorDateFormatMSlashD = 0,
  FSHeaderFooterContentGeneratorDateFormatMSlashDSlashYY = 1,
  FSHeaderFooterContentGeneratorDateFormatMSlashDSlashYYYY = 2,
  FSHeaderFooterContentGeneratorDateFormatMMSlashDDSlashYY = 3,
  FSHeaderFooterContentGeneratorDateFormatMMSlashDDSlashYYYY = 4,
  FSHeaderFooterContentGeneratorDateFormatDSlashMSlashYY = 5,
  FSHeaderFooterContentGeneratorDateFormatDSlashMSlashYYYY = 6,
  FSHeaderFooterContentGeneratorDateFormatDDSlashMMSlashYY = 7,
  FSHeaderFooterContentGeneratorDateFormatDDSlashMMSlashYYYY = 8,
  FSHeaderFooterContentGeneratorDateFormatMMSlashYY = 9,
  FSHeaderFooterContentGeneratorDateFormatMMSlashYYYY = 10,
  FSHeaderFooterContentGeneratorDateFormatMDotDDotYY = 11,
  FSHeaderFooterContentGeneratorDateFormatMDotDDotYYYY = 12,
  FSHeaderFooterContentGeneratorDateFormatMMDotDDDotYY = 13,
  FSHeaderFooterContentGeneratorDateFormatMMDotDDDotYYYY = 14,
  FSHeaderFooterContentGeneratorDateFormatMMDotYY = 15,
  FSHeaderFooterContentGeneratorDateFormatDDotMDotYYYY = 16,
  FSHeaderFooterContentGeneratorDateFormatDDDotMMDotYY = 17,
  FSHeaderFooterContentGeneratorDateFormatDDDotMMDotYYYY = 18,
  FSHeaderFooterContentGeneratorDateFormatYYHyphenMMHyphenDD = 19,
  FSHeaderFooterContentGeneratorDateFormatYYYYHyphenMMHyphenDD = 20
};

typedef NS_ENUM(NSInteger, FSHeaderFooterContentGeneratorPageNumberFormat) {
  FSHeaderFooterContentGeneratorPageNumberFormatDefault = 0,
  FSHeaderFooterContentGeneratorPageNumberFormatNumberOfCount = 1,
  FSHeaderFooterContentGeneratorPageNumberFormatNumberSlashCount = 2,
  FSHeaderFooterContentGeneratorPageNumberFormatPageNumber = 3,
  FSHeaderFooterContentGeneratorPageNumberFormatPageNumberOfCount = 4
};

@interface FSHeaderFooterContentGenerator : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSHeaderFooterContentGenerator*)other;
-(BOOL)isEmpty;
-(void)addDate: (FSHeaderFooterContentGeneratorDateFormatType)format_type;
-(void)addPageNumber: (FSHeaderFooterContentGeneratorPageNumberFormat)format_type;
-(void)addString: (NSString *)new_string;
-(void)clear;
-(NSString *)generateContent;

-(void)dealloc;

@end

@interface FSWrapperData : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getVersion) int version;
@property (nonatomic, copy, getter=getType) NSString * type;
@property (nonatomic, copy, getter=getApp_id) NSString * app_id;
@property (nonatomic, copy, getter=getUri) NSString * uri;
@property (nonatomic, copy, getter=getDescription) NSString * description;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithVersion: (int)version type: (NSString *)type app_id: (NSString *)app_id uri: (NSString *)uri description: (NSString *)description;
-(id)initWithWrapper_data: (FSWrapperData*)wrapper_data;
-(void)set: (int)version type: (NSString *)type app_id: (NSString *)app_id uri: (NSString *)uri description: (NSString *)description;
-(void)dealloc;

@end

@interface FSPayLoadData : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getVersion) float version;
@property (nonatomic, copy, getter=getCrypto_filter) NSString * crypto_filter;
@property (nonatomic, copy, getter=getFile_name) NSString * file_name;
@property (nonatomic, getter=getFile_size) long long file_size;
@property (nonatomic, copy, getter=getDescription) NSString * description;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithPayload_data: (FSPayLoadData*)payload_data;
-(void)set: (float)version crypto_filter: (NSString *)crypto_filter file_name: (NSString *)file_name file_size: (long long)file_size description: (NSString *)description;
-(void)dealloc;

@end

@interface FSPageBasicInfo : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getWidth) float width;
@property (nonatomic, getter=getHeight) float height;
@property (nonatomic, getter=getRotation) FSRotation rotation;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithWidth: (float)width height: (float)height rotation: (FSRotation)rotation;
-(id)init;
-(id)initWithPage_info: (FSPageBasicInfo*)page_info;
-(void)set: (float)width height: (float)height rotation: (FSRotation)rotation;
-(void)dealloc;

@end

@interface FSEmbeddedFontData : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getNonstandard_font_name_array) NSArray<NSString *> * nonstandard_font_name_array;
@property (nonatomic, copy, getter=getStandard_font_name_array) NSArray<NSString *> * standard_font_name_array;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSEmbeddedFontData*)other;
-(void)dealloc;

@end

@interface FSTableOfContentsConfig : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getTitle) NSString * title;
@property (nonatomic, copy, getter=getBookmark_level_array) FSInt32Array* bookmark_level_array;
@property (nonatomic, getter=getIs_show_serial_number) BOOL is_show_serial_number;
@property (nonatomic, getter=getInclude_toc_pages) BOOL include_toc_pages;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithTitle: (NSString *)title bookmark_level_array: (FSInt32Array*)bookmark_level_array is_show_serial_number: (BOOL)is_show_serial_number include_toc_pages: (BOOL)include_toc_pages;
-(void)set: (NSString *)title bookmark_level_array: (FSInt32Array*)bookmark_level_array is_show_serial_number: (BOOL)is_show_serial_number include_toc_pages: (BOOL)include_toc_pages;
-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSPDFDocPasswordType) {
  FSPDFDocPwdInvalid = 0,
  FSPDFDocPwdNoPassword = 1,
  FSPDFDocPwdUser = 2,
  FSPDFDocPwdOwner = 3
};

typedef NS_ENUM(NSInteger, FSPDFDocEncryptType) {
  FSPDFDocEncryptUnknown = -1,
  FSPDFDocEncryptNone = 0,
  FSPDFDocEncryptPassword = 1,
  FSPDFDocEncryptCertificate = 2,
  FSPDFDocEncryptFoxitDRM = 3,
  FSPDFDocEncryptCustom = 4,
  FSPDFDocEncryptRMS = 5,
  FSPDFDocEncryptCDRM = 6
};

typedef NS_ENUM(NSInteger, FSPDFDocUserPermissions) {
  FSPDFDocPermPrint = 0x0004,
  FSPDFDocPermModify = 0x0008,
  FSPDFDocPermExtract = 0x0010,
  FSPDFDocPermAnnotForm = 0x0020,
  FSPDFDocPermFillForm = 0x0100,
  FSPDFDocPermExtractAccess = 0x0200,
  FSPDFDocPermAssemble = 0x0400,
  FSPDFDocPermPrintHigh = 0x0800
};

typedef NS_ENUM(NSInteger, FSPDFDocSaveFlags) {
  FSPDFDocSaveFlagNormal = 0,
  FSPDFDocSaveFlagIncremental = 0x0001,
  FSPDFDocSaveFlagNoOriginal = 0x0002,
  FSPDFDocSaveFlagXRefStream = 0x0008,
  FSPDFDocSaveFlagLinearized = 0x1000,
  FSPDFDocSaveFlagRemoveRedundantObjects = 0x0010
};

typedef NS_ENUM(NSInteger, FSPDFDocImportPageFlags) {
  FSPDFDocImportFlagNormal = 0,
  FSPDFDocImportFlagWithLayers = 0x0001,
  FSPDFDocImportFlagShareStream = 0x0002
};

typedef NS_ENUM(NSInteger, FSPDFDocExtractPagesOptions) {
  FSPDFDocExtractPagesOptionAnnotation = 0x0001,
  FSPDFDocExtractPagesOptionStructureTree = 0x0002,
  FSPDFDocExtractPagesOptionJavascript = 0x0004,
  FSPDFDocExtractPagesOptionOCProperties = 0x0008,
  FSPDFDocExtractPagesOptionObjectStream = 0x0010,
  FSPDFDocExtractPagesOptionAttachFiles = 0x0020
};

typedef NS_ENUM(NSInteger, FSPDFDocInsertDocOptions) {
  FSPDFDocInsertDocOptionAttachments = 0x0001
};

typedef NS_ENUM(NSInteger, FSPDFDocDisplayMode) {
  FSPDFDocDisplayUseNone = 0,
  FSPDFDocDisplayUseOutlines = 1,
  FSPDFDocDisplayUseThumbs = 2,
  FSPDFDocDisplayFullScreen = 3,
  FSPDFDocDisplayUseOC = 4,
  FSPDFDocDisplayUseAttachment = 5
};

typedef NS_ENUM(NSInteger, FSPDFDocDataType) {
  FSPDFDocForms = 0x0001,
  FSPDFDocAnnots = 0x0002,
  FSPDFDocLinks = 0x0004
};

typedef NS_ENUM(NSInteger, FSPDFDocWrapperType) {
  FSPDFDocWrapperNone = 0,
  FSPDFDocWrapperFoxit = 1,
  FSPDFDocWrapperPDFV2 = 2
};

@interface FSPDFDoc : FSBase
@property (nonatomic, getter=getDisplayMode) FSPDFDocDisplayMode displayMode;
@property (nonatomic, getter=getFileVersion) int fileVersion;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithPath: (NSString *)path;
-(id)initWithFile_read: (id<FSFileReaderCallback>)file_read is_async: (BOOL)is_async;
-(id)initWithOther: (FSPDFDoc*)other;
-(BOOL)isEmpty;
-(unsigned long long)getFileSize;
-(BOOL)isLinearized;
-(BOOL)isTaggedPDF;
-(FSErrorCode)load: (NSString *)password;
-(FSErrorCode)loadW: (NSString *)password;
-(BOOL)reload;
-(FSProgressive*)startLoad: (NSString *)password is_cache_stream: (BOOL)is_cache_stream pause: (id<FSPauseCallback>)pause;
-(FSProgressive*)startLoadW: (NSString *)password is_cache_stream: (BOOL)is_cache_stream pause: (id<FSPauseCallback>)pause;
-(int)getFirstAvailPageIndex;
-(BOOL)isXFA;
-(BOOL)isEncrypted;
-(void)clearRenderCache;
-(FSPDFDocPasswordType)getPasswordType;
-(FSPDFDocEncryptType)getEncryptionType;
-(FSPDFDocPasswordType)checkPassword: (NSString *)password;
-(BOOL)isUserPassword: (NSString *)password;
-(BOOL)isOwnerPassword: (NSString *)password;
-(NSString *)getUserPassword: (NSString *)owner_password;
-(FSStdEncryptData*)getStdEncryptData;
-(FSCertificateEncryptData*)getCertificateEncryptData;
-(FSDRMEncryptData*)getDRMEncryptData;
-(FSCustomEncryptData*)getCustomEncryptData;
-(FSRMSEncryptData*)getRMSEncryptData;
-(BOOL)saveAs: (NSString *)file_path save_flags: (unsigned int)save_flags;
-(FSProgressive*)startSaveAs: (NSString *)file_path save_flags: (unsigned int)save_flags pause: (id<FSPauseCallback>)pause;
-(FSProgressive*)startSaveAsWithWriterCallback: (id<FSFileWriterCallback>)file save_flags: (unsigned int)save_flags pause: (id<FSPauseCallback>)pause;
-(FSBookmark*)getRootBookmark;
-(FSBookmark*)createRootBookmark;
-(int)getBookmarkLevelDepth;
-(BOOL)removeBookmark: (FSBookmark*)bookmark;
-(BOOL)hasLayer;
-(BOOL)hasHeaderFooter;
-(FSHeaderFooter*)getEditableHeaderFooter;
-(void)addHeaderFooter: (FSHeaderFooter*)headerfooter;
-(void)updateHeaderFooter: (FSHeaderFooter*)headerfooter;
-(BOOL)removeAllHeaderFooters;
-(int)getPageCount;
-(FSPDFPage*)getPage: (int)index;
-(FSPDFDictionary*)getCatalog;
-(FSPDFDictionary*)getTrailer;
-(FSPDFDictionary*)getInfo;
-(FSPDFDictionary*)getEncryptDict;
-(FSPDFDictionary*)getPagesDict;
-(FSPDFObject*)getIndirectObject: (unsigned int)object_number;
-(unsigned int)addIndirectObject: (FSPDFObject*)pdf_object;
-(void)deleteIndirectObject: (unsigned int)object_number;
-(unsigned int)getUserPermissions;
-(BOOL)isWrapper;
-(FSPDFDocWrapperType)getWrapperType;
-(FSWrapperData*)getWrapperData;
-(long long)getWrapperOffset;
-(FSPayLoadData*)getPayLoadData;
-(FSProgressive*)startGetPayloadFile: (id<FSFileWriterCallback>)payload_file pause: (id<FSPauseCallback>)pause;
-(BOOL)saveAsWrapperFile: (NSString *)file_path wrapper_data: (FSWrapperData*)wrapper_data user_permissions: (unsigned int)user_permissions owner_password: (NSString *)owner_password;
-(FSProgressive*)startSaveAsPayloadFile: (NSString *)file_path payload_file_path: (NSString *)payload_file_path crypto_filter: (NSString *)crypto_filter description: (NSString *)description version: (float)version save_flags: (unsigned int)save_flags pause: (id<FSPauseCallback>)pause;
-(BOOL)hasForm;
-(int)getReadingBookmarkCount;
-(FSReadingBookmark*)getReadingBookmark: (int)index;
-(FSReadingBookmark*)insertReadingBookmark: (int)reading_bookmark_index title: (NSString *)title dest_page_index: (int)dest_page_index;
-(BOOL)removeReadingBookmark: (FSReadingBookmark*)reading_bookmark;
-(int)getSignatureCount;
-(FSSignature*)getSignature: (int)index;
-(void)removeSignature: (FSSignature*)signature;
-(FSPDFPage*)insertPage: (int)index width: (float)width height: (float)height;
-(FSPDFPage*)insertPageSize: (int)index size: (FSPDFPageSize)size;
-(FSPDFPage*)addPageFromTemplate: (NSString *)template_name;
-(BOOL)hidePageTemplate: (NSString *)template_name;
-(BOOL)removePage: (int)index;
-(BOOL)movePageTo: (FSPDFPage*)page dest_index: (int)dest_index;
-(BOOL)movePagesTo: (FSRange*)page_range dest_index: (int)dest_index;
-(FSProgressive*)startImportPagesFromFilePath: (int)dest_index src_file_path: (NSString *)src_file_path password: (NSString *)password flags: (unsigned int)flags layer_name: (NSString *)layer_name page_range: (FSRange*)page_range pause: (id<FSPauseCallback>)pause;
-(FSProgressive*)startImportPages: (int)dest_index src_doc: (FSPDFDoc*)src_doc flags: (unsigned int)flags layer_name: (NSString *)layer_name page_range: (FSRange*)page_range pause: (id<FSPauseCallback>)pause;
-(FSProgressive*)startExtractPages: (NSString *)file_path options: (unsigned int)options page_range: (FSRange*)page_range pause: (id<FSPauseCallback>)pause;
-(FSProgressive*)startExtractPagesWithWriterCallback: (id<FSFileWriterCallback>)file options: (unsigned int)options page_range: (FSRange*)page_range pause: (id<FSPauseCallback>)pause;
-(void)insertDocument: (int)dest_index src_doc: (FSPDFDoc*)src_doc options: (unsigned int)options;
-(BOOL)importFromFDF: (FSFDFDoc*)fdf_doc types: (int)types page_range: (FSRange*)page_range;
-(BOOL)exportToFDF: (FSFDFDoc*)fdf_doc types: (int)types page_range: (FSRange*)page_range;
-(BOOL)exportAnnotToFDF: (FSAnnot*)pdf_annot fdf_doc: (FSFDFDoc*)fdf_doc;
-(BOOL)exportFormFieldsToFDF: (FSFieldArray*)field_array is_include: (BOOL)is_include fdf_doc: (FSFDFDoc*)fdf_doc;
-(NSString *)getHeader;
-(BOOL)setSecurityHandler: (FSSecurityHandler*)handler;
-(FSSecurityHandler*)getSecurityHandler;
-(BOOL)removeSecurity;
-(int)getFontCount;
-(FSFont*)getFont: (int)index;
-(FSAction*)getOpenAction;
-(BOOL)setOpenAction: (FSAction*)action;
-(BOOL)removeOpenAction;
-(BOOL)doJSOpenAction;
-(BOOL)isPortfolio;
-(FSPageBasicInfo*)getPageBasicInfo: (int)index;
-(FSEmbeddedFontData*)getEmbeddedFontData;
-(void)createDSS;
-(void)addTableOfContentsWithTitle: (NSString *)title bookmark_level_array: (FSInt32Array*)bookmark_level_array;
-(void)addTableOfContents: (FSTableOfContentsConfig*)table_of_contents_config;
-(void)setCacheFile: (id<FSStreamCallback>)file_stream is_own_file_stream: (BOOL)is_own_file_stream;
-(FSProgressive*)startRecognizeForm: (id<FSPauseCallback>)pause;
-(NSString *)getPageText: (int)page_index;
-(id)initWithBuffer: (NSData *)buffer;

-(void)dealloc;

@end

@interface FSFileSpec : FSBase
@property (nonatomic, copy, getter=getFileName) NSString * fileName;
@property (nonatomic, getter=getAssociteFileRelationship) FSAssociatedFilesRelationship associteFileRelationship;
@property (nonatomic, copy, getter=getDescription) NSString * description;
@property (nonatomic, copy, getter=getDescriptionW) NSString * descriptionW;
@property (nonatomic, copy, getter=getCreationDateTime) FSDateTime* creationDateTime;
@property (nonatomic, copy, getter=getModifiedDateTime) FSDateTime* modifiedDateTime;
@property (nonatomic, copy, getter=getSubtype) NSString * subtype;
@property (nonatomic, copy, getter=getChecksum) NSData * checksum;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document;
-(id)initWithDocument: (FSPDFDoc*)document pdf_object: (FSPDFObject*)pdf_object;
-(id)initWithOther: (FSFileSpec*)other;
-(BOOL)isEmpty;
-(long long)getFileSize;
-(long long)getCompressedEmbeddedFileSize;
-(id<FSFileReaderCallback>)getFileData;
-(BOOL)embed: (NSString *)file_path;
-(BOOL)embedWithStreamCallback: (id<FSStreamCallback>)stream;
-(BOOL)isEmbedded;
-(FSPDFDictionary*)getDict;
-(BOOL)exportToFile: (NSString *)path;
-(BOOL)exportToFileStream: (id<FSStreamCallback>)stream;

-(void)dealloc;

@end

@interface FSTextFillSignObjectData : FSBase
@property (nonatomic, copy, getter=getText_state) FSTextState* text_state;
@property (nonatomic, copy, getter=getText) NSString * text;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithText_state: (FSTextState*)text_state text: (NSString *)text;
-(id)initWithText_data: (FSTextFillSignObjectData*)text_data;
-(void)set: (FSTextState*)text_state text: (NSString *)text;
-(void)dealloc;

@end

@interface FSTextFillSignObjectDataArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSTextFillSignObjectDataArray*)other;
-(unsigned long)getSize;
-(FSTextFillSignObjectData*)getAt: (unsigned long)index;
-(void)add: (FSTextFillSignObjectData*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSTextFillSignObjectData*)element;
-(void)removeAll;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSFillSignFillSignObjectType) {
  FSFillSignFillSignObjectTypeText = 0,
  FSFillSignFillSignObjectTypeCrossMark = 1,
  FSFillSignFillSignObjectTypeCheckMark = 2,
  FSFillSignFillSignObjectTypeRoundRectangle = 3,
  FSFillSignFillSignObjectTypeLine = 4,
  FSFillSignFillSignObjectTypeDot = 5,
  FSFillSignFillSignObjectTypeSignature = 6,
  FSFillSignFillSignObjectTypeInitialsSignature = 7
};

@interface FSFillSign : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithPage: (FSPDFPage*)page;
-(id)initWithOther: (FSFillSign*)other;
-(BOOL)isEmpty;
-(FSFillSignObject*)addObject: (FSFillSignFillSignObjectType)type point: (FSPointF*)point width: (float)width height: (float)height rotation: (FSRotation)rotation;
-(FSFillSignObject*)addTextObject: (FSTextFillSignObjectDataArray*)text_data point: (FSPointF*)point width: (float)width height: (float)height rotation: (FSRotation)rotation is_comb_field_mode: (BOOL)is_comb_field_mode;
-(BOOL)removeObject: (FSFillSignObject*)fillsign_object;
-(FSFillSignObject*)getObjectAtPoint: (FSPointF*)point;
-(FSFillSignObject*)getObjectAtDevicePoint: (FSPointF*)point matrix: (FSMatrix2D*)matrix;
-(FSFillSignObject*)getObjectByFormXObject: (FSFormXObject*)formobject;

-(void)dealloc;

@end

@interface FSFillSignObject : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSFillSignObject*)other;
-(id)init;
-(BOOL)isEmpty;
-(FSFillSignFillSignObjectType)getType;
-(void)move: (FSPointF*)point width: (float)width height: (float)height rotation: (FSRotation)rotation;
-(FSRectF*)getRect;
-(BOOL)generateContent;
-(FSFormXObject*)getFormXObject;

-(void)dealloc;

@end

@interface FSTextFillSignObject : FSFillSignObject
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithFillsign_object: (FSFillSignObject*)fillsign_object;
-(FSTextFillSignObjectDataArray*)getTextDataArray;
-(BOOL)isCombFieldMode;

-(void)dealloc;

@end

@interface FSSignatureFillSignObject : FSFillSignObject
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithFillsign_object: (FSFillSignObject*)fillsign_object;
-(BOOL)isInitialsType;
-(void)setBitmap: (FSBitmap*)bitmap;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSOutputPreviewShowType) {
  FSOutputPreviewShowAll = 0,
  FSOutputPreviewShowDeviceCMYK = 1,
  FSOutputPreviewShowNotDeviceCMYK = 2,
  FSOutputPreviewShowICCBasedCMYK = 3,
  FSOutputPreviewShowSpotColor = 4,
  FSOutputPreviewShowDeviceCMYKAndSpot = 5,
  FSOutputPreviewShowNotDeviceCMYKOrSpot = 6,
  FSOutputPreviewShowDeviceN = 7,
  FSOutputPreviewShowCMYK = 8,
  FSOutputPreviewShowRGB = 9,
  FSOutputPreviewShowDeviceRGB = 10,
  FSOutputPreviewShowICCBasedRGB = 11,
  FSOutputPreviewShowGray = 12,
  FSOutputPreviewShowDeviceGray = 13,
  FSOutputPreviewShowCalGray = 14,
  FSOutputPreviewShowCalibrated = 15,
  FSOutputPreviewShowLab = 16,
  FSOutputPreviewShowDevice = 17,
  FSOutputPreviewShowImages = 18,
  FSOutputPreviewShowSolidColor = 19,
  FSOutputPreviewShowSmoothShades = 20,
  FSOutputPreviewShowRegistrationColor = 21,
  FSOutputPreviewShowText = 22,
  FSOutputPreviewShowLineArt = 23
};

typedef NS_ENUM(NSInteger, FSOutputPreviewColorantType) {
  FSOutputPreviewColorantTypeProcess = 0,
  FSOutputPreviewColorantTypeSpot = 1
};

@interface FSOutputPreview : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithPdf_doc: (FSPDFDoc*)pdf_doc;
-(id)initWithOther: (FSOutputPreview*)other;
-(BOOL)isEmpty;
-(void)setSimulationProfile: (NSString *)icc_profile_path;
-(void)setShowType: (FSOutputPreviewShowType)show_type;
-(NSArray<NSData *> *)getPlates: (FSOutputPreviewColorantType)colorant_type;
-(unsigned int)getSpotPlateColor: (NSString *)plate_name;
-(void)setCheckStatus: (NSString *)plate_name to_check: (BOOL)to_check;
-(BOOL)isChecked: (NSString *)plate_name;
-(FSBitmap*)generatePreviewBitmap: (FSPDFPage*)page matrix: (FSMatrix2D*)matrix renderer: (FSRenderer*)renderer;

-(void)dealloc;

@end

@interface FSLayerNodeArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSLayerNodeArray*)other;
-(unsigned long)getSize;
-(FSLayerNode*)getAt: (unsigned long)index;
-(void)add: (FSLayerNode*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSLayerNode*)element;
-(void)removeAll;

-(void)dealloc;

@end

@interface FSLayerZoomData : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getMin_factor) float min_factor;
@property (nonatomic, getter=getMax_factor) float max_factor;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithMin_factor: (float)min_factor max_factor: (float)max_factor;
-(id)initWithData: (FSLayerZoomData*)data;
-(void)set: (float)min_factor max_factor: (float)max_factor;
-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSLayerTreeUsageState) {
  FSLayerTreeStateON = 0x0000,
  FSLayerTreeStateOFF = 0x0001,
  FSLayerTreeStateUnchanged = 0x0002,
  FSLayerTreeStateUndefined = 0x0003
};

@interface FSLayerTree : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document;
-(id)initWithOther: (FSLayerTree*)other;
-(BOOL)isEmpty;
-(BOOL)setBaseState: (FSLayerTreeUsageState)state;
-(FSLayerNode*)getRootNode;
-(FSPDFDictionary*)getDict;
-(FSPDFArray*)getOCGs;

-(void)dealloc;

@end

@interface FSLayerPrintData : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getSubtype) NSString * subtype;
@property (nonatomic, getter=getPrint_state) FSLayerTreeUsageState print_state;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithSubtype: (NSString *)subtype print_state: (FSLayerTreeUsageState)print_state;
-(id)init;
-(id)initWithData: (FSLayerPrintData*)data;
-(void)set: (NSString *)subtype print_state: (FSLayerTreeUsageState)print_state;
-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSLayerContextUsageType) {
  FSLayerContextUsageView = 0x0000,
  FSLayerContextUsageDesign = 0x0001,
  FSLayerContextUsagePrint = 0x0002,
  FSLayerContextUsageExport = 0x0003,
  FSLayerContextUsageZoom = 0x0004
};

@interface FSLayerContext : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document usage_type: (FSLayerContextUsageType)usage_type;
-(id)initWithOther: (FSLayerContext*)other;
-(BOOL)isEmpty;
-(FSPDFDoc*)getDocument;
-(FSLayerContextUsageType)getUsageType;
-(BOOL)reset;
-(BOOL)copyStates: (FSLayerContext*)source_context;
-(BOOL)mergeStates: (FSLayerContext*)source_context;
-(BOOL)isVisible: (FSLayerNode*)layer;
-(BOOL)setVisible: (FSLayerNode*)layer is_visible: (BOOL)is_visible;

-(void)dealloc;

@end

@interface FSLayerNode : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSLayerNode*)other;
-(BOOL)isEmpty;
-(int)getChildrenCount;
-(FSLayerNode*)getChild: (int)index;
-(BOOL)removeChild: (int)index;
-(BOOL)moveTo: (FSLayerNode*)parent_layer_node index: (int)index;
-(FSLayerNode*)addChild: (int)index name: (NSString *)name has_Layer: (BOOL)has_Layer;
-(NSString *)getName;
-(BOOL)isLocked;
-(BOOL)hasLayer;
-(BOOL)hasIntent: (NSString *)intent;
-(BOOL)isInPage: (FSPDFPage*)page;
-(FSLayerTreeUsageState)getViewUsage;
-(FSLayerTreeUsageState)getExportUsage;
-(FSLayerPrintData*)getPrintUsage;
-(FSLayerZoomData*)getZoomUsage;
-(BOOL)setName: (NSString *)name;
-(BOOL)setDefaultVisible: (BOOL)is_visible;
-(BOOL)setViewUsage: (FSLayerTreeUsageState)state;
-(BOOL)setExportUsage: (FSLayerTreeUsageState)state;
-(BOOL)setPrintUsage: (FSLayerPrintData*)data;
-(BOOL)setZoomUsage: (FSLayerZoomData*)data;
-(FSGraphicsObjectArray*)getGraphicsObjects: (FSPDFPage*)page;
-(BOOL)addGraphicsObject: (FSPDFPage*)page graphicsobject: (FSGraphicsObject*)graphicsobject;
-(BOOL)removeGraphicsObject: (FSGraphicsObject*)graphics_object;
-(BOOL)removeUsage: (FSLayerContextUsageType)usage_type;
-(FSPDFDictionary*)getDict;

-(void)dealloc;

@end

@interface FSMetadata : FSBase
@property (nonatomic, copy, getter=getCreationDateTime) FSDateTime* creationDateTime;
@property (nonatomic, copy, getter=getModifiedDateTime) FSDateTime* modifiedDateTime;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document;
-(id)initWithOther: (FSMetadata*)other;
-(BOOL)isEmpty;
-(BOOL)hasKey: (NSString *)key;
-(NSArray<NSString *> *)getValues: (NSString *)key;
-(BOOL)setValues: (NSString *)key value_array: (NSArray<NSString *> *)value_array;
-(NSArray<NSString *> *)getCustomerKeys;
-(void)removeCustomerKey: (NSString *)key;

-(void)dealloc;

@end

@interface FSGraphicsObjectArray : FSBasicArray
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSGraphicsObjectArray*)other;
-(int)getSize;
-(int)getUpperBound;
-(BOOL)setSize: (int)nNewSize nGrowBy: (int)nGrowBy;
-(void)removeAll;
-(FSGraphicsObject*)getAt: (int)nIndex;
-(BOOL)setAt: (int)nIndex newElement: (FSGraphicsObject*)newElement;
-(BOOL)setAtGrow: (int)nIndex newElement: (FSGraphicsObject*)newElement;
-(BOOL)add: (FSGraphicsObject*)newElement;
-(BOOL)insertAt: (int)nIndex newElement: (FSGraphicsObject*)newElement nCount: (int)nCount;
-(BOOL)removeAt: (int)nIndex nCount: (int)nCount;
-(int)find: (FSGraphicsObject*)data iStart: (int)iStart;

-(void)dealloc;

@end

@interface FSColorState : FSBase
@property (nonatomic, copy, getter=getFillColor) FSColor* fillColor;
@property (nonatomic, copy, getter=getStrokeColor) FSColor* strokeColor;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSColorState*)other;
-(BOOL)isEmpty;

-(void)dealloc;

@end

@interface FSMarkedContent : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(BOOL)hasTag: (NSString *)tag_name;
-(int)getItemCount;
-(NSString *)getItemTagName: (int)index;
-(int)getItemMCID: (int)index;
-(FSPDFDictionary*)getItemPropertyDict: (int)index;
-(int)addItem: (NSString *)tag_name property_dict: (FSPDFDictionary*)property_dict;
-(BOOL)removeItem: (NSString *)tag_name;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSGraphicsObjectBlendMode) {
  FSGraphicsObjectBlendNormal = 0,
  FSGraphicsObjectBlendMultiply = 1,
  FSGraphicsObjectBlendScreen = 2,
  FSGraphicsObjectBlendOverlay = 3,
  FSGraphicsObjectBlendDarken = 4,
  FSGraphicsObjectBlendLighten = 5,
  FSGraphicsObjectBlendColorDodge = 6,
  FSGraphicsObjectBlendColorBurn = 7,
  FSGraphicsObjectBlendHardlight = 8,
  FSGraphicsObjectBlendSoftlight = 9,
  FSGraphicsObjectBlendDifference = 10,
  FSGraphicsObjectBlendExclusion = 11,
  FSGraphicsObjectBlendHue = 21,
  FSGraphicsObjectBlendSaturation = 22,
  FSGraphicsObjectBlendColor = 23,
  FSGraphicsObjectBlendLuminosity = 24
};

typedef NS_ENUM(NSInteger, FSGraphicsObjectType) {
  FSGraphicsObjectTypeAll = 0,
  FSGraphicsObjectTypeText = 1,
  FSGraphicsObjectTypePath = 2,
  FSGraphicsObjectTypeImage = 3,
  FSGraphicsObjectTypeShading = 4,
  FSGraphicsObjectTypeFormXObject = 5
};

@interface FSGraphicsObject : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getStrokeColor) unsigned int strokeColor;
@property (nonatomic, getter=getFillColor) unsigned int fillColor;
@property (nonatomic, copy, getter=getColorState) FSColorState* colorState;
@property (nonatomic, getter=getFillOpacity) float fillOpacity;
@property (nonatomic, getter=getStrokeOpacity) float strokeOpacity;
@property (nonatomic, copy, getter=getMatrix) FSMatrix2D* matrix;
@property (nonatomic, copy, getter=getGraphState) FSGraphState* graphState;
@property (nonatomic, getter=getBlendMode) FSGraphicsObjectBlendMode blendMode;
@property (nonatomic, copy, getter=getClipRect) FSRectF* clipRect;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(FSGraphicsObjectType)getType;
-(FSRectF*)getRect;
-(BOOL)hasTransparency;
-(BOOL)transform: (FSMatrix2D*)matrix need_transform_clippath: (BOOL)need_transform_clippath;
-(FSGraphicsObject*)clone;
-(int)getClipPathCount;
-(FSPath*)getClipPath: (int)index;
-(FSFillMode)getClipPathFillMode: (int)index;
-(BOOL)addClipPath: (FSPath*)path fill_mode: (FSFillMode)fill_mode;
-(BOOL)removeClipPath: (int)index;
-(int)getClipTextObjectCount;
-(FSTextObject*)getClipTextObject: (int)index;
-(BOOL)addClipTextObject: (FSTextObject*)textobject;
-(BOOL)removeClipTextObject: (int)index;
-(BOOL)clearClips;
-(FSMarkedContent*)getMarkedContent;
-(FSLayerNodeArray*)getLayers: (FSLayerTree*)layer_tree;
-(FSTextObject*)getTextObject;
-(FSFormXObject*)getFormXObject;
-(FSImageObject*)getImageObject;
-(FSPathObject*)getPathObject;
-(FSShadingObject*)getShadingObject;
-(void)rotate: (int)angle;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSTextStateMode) {
  FSTextStateModeFill = 0,
  FSTextStateModeStroke = 1,
  FSTextStateModeFillStroke = 2,
  FSTextStateModeInvisible = 3,
  FSTextStateModeFillClip = 4,
  FSTextStateModeStrokeClip = 5,
  FSTextStateModeFillStrokeClip = 6,
  FSTextStateModeClip = 7
};

@interface FSTextState : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getVersion) unsigned int version;
@property (nonatomic, getter=getFont_size) float font_size;
@property (nonatomic, getter=getCharspace) float charspace;
@property (nonatomic, getter=getWordspace) float wordspace;
@property (nonatomic, getter=getTextmode) FSTextStateMode textmode;
@property (nonatomic, copy, getter=getTextmatrix) NSArray<NSNumber *> * textmatrix;
@property (nonatomic, copy, getter=getOrigin_position) FSPointF* origin_position;
@property (nonatomic, copy, getter=getFont) FSFont* font;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithVersion: (unsigned int)version font: (FSFont*)font font_size: (float)font_size charspace: (float)charspace wordspace: (float)wordspace textmode: (FSTextStateMode)textmode origin_position: (FSPointF*)origin_position textmatrix: (NSArray<NSNumber *> *)textmatrix;
-(id)init;
-(id)initWithState: (FSTextState*)state;
-(void)set: (unsigned int)version font: (FSFont*)font font_size: (float)font_size charspace: (float)charspace wordspace: (float)wordspace textmode: (FSTextStateMode)textmode origin_position: (FSPointF*)origin_position textmatrix: (NSArray<NSNumber *> *)textmatrix;

-(void)dealloc;

@end

@interface FSImageObject : FSGraphicsObject
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSImageObject*)create: (FSPDFDoc*)document;
-(void)setBitmap: (FSBitmap*)bitmap mask: (FSBitmap*)mask;
-(void)setImage: (FSImage*)image frame_index: (int)frame_index;
-(FSBitmap*)cloneBitmap: (FSGraphicsObjects*)graphics_objects;
-(FSBitmap*)saveAsBitmap: (FSGraphicsObjects*)graphics_objects;
-(FSColorSpaceType)getColorSpace;
-(FSPDFStream*)getStream;
-(void)loadStream: (FSPDFDoc*)document stream: (FSPDFStream*)stream;
-(BOOL)isImageMask;
-(FSPDFObject*)getMask;

-(void)dealloc;

@end

@interface FSTextObject : FSGraphicsObject
@property (nonatomic, copy, getter=getText) NSString * text;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSTextObject*)create;
-(FSTextState*)getTextState: (FSPDFPage*)page;
-(void)setTextState: (FSPDFPage*)page text_state: (FSTextState*)text_state is_italic: (BOOL)is_italic weight: (int)weight;
-(int)getCharCount;
-(FSPointF*)getCharPos: (int)index;
-(float)getCharWidthByIndex: (int)index;
-(float)getCharHeightByIndex: (int)index;

-(void)dealloc;

@end

@interface FSPathObject : FSGraphicsObject
@property (nonatomic, getter=getFillMode) FSFillMode fillMode;
@property (nonatomic, getter=getStrokeState) BOOL strokeState;
@property (nonatomic, copy, getter=getPathData) FSPath* pathData;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSPathObject*)create;
+(FSPathObject*)createFromTextObject: (FSPDFPage*)page text_obj: (FSTextObject*)text_obj;

-(void)dealloc;

@end

@interface FSFormXObject : FSGraphicsObject
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSFormXObject*)create: (FSPDFDoc*)document;
-(FSPDFStream*)getStream;
-(FSGraphicsObjects*)getGraphicsObjects;
-(BOOL)importPageContent: (FSPDFPage*)source_page is_annots_included: (BOOL)is_annots_included;

-(void)dealloc;

@end

@interface FSShadingObject : FSGraphicsObject
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(FSPDFObject*)getPDFObject;

-(void)dealloc;

@end

@interface FSGraphicsObjects : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSGraphicsObjects*)other;
-(BOOL)isEmpty;
-(long)getFirstGraphicsObjectPosition: (FSGraphicsObjectType)filter;
-(long)getNextGraphicsObjectPosition: (long)position filter: (FSGraphicsObjectType)filter;
-(long)getLastGraphicsObjectPosition: (FSGraphicsObjectType)filter;
-(long)getPrevGraphicsObjectPosition: (long)position filter: (FSGraphicsObjectType)filter;
-(FSGraphicsObject*)getGraphicsObject: (long)position;
-(long)insertGraphicsObject: (long)position_insert_after graphics_object: (FSGraphicsObject*)graphics_object;
-(BOOL)removeGraphicsObject: (FSGraphicsObject*)graphics_object;
-(BOOL)removeGraphicsObjectByPosition: (long)position;
-(long)moveGraphicsObjectByPosition: (long)current_position position_move_after: (long)position_move_after;
-(long)getGraphicsObjectPosition: (FSGraphicsObject*)graphics_object;
-(int)getGraphicsObjectCount;
-(int)getGraphicsObjectIndex: (FSGraphicsObject*)graphics_object;
-(FSGraphicsObject*)getGraphicsObjectWithIndex: (int)index;
-(BOOL)generateContent;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSPDFPageParseFlags) {
  FSPDFPageParsePageNormal = 0x0000,
  FSPDFPageParsePageTextOnly = 0x0001
};

typedef NS_ENUM(NSInteger, FSPDFPageCalcMarginMode) {
  FSPDFPageCalcContentsBox = 0,
  FSPDFPageCalcDetection = 1
};

typedef NS_ENUM(NSInteger, FSPDFPageFlattenOptions) {
  FSPDFPageFlattenAll = 0,
  FSPDFPageFlattenNoAnnot = 0x0001,
  FSPDFPageFlattenNoFormControl = 0x0002
};

typedef NS_ENUM(NSInteger, FSPDFPageBoxType) {
  FSPDFPageMediaBox = 0,
  FSPDFPageCropBox = 1,
  FSPDFPageTrimBox = 2,
  FSPDFPageArtBox = 3,
  FSPDFPageBleedBox = 4
};

typedef NS_ENUM(NSInteger, FSPDFPageSize) {
  FSPDFPageSizeLetter = 1,
  FSPDFPageSizeLegal = 2,
  FSPDFPageSizeA2 = 3,
  FSPDFPageSizeA3 = 4,
  FSPDFPageSizeA4 = 5,
  FSPDFPageSizeA5 = 6,
  FSPDFPageSizeA6 = 7,
  FSPDFPageSizeB2 = 8,
  FSPDFPageSizeB3 = 9,
  FSPDFPageSizeB4 = 10,
  FSPDFPageSizeB5 = 11,
  FSPDFPageSizeB6 = 12
};

@interface FSPDFPage : FSGraphicsObjects
@property (nonatomic, getter=getRotation) FSRotation rotation;
@property (nonatomic, getter=getUserUnitSize) float userUnitSize;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document page_dict: (FSPDFDictionary*)page_dict;
-(FSPDFDoc*)getDocument;
-(FSPDFDictionary*)getDict;
-(BOOL)isParsed;
-(FSProgressive*)startParse: (unsigned int)flags pause: (id<FSPauseCallback>)pause is_reparse: (BOOL)is_reparse;
-(int)getIndex;
-(float)getHeight;
-(float)getWidth;
-(FSBitmap*)loadThumbnail;
-(FSMatrix2D*)getDisplayMatrix: (int)left top: (int)top width: (int)width height: (int)height rotate: (FSRotation)rotate;
-(FSRectF*)calcContentBBox: (FSPDFPageCalcMarginMode)mode;
-(int)getAnnotCount;
-(FSAnnot*)getAnnot: (int)index;
-(FSAnnot*)getAnnotAtPoint: (FSPointF*)position tolerance: (float)tolerance;
-(FSAnnot*)getAnnotAtDevicePoint: (FSPointF*)position tolerance: (float)tolerance matrix: (FSMatrix2D*)matrix;
-(FSAnnotArray*)getAnnotsAtPoint: (FSPointF*)position tolerance: (float)tolerance;
-(FSAnnotArray*)getAnnotsAtDevicePoint: (FSPointF*)position tolerance: (float)tolerance matrix: (FSMatrix2D*)matrix;
-(FSAnnot*)addAnnot: (FSAnnotType)type rect: (FSRectF*)rect;
-(FSAnnot*)addAnnotWithDictionary: (FSPDFDictionary*)annot_dict;
-(BOOL)removeAnnot: (FSAnnot*)annot;
-(void)moveAnnotToFirst: (FSAnnot*)annot;
-(void)moveAnnotToLast: (FSAnnot*)annot;
-(void)moveAnnotToPrev: (FSAnnot*)annot;
-(void)moveAnnotToNext: (FSAnnot*)annot;
-(void)updateAnnotList;
-(BOOL)hasTransparency;
-(BOOL)flatten: (BOOL)for_display options: (unsigned int)options;
-(BOOL)flattenAnnot: (FSAnnot*)annot;
-(BOOL)setAnnotGroup: (FSMarkupArray*)annot_array header_index: (int)header_index;
-(FSSignature*)addSignature: (FSRectF*)rect;
-(FSSignature*)addSignatureWithFieldName: (FSRectF*)rect field_name: (NSString *)field_name;
-(FSSignature*)addSignatureWithSignatureType: (FSRectF*)rect field_name: (NSString *)field_name signature_type: (FSSignatureSignatureType)signature_type to_check_permission: (BOOL)to_check_permission;
-(BOOL)hasWatermark;
-(BOOL)removeAllWatermarks;
-(void)setSize: (float)width height: (float)height;
-(void)setBox: (FSPDFPageBoxType)box_type box: (FSRectF*)box;
-(FSRectF*)getBox: (FSPDFPageBoxType)box_type;
-(BOOL)transform: (FSMatrix2D*)matrix need_transform_clip_path: (BOOL)need_transform_clip_path;
-(BOOL)normalize;
-(void)setClipRect: (FSRectF*)clip_rect;
-(void)setThumbnail: (FSBitmap*)thumbnail;
-(FSGraphicsObject*)getGraphicsObjectAtPoint: (FSPointF*)point tolerance: (float)tolerance filter: (FSGraphicsObjectType)filter;
-(FSGraphicsObjectArray*)getGraphicsObjectsAtPoint: (FSPointF*)point tolerance: (float)tolerance filter: (FSGraphicsObjectType)filter;
-(FSGraphicsObject*)getGraphicsObjectAtDevicePoint: (FSPointF*)point tolerance: (float)tolerance matrix: (FSMatrix2D*)matrix filter: (FSGraphicsObjectType)filter;
-(FSGraphicsObjectArray*)getGraphicsObjectsAtDevicePoint: (FSPointF*)point tolerance: (float)tolerance matrix: (FSMatrix2D*)matrix filter: (FSGraphicsObjectType)filter;
-(FSGraphicsObject*)getGraphicsObjectAtRectangle: (FSRectF*)rect filter: (FSGraphicsObjectType)filter;
-(FSGraphicsObjectArray*)getGraphicsObjectsAtRectangle: (FSRectF*)rect filter: (FSGraphicsObjectType)filter;
-(BOOL)addImage: (FSImage*)image frame_index: (int)frame_index position: (FSPointF*)position width: (float)width height: (float)height auto_generate_content: (BOOL)auto_generate_content;
-(BOOL)addImageFromFilePath: (NSString *)file_path position: (FSPointF*)position width: (float)width height: (float)height auto_generate_content: (BOOL)auto_generate_content;
-(FSPDFArray*)getAnnots;
-(FSPDFDictionary*)getResources;
-(FSPDFObject*)getContents;
-(FSPDFStream*)getThumb;
-(FSPDFObject*)getInheritedAttribute: (NSString *)attruibute_name;
-(void)clearRenderCache;
-(FSRectF*)getSuggestedRect: (FSBitmap*)render_result render_matrix: (FSMatrix2D*)render_matrix point: (FSPointF*)point;
-(BOOL)addText: (NSString *)text rect: (FSRectF*)rect style: (FSRichTextStyle*)style;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSDocViewerPrefsPrintScale) {
  FSDocViewerPrefsPrintScaleNone = 0,
  FSDocViewerPrefsPrintScaleAppDefault = 1
};

typedef NS_ENUM(NSInteger, FSDocViewerPrefsViewerPref) {
  FSDocViewerPrefsHideToolbar = 0,
  FSDocViewerPrefsHideMenubar = 1,
  FSDocViewerPrefsHideWindowUI = 2,
  FSDocViewerPrefsFitWindow = 3,
  FSDocViewerPrefsCenterWindow = 4,
  FSDocViewerPrefsDisplayDocTitle = 5
};

@interface FSDocViewerPrefs : FSBase
@property (nonatomic, getter=getNonFullScreenPageMode) FSPDFDocDisplayMode nonFullScreenPageMode;
@property (nonatomic, getter=getReadingDirection) BOOL readingDirection;
@property (nonatomic, getter=getViewArea) FSPDFPageBoxType viewArea;
@property (nonatomic, getter=getViewClip) FSPDFPageBoxType viewClip;
@property (nonatomic, getter=getPrintArea) FSPDFPageBoxType printArea;
@property (nonatomic, getter=getPrintClip) FSPDFPageBoxType printClip;
@property (nonatomic, getter=getPrintScale) FSDocViewerPrefsPrintScale printScale;
@property (nonatomic, getter=getPrintCopies) int printCopies;
@property (nonatomic, copy, getter=getPrintRange) FSRange* printRange;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document pdf_dict: (FSPDFDictionary*)pdf_dict;
-(id)initWithOther: (FSDocViewerPrefs*)other;
-(BOOL)isEmpty;
-(BOOL)getUIDisplayStatus: (FSDocViewerPrefsViewerPref)pref;
-(void)setUIDisplayStatus: (FSDocViewerPrefsViewerPref)pref value: (BOOL)value;
-(FSPDFDictionary*)getDict;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSPageLabelsStyle) {
  FSPageLabelsNone = 0,
  FSPageLabelsDecimalNums = 1,
  FSPageLabelsUpperRomanNums = 2,
  FSPageLabelsLowerRomanNums = 3,
  FSPageLabelsUpperLetters = 4,
  FSPageLabelsLowerLetters = 5
};

@interface FSPageLabels : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document;
-(id)initWithOther: (FSPageLabels*)other;
-(BOOL)isEmpty;
-(NSString *)getPageLabelTitle: (int)page_index;
-(BOOL)hasPageLabel: (int)page_index;
-(FSPageLabelsStyle)getPageLabelStyle: (int)page_index;
-(NSString *)getPageLabelPrefix: (int)page_index;
-(int)getPageLabelStart: (int)page_index;
-(void)setPageLabel: (int)page_index label_style: (FSPageLabelsStyle)label_style first_label_number: (int)first_label_number prefix_string: (NSString *)prefix_string;
-(void)removePageLabel: (int)page_index;
-(void)removeAll;
-(FSPDFNumberTree*)getNumberTree;

-(void)dealloc;

@end



@interface FSPSI : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithBitmap: (FSBitmap*)bitmap simulate: (BOOL)simulate;
-(id)initWithWidth: (int)width height: (int)height simulate: (BOOL)simulate;
-(id)initWithOther: (FSPSI*)other;
-(BOOL)isEmpty;
-(void)setCallback: (id<FSPSICallback>)callback;
-(void)setColor: (unsigned int)color;
-(void)setDiameter: (int)diameter;
-(void)setOpacity: (float)opacity;
-(void)addPoint: (FSPointF*)point type: (FSPathPointType)type pressure: (float)pressure;
-(FSRectF*)getContentsRect;
-(FSBitmap*)getBitmap;
-(FSPSInk*)convertToPDFAnnot: (FSPDFPage*)page annot_rect: (FSRectF*)annot_rect rotate: (FSRotation)rotate;

-(void)dealloc;

@end

@interface FSReadingBookmark : FSBase
@property (nonatomic, copy, getter=getTitle) NSString * title;
@property (nonatomic, getter=getPageIndex) int pageIndex;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSReadingBookmark*)other;
-(BOOL)isEmpty;
-(FSDateTime*)getDateTime: (BOOL)is_creation_date;
-(void)setDateTime: (FSDateTime*)date_time is_creation_date: (BOOL)is_creation_date;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSReflowPageFlags) {
  FSReflowPageNormal = 0x0,
  FSReflowPageWithImage = 0x1,
  FSReflowPageNoTruncate = 0x2
};

@interface FSReflowPage : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithPage: (FSPDFPage*)page;
-(id)initWithOther: (FSReflowPage*)other;
-(BOOL)isEmpty;
-(void)setScreenSize: (float)width height: (float)height;
-(void)setScreenMargin: (int)left top: (int)top right: (int)right bottom: (int)bottom;
-(void)setZoom: (int)zoom;
-(void)setParseFlags: (unsigned int)flags;
-(void)setLineSpace: (float)line_space;
-(void)setImageScale: (float)image_scale;
-(void)setTopSpace: (float)top_space;
-(FSProgressive*)startParse: (id<FSPauseCallback>)pause;
-(float)getContentWidth;
-(float)getContentHeight;
-(FSMatrix2D*)getDisplayMatrix: (float)offset_x offset_y: (float)offset_y width: (int)width height: (int)height rotate: (FSRotation)rotate;
-(NSString *)getFocusData: (FSMatrix2D*)matrix point: (FSPointF*)point;
-(FSPointF*)getFocusPosition: (FSMatrix2D*)matrix focus_data: (NSString *)focus_data;
-(BOOL)isParsed;

-(void)dealloc;

@end



typedef NS_ENUM(NSInteger, FSTextPageCharInfoTextCharFlag) {
  FSTextPageCharInfoUnknown = -1,
  FSTextPageCharInfoNormal = 0,
  FSTextPageCharInfoGenerated = 1,
  FSTextPageCharInfoUnUnicode = 2,
  FSTextPageCharInfoHyphen = 3,
  FSTextPageCharInfoComboWord = 4
};

@interface FSTextPageCharInfo : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getFont) FSFont* font;
@property (nonatomic, getter=getFlag) FSTextPageCharInfoTextCharFlag flag;
@property (nonatomic, getter=getFont_size) float font_size;
@property (nonatomic, getter=getOrigin_x) float origin_x;
@property (nonatomic, getter=getOrigin_y) float origin_y;
@property (nonatomic, copy, getter=getChar_box) FSRectF* char_box;
@property (nonatomic, copy, getter=getChar_outbox) FSRectF* char_outbox;
@property (nonatomic, copy, getter=getMatrix) FSMatrix2D* matrix;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithFont: (FSFont*)font flag: (FSTextPageCharInfoTextCharFlag)flag font_size: (float)font_size origin_x: (float)origin_x origin_y: (float)origin_y char_box: (FSRectF*)char_box char_outbox: (FSRectF*)char_outbox matrix: (FSMatrix2D*)matrix;
-(id)initWithChar_info: (FSTextPageCharInfo*)char_info;
-(void)set: (FSFont*)font flag: (FSTextPageCharInfoTextCharFlag)flag font_size: (float)font_size origin_x: (float)origin_x origin_y: (float)origin_y char_box: (FSRectF*)char_box char_outbox: (FSRectF*)char_outbox matrix: (FSMatrix2D*)matrix;
-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSTextPageTextParseFlags) {
  FSTextPageParseTextNormal = 0x0000,
  FSTextPageParseTextOutputHyphen = 0x0001,
  FSTextPageParseTextUseStreamOrder = 0x0002
};

typedef NS_ENUM(NSInteger, FSTextPageTextOrderFlag) {
  FSTextPageTextStreamOrder = 0,
  FSTextPageTextDisplayOrder = 1
};

@interface FSTextPage : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithPage: (FSPDFPage*)page flags: (int)flags;
-(id)initWithOther: (FSTextPage*)other;
-(BOOL)isEmpty;
-(int)getCharCount;
-(FSTextPageCharInfo*)getCharInfo: (int)char_index;
-(NSString *)getChars: (int)start count: (int)count;
-(int)getIndexAtPos: (float)x y: (float)y tolerance: (float)tolerance;
-(NSString *)getTextInRect: (FSRectF*)rect;
-(NSString *)getText: (FSTextPageTextOrderFlag)flag;
-(FSRange*)getWordAtPos: (float)x y: (float)y tolerance: (float)tolerance;
-(int)getTextRectCount: (int)start count: (int)count;
-(FSRectF*)getTextRect: (int)rect_index;
-(FSRotation)getBaselineRotation: (int)rect_index;
-(FSRectFArray*)getTextRectArrayByRect: (FSRectF*)rect;
-(FSRange*)getCharRange: (FSRectF*)rect;
-(NSString *)getTextUnderAnnot: (FSAnnot*)annot;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSTextSearchSearchFlags) {
  FSTextSearchSearchNormal = 0x00,
  FSTextSearchSearchMatchCase = 0x01,
  FSTextSearchSearchMatchWholeWord = 0x02,
  FSTextSearchSearchConsecutive = 0x04
};

@interface FSTextSearch : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document cancel: (id<FSSearchCancelCallback>)cancel flags: (int)flags;
-(id)initWithXfa_document: (FSXFADoc*)xfa_document;
-(id)initWithAnnot: (FSAnnot*)annot;
-(id)initWithOther: (FSTextSearch*)other;
-(BOOL)isEmpty;
-(BOOL)setPattern: (NSString *)key_words;
-(BOOL)setStartPage: (int)page_index;
-(BOOL)setEndPage: (int)page_index;
-(BOOL)setStartCharacter: (int)char_index;
-(BOOL)setSearchFlags: (unsigned int)search_flags;
-(BOOL)findNext;
-(BOOL)findPrev;
-(FSRectFArray*)getMatchRects;
-(int)getMatchPageIndex;
-(NSString *)getMatchSentence;
-(int)getMatchSentenceStartIndex;
-(int)getMatchSentenceEndIndex;
-(int)getMatchStartCharIndex;
-(int)getMatchEndCharIndex;

-(void)dealloc;

@end

@interface FSTextLink : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSTextLink*)other;
-(BOOL)isEmpty;
-(NSString *)getURI;
-(int)getStartCharIndex;
-(int)getEndCharIndex;
-(FSRectFArray*)getRects;

-(void)dealloc;

@end

@interface FSPageTextLinks : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithPage: (FSTextPage*)page;
-(id)initWithOther: (FSPageTextLinks*)other;
-(BOOL)isEmpty;
-(int)getTextLinkCount;
-(FSTextLink*)getTextLink: (int)index;

-(void)dealloc;

@end

@interface FSEnvelopeArray : FSBasicArray
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSEnvelopeArray*)other;
-(int)getSize;
-(int)getUpperBound;
-(BOOL)setSize: (int)nNewSize nGrowBy: (int)nGrowBy;
-(void)removeAll;
-(FSEnvelope*)getAt: (int)nIndex;
-(BOOL)setAt: (int)nIndex newElement: (FSEnvelope*)newElement;
-(BOOL)setAtGrow: (int)nIndex newElement: (FSEnvelope*)newElement;
-(BOOL)add: (FSEnvelope*)newElement;
-(BOOL)insertAt: (int)nIndex newElement: (FSEnvelope*)newElement nCount: (int)nCount;
-(BOOL)removeAt: (int)nIndex nCount: (int)nCount;
-(int)find: (FSEnvelope*)data iStart: (int)iStart;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSSecurityHandlerCipherType) {
  FSSecurityHandlerCipherNone = 0,
  FSSecurityHandlerCipherRC4 = 1,
  FSSecurityHandlerCipherAES = 2
};

@interface FSSecurityHandler : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSSecurityHandler*)other;
-(BOOL)isEmpty;
-(FSPDFDocEncryptType)getSecurityType;

-(void)dealloc;

@end

@interface FSStdEncryptData : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getIs_encrypt_metadata) BOOL is_encrypt_metadata;
@property (nonatomic, getter=getUser_permissions) unsigned int user_permissions;
@property (nonatomic, getter=getCipher) FSSecurityHandlerCipherType cipher;
@property (nonatomic, getter=getKey_length) int key_length;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithIs_encrypt_metadata: (BOOL)is_encrypt_metadata user_permissions: (unsigned int)user_permissions cipher: (FSSecurityHandlerCipherType)cipher key_length: (int)key_length;
-(id)init;
-(id)initWithOther: (FSStdEncryptData*)other;
-(void)set: (BOOL)is_encrypt_metadata user_permissions: (unsigned int)user_permissions cipher: (FSSecurityHandlerCipherType)cipher key_length: (int)key_length;
-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSStdSecurityHandlerModifyFlag) {
  FSStdSecurityHandlerModifyPermission = 0x01,
  FSStdSecurityHandlerModifyUserPassword = 0x02,
  FSStdSecurityHandlerModifyOwnerPassword = 0x04
};

@interface FSStdSecurityHandler : FSSecurityHandler
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSSecurityHandler*)other;
-(BOOL)initialize: (FSStdEncryptData*)encrypt_data user_password: (NSString *)user_password owner_password: (NSString *)owner_password;
-(BOOL)initializeW: (FSStdEncryptData*)encrypt_data user_password: (NSString *)user_password owner_password: (NSString *)owner_password;
-(void)setAES256ModifyFlags: (unsigned int)modify_flags;

-(void)dealloc;

@end

@interface FSCertificateEncryptData : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getIs_encrypt_metadata) BOOL is_encrypt_metadata;
@property (nonatomic, getter=getCipher) FSSecurityHandlerCipherType cipher;
@property (nonatomic, copy, getter=getEnvelopes) NSArray<NSData *> * envelopes;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithIs_encrypt_metadata: (BOOL)is_encrypt_metadata cipher: (FSSecurityHandlerCipherType)cipher envelopes: (NSArray<NSData *> *)envelopes;
-(id)init;
-(id)initWithOther: (FSCertificateEncryptData*)other;
-(void)set: (BOOL)is_encrypt_metadata cipher: (FSSecurityHandlerCipherType)cipher envelopes: (NSArray<NSData *> *)envelopes;
-(void)dealloc;

@end

@interface FSEnvelope : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithCertFilePath: (NSString *)certFilePath;
-(id)initWithOther: (FSEnvelope*)other;
-(NSString *)getDecryptionKey: (NSString *)p12FilePath password: (NSString *)password;
-(id)initWithBuffer: (NSData *)buffer;

-(void)dealloc;

@end

@interface FSCertificateSecurityHandler : FSSecurityHandler
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSSecurityHandler*)other;
-(BOOL)initialize: (FSEnvelopeArray*)envelopes cipher: (FSSecurityHandlerCipherType)cipher is_encrypt_metadata: (BOOL)is_encrypt_metadata;

-(void)dealloc;

@end

@interface FSDRMEncryptData : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getIs_encrypt_metadata) BOOL is_encrypt_metadata;
@property (nonatomic, copy, getter=getSub_filter) NSString * sub_filter;
@property (nonatomic, getter=getCipher) FSSecurityHandlerCipherType cipher;
@property (nonatomic, getter=getKey_length) int key_length;
@property (nonatomic, getter=getIs_owner) BOOL is_owner;
@property (nonatomic, getter=getUser_permissions) unsigned int user_permissions;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithIs_encrypt_metadata: (BOOL)is_encrypt_metadata sub_filter: (NSString *)sub_filter cipher: (FSSecurityHandlerCipherType)cipher key_length: (int)key_length is_owner: (BOOL)is_owner user_permissions: (unsigned int)user_permissions;
-(id)init;
-(id)initWithOther: (FSDRMEncryptData*)other;
-(void)set: (BOOL)is_encrypt_metadata sub_filter: (NSString *)sub_filter cipher: (FSSecurityHandlerCipherType)cipher key_length: (int)key_length is_owner: (BOOL)is_owner user_permissions: (unsigned int)user_permissions;
-(void)dealloc;

@end

@interface FSDRMSecurityHandler : FSSecurityHandler
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSSecurityHandler*)other;
-(BOOL)initialize: (FSDRMEncryptData*)encrypt_data file_id: (NSString *)file_id initial_key: (NSString *)initial_key;
-(NSString *)getDRMValue: (NSString *)key;
-(BOOL)setDRMValue: (NSString *)key value: (NSString *)value;
-(BOOL)verifyEncryptionParams;

-(void)dealloc;

@end

@interface FSCustomEncryptData : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getIs_encrypt_metadata) BOOL is_encrypt_metadata;
@property (nonatomic, copy, getter=getFilter) NSString * filter;
@property (nonatomic, copy, getter=getSub_filter) NSString * sub_filter;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithIs_encrypt_metadata: (BOOL)is_encrypt_metadata filter: (NSString *)filter sub_filter: (NSString *)sub_filter;
-(id)init;
-(id)initWithOther: (FSCustomEncryptData*)other;
-(void)set: (BOOL)is_encrypt_metadata filter: (NSString *)filter sub_filter: (NSString *)sub_filter;
-(void)dealloc;

@end

@interface FSCustomSecurityHandler : FSSecurityHandler
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSSecurityHandler*)other;
-(BOOL)initialize: (FSCustomEncryptData*)encrypt_data callback: (id<FSCustomSecurityCallback>)callback encrypt_info: (NSString *)encrypt_info;

-(void)dealloc;

@end

@interface FSRMSEncryptData : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getIs_encrypt_metadata) BOOL is_encrypt_metadata;
@property (nonatomic, copy, getter=getPublish_license) NSString * publish_license;
@property (nonatomic, copy, getter=getServer_eul_list) NSArray<NSData *> * server_eul_list;
@property (nonatomic, getter=getIrm_version) float irm_version;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithIs_encrypt_metadata: (BOOL)is_encrypt_metadata publish_license: (NSData *)publish_license server_eul_list: (NSArray<NSData *> *)server_eul_list irm_version: (float)irm_version;
-(id)init;
-(id)initWithOther: (FSRMSEncryptData*)other;
-(void)set: (BOOL)is_encrypt_metadata publish_license: (NSString *)publish_license server_eul_list: (NSArray<NSData *> *)server_eul_list irm_version: (float)irm_version;
-(void)dealloc;

@end

@interface FSRMSSecurityHandler : FSSecurityHandler
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSSecurityHandler*)other;
-(BOOL)initialize: (FSRMSEncryptData*)encrypt_data callback: (id<FSRMSSecurityCallback>)callback;

-(void)dealloc;

@end











typedef NS_ENUM(NSInteger, FSTabOrderMgrOrderType) {
  FSTabOrderMgrNone = 0x0000,
  FSTabOrderMgrRow = 0x0001,
  FSTabOrderMgrColumn = 0x0002,
  FSTabOrderMgrStructure = 0x0003
};

@interface FSTabOrderMgr : FSBase
@property (nonatomic, getter=getOrderType) FSTabOrderMgrOrderType orderType;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithPage: (FSPDFPage*)page;
-(id)initWithOther: (FSTabOrderMgr*)other;
-(BOOL)isEmpty;
-(void)reload;
-(FSAnnot*)getFirstAnnot;
-(FSAnnot*)getLastAnnot;
-(FSAnnot*)getNextAnnot: (FSAnnot*)annot;
-(FSAnnot*)getPrevAnnot: (FSAnnot*)annot;
-(BOOL)adjustStructureOrder: (FSAnnotArray*)annot_array;

-(void)dealloc;

@end

@interface FSWatermark : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document text: (NSString *)text properties: (FSWatermarkTextProperties*)properties settings: (FSWatermarkSettings*)settings;
-(id)initWithDocument: (FSPDFDoc*)document bitmap: (FSBitmap*)bitmap settings: (FSWatermarkSettings*)settings;
-(id)initWithDocument: (FSPDFDoc*)document image: (FSImage*)image frame_index: (int)frame_index settings: (FSWatermarkSettings*)settings;
-(id)initWithDocument: (FSPDFDoc*)document page: (FSPDFPage*)page settings: (FSWatermarkSettings*)settings;
-(id)initWithOther: (FSWatermark*)other;
-(BOOL)isEmpty;
-(float)getWidth;
-(float)getHeight;
-(BOOL)insertToPage: (FSPDFPage*)page;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSWatermarkSettingsFlags) {
  FSWatermarkSettingsFlagASPageContents = 0x0000,
  FSWatermarkSettingsFlagASAnnot = 0x0001,
  FSWatermarkSettingsFlagOnTop = 0x0002,
  FSWatermarkSettingsFlagNoPrint = 0x0004,
  FSWatermarkSettingsFlagInvisible = 0x0008,
  FSWatermarkSettingsFlagShareImageStream = 0x0010
};

@interface FSWatermarkSettings : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getPosition) FSPosition position;
@property (nonatomic, getter=getOffset_x) float offset_x;
@property (nonatomic, getter=getOffset_y) float offset_y;
@property (nonatomic, getter=getFlags) unsigned int flags;
@property (nonatomic, getter=getScale_x) float scale_x;
@property (nonatomic, getter=getScale_y) float scale_y;
@property (nonatomic, getter=getRotation) float rotation;
@property (nonatomic, getter=getOpacity) int opacity;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithPosition: (FSPosition)position offset_x: (float)offset_x offset_y: (float)offset_y flags: (unsigned int)flags scale_x: (float)scale_x scale_y: (float)scale_y rotation: (float)rotation opacity: (int)opacity;
-(id)init;
-(id)initWithSettings: (FSWatermarkSettings*)settings;
-(void)set: (FSPosition)position offset_x: (float)offset_x offset_y: (float)offset_y flags: (unsigned int)flags scale_x: (float)scale_x scale_y: (float)scale_y rotation: (float)rotation opacity: (int)opacity;
-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSWatermarkTextPropertiesFontStyle) {
  FSWatermarkTextPropertiesFontStyleNormal = 0,
  FSWatermarkTextPropertiesFontStyleUnderline = 1
};

@interface FSWatermarkTextProperties : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getFont_size) float font_size;
@property (nonatomic, getter=getColor) unsigned int color;
@property (nonatomic, getter=getFont_style) FSWatermarkTextPropertiesFontStyle font_style;
@property (nonatomic, getter=getLine_space) float line_space;
@property (nonatomic, getter=getAlignment) FSAlignment alignment;
@property (nonatomic, copy, getter=getFont) FSFont* font;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithFont: (FSFont*)font font_size: (float)font_size color: (unsigned int)color style: (FSWatermarkTextPropertiesFontStyle)style line_space: (float)line_space alignment: (FSAlignment)alignment;
-(id)init;
-(id)initWithProperties: (FSWatermarkTextProperties*)properties;
-(void)set: (FSFont*)font font_size: (float)font_size color: (unsigned int)color style: (FSWatermarkTextPropertiesFontStyle)style line_space: (float)line_space alignment: (FSAlignment)alignment;

-(void)dealloc;

@end

@interface FSTimer : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(void)onTimer: (int)timer;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSFillerAssistCallbackPopupMenuItem) {
  FSFillerAssistCallbackPopupMenuItemNone = 0,
  FSFillerAssistCallbackPopupMenuItemCut = 1,
  FSFillerAssistCallbackPopupMenuItemCopy = 2,
  FSFillerAssistCallbackPopupMenuItemPaste = 3,
  FSFillerAssistCallbackPopupMenuItemDelete = 4,
  FSFillerAssistCallbackPopupMenuItemSelectAll = 5
};



typedef NS_ENUM(NSInteger, FSFillerVirtualKeyCode) {
  FSFillerVkeyUnknown = 0x00,
  FSFillerVkeyBack = 0x08,
  FSFillerVkeyTab = 0x09,
  FSFillerVkeyReturn = 0x0D,
  FSFillerVkeyShift = 0x10,
  FSFillerVkeyControl = 0x11,
  FSFillerVkeyMenu = 0x12,
  FSFillerVkeyPause = 0x13,
  FSFillerVkeyEscape = 0x1B,
  FSFillerVkeySpace = 0x20,
  FSFillerVkeyPrior = 0x21,
  FSFillerVkeyNext = 0x22,
  FSFillerVkeyEnd = 0x23,
  FSFillerVkeyHome = 0x24,
  FSFillerVkeyLeft = 0x25,
  FSFillerVkeyUp = 0x26,
  FSFillerVkeyRight = 0x27,
  FSFillerVkeyDown = 0x28,
  FSFillerVkeyPrint = 0x2A,
  FSFillerVkeySnapshot = 0x2C,
  FSFillerVkeyInsert = 0x2D,
  FSFillerVkeyDelete = 0x2E,
  FSFillerVkeyHelp = 0x2F,
  FSFillerVkey0 = 0x30,
  FSFillerVkey1 = 0x31,
  FSFillerVkey2 = 0x32,
  FSFillerVkey3 = 0x33,
  FSFillerVkey4 = 0x34,
  FSFillerVkey5 = 0x35,
  FSFillerVkey6 = 0x36,
  FSFillerVkey7 = 0x37,
  FSFillerVkey8 = 0x38,
  FSFillerVkey9 = 0x39,
  FSFillerVkeyA = 0x41,
  FSFillerVkeyB = 0x42,
  FSFillerVkeyC = 0x43,
  FSFillerVkeyD = 0x44,
  FSFillerVkeyE = 0x45,
  FSFillerVkeyF = 0x46,
  FSFillerVkeyG = 0x47,
  FSFillerVkeyH = 0x48,
  FSFillerVkeyI = 0x49,
  FSFillerVkeyJ = 0x4A,
  FSFillerVkeyK = 0x4B,
  FSFillerVkeyL = 0x4C,
  FSFillerVkeyM = 0x4D,
  FSFillerVkeyN = 0x4E,
  FSFillerVkeyO = 0x4F,
  FSFillerVkeyP = 0x50,
  FSFillerVkeyQ = 0x51,
  FSFillerVkeyR = 0x52,
  FSFillerVkeyS = 0x53,
  FSFillerVkeyT = 0x54,
  FSFillerVkeyU = 0x55,
  FSFillerVkeyV = 0x56,
  FSFillerVkeyW = 0x57,
  FSFillerVkeyX = 0x58,
  FSFillerVkeyY = 0x59,
  FSFillerVkeyZ = 0x5A,
  FSFillerVkeyNumpad0 = 0x60,
  FSFillerVkeyNumpad1 = 0x61,
  FSFillerVkeyNumpad2 = 0x62,
  FSFillerVkeyNumpad3 = 0x63,
  FSFillerVkeyNumpad4 = 0x64,
  FSFillerVkeyNumpad5 = 0x65,
  FSFillerVkeyNumpad6 = 0x66,
  FSFillerVkeyNumpad7 = 0x67,
  FSFillerVkeyNumpad8 = 0x68,
  FSFillerVkeyNumpad9 = 0x69,
  FSFillerVkeyMultiply = 0x6A,
  FSFillerVkeyAdd = 0x6B,
  FSFillerVkeySeparator = 0x6C,
  FSFillerVkeySubtract = 0x6D,
  FSFillerVkeyDecimal = 0x6E,
  FSFillerVkeyDivide = 0x6F,
  FSFillerVkeyF1 = 0x70,
  FSFillerVkeyF2 = 0x71,
  FSFillerVkeyF3 = 0x72,
  FSFillerVkeyF4 = 0x73,
  FSFillerVkeyF5 = 0x74,
  FSFillerVkeyF6 = 0x75,
  FSFillerVkeyF7 = 0x76,
  FSFillerVkeyF8 = 0x77,
  FSFillerVkeyF9 = 0x78,
  FSFillerVkeyF10 = 0x79,
  FSFillerVkeyF11 = 0x7A,
  FSFillerVkeyF12 = 0x7B
};

typedef NS_ENUM(NSInteger, FSFillerEventFlags) {
  FSFillerEventFlagShiftKey = 0x0001,
  FSFillerEventFlagControlKey = 0x0002,
  FSFillerEventFlagAltKey = 0x0004,
  FSFillerEventFlagMetaKey = 0x0008,
  FSFillerEventFlagKeyPad = 0x0010,
  FSFillerEventFlagAutoRepeat = 0x0020,
  FSFillerEventFlagLeftButtonDown = 0x0040,
  FSFillerEventFlagMiddleButtonDown = 0x0080,
  FSFillerEventFlagRightButtonDown = 0x0100,
  FSFillerEventFlagCommand = 0x0200
};

@interface FSFiller : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithForm: (FSForm*)form assist: (id<FSFillerAssistCallback>)assist;
-(id)initWithOther: (FSFiller*)other;
-(BOOL)isEmpty;
-(void)render: (FSPDFPage*)page matrix: (FSMatrix2D*)matrix renderer: (FSRenderer*)renderer;
-(BOOL)onLButtonDown: (FSPDFPage*)page point: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onLButtonUp: (FSPDFPage*)page point: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onLButtonDoubleClick: (FSPDFPage*)page point: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onMouseMove: (FSPDFPage*)page point: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onMouseEnter: (FSPDFPage*)page point: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onMouseHover: (FSPDFPage*)page point: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onMouseLeave: (FSPDFPage*)page point: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onMouseWheel: (FSPDFPage*)page point: (FSPointF*)point delta: (int)delta flags: (unsigned int)flags;
-(BOOL)onRButtonDown: (FSPDFPage*)page point: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onRButtonUp: (FSPDFPage*)page point: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onRButtonDoubleClick: (FSPDFPage*)page point: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onWheelButtonDown: (FSPDFPage*)page point: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onWheelButtonUp: (FSPDFPage*)page point: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onWheelButtonDoubleClick: (FSPDFPage*)page point: (FSPointF*)point flags: (unsigned int)flags;
-(BOOL)onKeyDown: (unsigned int)key_code flags: (unsigned int)flags;
-(BOOL)onKeyUp: (unsigned int)key_code flags: (unsigned int)flags;
-(BOOL)onChar: (unsigned int)char_code flags: (unsigned int)flags;
-(BOOL)setFocus: (FSControl*)control;
-(BOOL)killFocus;
-(void)highlightFormFields: (BOOL)is_highlight;
-(void)highlightFormFieldsAndSignature: (BOOL)is_highlight is_sign_highlight: (BOOL)is_sign_highlight;
-(void)setHighlightColor: (unsigned int)color;
-(void)showOverflowIndicator: (BOOL)is_show_overflow_indicator;
-(BOOL)onCut;
-(BOOL)onCopy;
-(BOOL)onPaste;
-(BOOL)onSelectAll;
-(BOOL)onDelete;

-(void)dealloc;

@end

@interface FSFieldArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSFieldArray*)other;
-(unsigned long)getSize;
-(FSField*)getAt: (unsigned long)index;
-(void)add: (FSField*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSField*)element;
-(void)removeAll;

-(void)dealloc;

@end

@interface FSChoiceOption : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getOption_value) NSString * option_value;
@property (nonatomic, copy, getter=getOption_label) NSString * option_label;
@property (nonatomic, getter=getSelected) BOOL selected;
@property (nonatomic, getter=getDefault_selected) BOOL default_selected;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOption_value: (NSString *)option_value option_label: (NSString *)option_label selected: (BOOL)selected default_selected: (BOOL)default_selected;
-(id)initWithOption: (FSChoiceOption*)option;
-(void)set: (NSString *)option_value option_label: (NSString *)option_label selected: (BOOL)selected default_selected: (BOOL)default_selected;
-(void)dealloc;

@end

@interface FSChoiceOptionArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSChoiceOptionArray*)other;
-(unsigned long)getSize;
-(FSChoiceOption*)getAt: (unsigned long)index;
-(void)add: (FSChoiceOption*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSChoiceOption*)element;
-(void)removeAll;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSFieldType) {
  FSFieldTypeUnknown = 0,
  FSFieldTypePushButton = 1,
  FSFieldTypeCheckBox = 2,
  FSFieldTypeRadioButton = 3,
  FSFieldTypeComboBox = 4,
  FSFieldTypeListBox = 5,
  FSFieldTypeTextField = 6,
  FSFieldTypeSignature = 7
};

typedef NS_ENUM(NSInteger, FSFieldFlags) {
  FSFieldFlagReadOnly = 0x01,
  FSFieldFlagRequired = 0x02,
  FSFieldFlagNoExport = 0x04,
  FSFieldFlagButtonNoToggleToOff = 0x100,
  FSFieldFlagButtonRadiosInUnison = 0x200,
  FSFieldFlagTextMultiline = 0x100,
  FSFieldFlagTextPassword = 0x200,
  FSFieldFlagTextFileSelect = 0x400,
  FSFieldFlagTextNoSpellCheck = 0x800,
  FSFieldFlagTextDoNotScroll = 0x1000,
  FSFieldFlagTextComb = 0x2000,
  FSFieldFlagComboEdit = 0x100,
  FSFieldFlagChoiceMultiSelect = 0x100,
  FSFieldFlagTextRichText = 0x4000,
  FSFieldFlagChoiceSort = 0x200,
  FSFieldFlagChoiceCommitOnSelChange = 0x400
};

@interface FSField : FSBase
@property (nonatomic, getter=getFlags) unsigned int flags;
@property (nonatomic, copy, getter=getDefaultValue) NSString * defaultValue;
@property (nonatomic, copy, getter=getValue) NSString * value;
@property (nonatomic, getter=getAlignment) FSAlignment alignment;
@property (nonatomic, copy, getter=getAlternateName) NSString * alternateName;
@property (nonatomic, copy, getter=getDefaultAppearance) FSDefaultAppearance* defaultAppearance;
@property (nonatomic, copy, getter=getMappingName) NSString * mappingName;
@property (nonatomic, getter=getMaxLength) int maxLength;
@property (nonatomic, copy, getter=getOptions) FSChoiceOptionArray* options;
@property (nonatomic, getter=getTopVisibleIndex) int topVisibleIndex;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document field_dict: (FSPDFDictionary*)field_dict;
-(id)initWithField: (FSField*)field;
-(BOOL)isEmpty;
-(FSFieldType)getType;
-(NSString *)getName;
-(int)getControlCount;
-(FSControl*)getControl: (int)index;
-(BOOL)reset;
-(FSPDFDictionary*)getDict;
-(FSPDFObject*)getValueObj;
-(FSPDFObject*)getDefaultValueObj;
-(FSPDFObject*)getInheritedAttribute: (NSString *)attribute_name;

-(void)dealloc;

@end

@interface FSForm : FSBase
@property (nonatomic, getter=getAlignment) FSAlignment alignment;
@property (nonatomic, copy, getter=getDefaultAppearance) FSDefaultAppearance* defaultAppearance;
@property (nonatomic, copy, getter=getFieldsInCalculationOrder) FSFieldArray* fieldsInCalculationOrder;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document;
-(id)initWithOther: (FSForm*)other;
-(BOOL)isEmpty;
-(BOOL)needConstructAppearances;
-(void)setConstructAppearances: (BOOL)need_construct;
-(FSControl*)getControlAtDevicePoint: (FSPDFPage*)page point: (FSPointF*)point tolerance: (float)tolerance type: (FSFieldType)type matrix: (FSMatrix2D*)matrix;
-(FSControl*)getControlAtPoint: (FSPDFPage*)page point: (FSPointF*)point tolerance: (float)tolerance type: (FSFieldType)type;
-(FSPDFDoc*)getDocument;
-(BOOL)validateFieldName: (FSFieldType)type field_name: (NSString *)field_name;
-(BOOL)renameField: (FSField*)field new_field_name: (NSString *)new_field_name;
-(FSControl*)addControl: (FSPDFPage*)page field_name: (NSString *)field_name field_type: (FSFieldType)field_type rect: (FSRectF*)rect;
-(BOOL)moveControl: (FSControl*)control field_name: (NSString *)field_name;
-(void)removeField: (FSField*)field;
-(void)removeControl: (FSControl*)control;
-(int)getFieldCount: (NSString *)filter;
-(FSField*)getField: (int)index filter: (NSString *)filter;
-(int)getControlCount: (FSPDFPage*)page;
-(FSControl*)getControl: (FSPDFPage*)page index: (int)index;
-(FSFiller*)getFormFiller;
-(BOOL)reset;
-(BOOL)exportToXML: (NSString *)file_path;
-(BOOL)importFromXML: (NSString *)file_path;
-(BOOL)exportToCSV: (NSString *)csv_file_path pdf_file_name: (NSString *)pdf_file_name is_append: (BOOL)is_append;
-(BOOL)exportToHTML: (NSString *)html_file_path field_array: (FSFieldArray*)field_array is_include: (BOOL)is_include;
-(BOOL)exportToTXT: (NSString *)txt_file_path field_array: (FSFieldArray*)field_array is_include: (BOOL)is_include;
-(FSPDFDictionary*)getDict;
-(void)fixPageFields: (int)page_index;
-(void)reload;

-(void)dealloc;

@end

@interface FSControl : FSBase
@property (nonatomic, copy, getter=getExportValue) NSString * exportValue;
@property (nonatomic, copy, getter=getDefaultAppearance) FSDefaultAppearance* defaultAppearance;
@property (nonatomic, getter=getAlignment) FSAlignment alignment;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSControl*)other;
-(BOOL)isEmpty;
-(FSField*)getField;
-(FSPDFDictionary*)getWidgetDict;
-(FSWidget*)getWidget;
-(int)getIndex;
-(BOOL)isChecked;
-(void)setChecked: (BOOL)checked_status;
-(BOOL)isDefaultChecked;
-(void)setDefaultChecked: (BOOL)checked_status;

-(void)dealloc;

@end

typedef NS_ENUM(NSUInteger, FSSignatureStates) {
  FSSignatureStateUnknown = 0x80000000,
  FSSignatureStateNoSignData = 0x00000200,
  FSSignatureStateUnsigned = 0x00000001,
  FSSignatureStateSigned = 0x00000002,
  FSSignatureStateVerifyValid = 0x00000004,
  FSSignatureStateVerifyInvalid = 0x00000008,
  FSSignatureStateVerifyErrorData = 0x00000010,
  FSSignatureStateVerifyNoSupportWay = 0x00000020,
  FSSignatureStateVerifyErrorByteRange = 0x00000040,
  FSSignatureStateVerifyChange = 0x00000080,
  FSSignatureStateVerifyIncredible = 0x00000100,
  FSSignatureStateVerifyNoChange = 0x00000400,
  FSSignatureStateVerifyIssueValid = 0x00001000,
  FSSignatureStateVerifyIssueUnknown = 0x00002000,
  FSSignatureStateVerifyIssueRevoke = 0x00004000,
  FSSignatureStateVerifyIssueExpire = 0x00008000,
  FSSignatureStateVerifyIssueUncheck = 0x00010000,
  FSSignatureStateVerifyIssueCurrent = 0x00020000,
  FSSignatureStateVerifyTimestampNone = 0x00040000,
  FSSignatureStateVerifyTimestampDoc = 0x00080000,
  FSSignatureStateVerifyTimestampValid = 0x00100000,
  FSSignatureStateVerifyTimestampInvalid = 0x00200000,
  FSSignatureStateVerifyTimestampExpire = 0x00400000,
  FSSignatureStateVerifyTimestampIssueUnknown = 0x00800000,
  FSSignatureStateVerifyTimestampIssueValid = 0x01000000,
  FSSignatureStateVerifyTimestampTimeBefore = 0x02000000,
  FSSignatureStateCertCannotGetVRI = 0x04000000,
  FSSignatureStateVerifyChangeLegal = 0x08000000,
  FSSignatureStateVerifyChangeIllegal = 0x10000000
};

typedef NS_ENUM(NSInteger, FSSignatureAPFlags) {
  FSSignatureAPFlagFoxitFlag = 0x0001,
  FSSignatureAPFlagLabel = 0x0002,
  FSSignatureAPFlagReason = 0x0004,
  FSSignatureAPFlagSigningTime = 0x0008,
  FSSignatureAPFlagDN = 0x0010,
  FSSignatureAPFlagLocation = 0x0020,
  FSSignatureAPFlagSigner = 0x0040,
  FSSignatureAPFlagBitmap = 0x0080,
  FSSignatureAPFlagText = 0x0100
};

typedef NS_ENUM(NSInteger, FSSignatureKeyName) {
  FSSignatureKeyNameSigner = 0,
  FSSignatureKeyNameLocation = 1,
  FSSignatureKeyNameReason = 2,
  FSSignatureKeyNameContactInfo = 3,
  FSSignatureKeyNameDN = 4,
  FSSignatureKeyNameText = 5
};

typedef NS_ENUM(NSInteger, FSSignatureDigestAlgorithm) {
  FSSignatureDigestSHA1 = 0,
  FSSignatureDigestSHA256 = 1,
  FSSignatureDigestSHA384 = 2,
  FSSignatureDigestSHA512 = 3
};

typedef NS_ENUM(NSInteger, FSSignatureSignatureType) {
  FSSignatureSignatureTypeOrdinary = 0,
  FSSignatureSignatureTypeTimeStamp = 3
};

typedef NS_ENUM(NSInteger, FSSignaturePAdESLevel) {
  FSSignaturePAdESLevelNotPAdES = 0,
  FSSignaturePAdESLevelNone = 1,
  FSSignaturePAdESLevelBB = 2,
  FSSignaturePAdESLevelBT = 3,
  FSSignaturePAdESLevelBLT = 4,
  FSSignaturePAdESLevelBLTA = 5
};

typedef NS_ENUM(NSInteger, FSSignatureDocPermission) {
  FSSignatureDocPermUnrestricted = 0,
  FSSignatureDocPermNoChangesAllowed = 1,
  FSSignatureDocPermFillingFormAndSigning = 2,
  FSSignatureDocPermFillingFormSigningAndAnnotating = 3
};

typedef NS_ENUM(NSInteger, FSSignatureFieldMDPAction) {
  FSSignatureFieldMDPActionNone = 0,
  FSSignatureFieldMDPActionAll = 1,
  FSSignatureFieldMDPActionInclude = 2,
  FSSignatureFieldMDPActionExclude = 3
};

typedef NS_ENUM(NSInteger, FSSignatureLabelName) {
  FSSignatureLabelNameSigner = 0,
  FSSignatureLabelNameLocation = 1,
  FSSignatureLabelNameReason = 2,
  FSSignatureLabelNameSignTime = 3,
  FSSignatureLabelNameDN = 4
};

@interface FSSignature : FSField
@property (nonatomic, getter=getDocPermission) FSSignatureDocPermission docPermission;
@property (nonatomic, getter=getAppearanceFlags) unsigned int appearanceFlags;
@property (nonatomic, copy, getter=getSignTime) FSDateTime* signTime;
@property (nonatomic, copy, getter=getFilter) NSString * filter;
@property (nonatomic, copy, getter=getSubFilter) NSString * subFilter;
@property (nonatomic, copy, getter=getBitmap) FSBitmap* bitmap;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithField: (FSField*)field;
-(id)initWithDocument: (FSPDFDoc*)document sig_field_dict: (FSPDFDictionary*)sig_field_dict;
-(BOOL)isEmpty;
-(BOOL)isSigned;
-(void)setFieldMDPActionFields: (FSSignatureFieldMDPAction)action field_array: (NSArray<NSString *> *)field_array;
-(FSSignatureFieldMDPAction)getFieldMDPAction;
-(NSArray<NSString *> *)getFieldMDPActionFields;
-(FSProgressive*)startSign: (NSString *)cert_path cert_password: (NSString *)cert_password digest_algorithm: (FSSignatureDigestAlgorithm)digest_algorithm save_path: (NSString *)save_path client_data: (NSData *)client_data pause: (id<FSPauseCallback>)pause;
-(FSProgressive*)startSignByCertStream: (id<FSStreamCallback>)cert_file_stream cert_password: (NSString *)cert_password digest_algorithm: (FSSignatureDigestAlgorithm)digest_algorithm save_path: (NSString *)save_path client_data: (NSData *)client_data pause: (id<FSPauseCallback>)pause;
-(FSProgressive*)startSignToStream: (NSString *)cert_path cert_password: (NSString *)cert_password digest_algorithm: (FSSignatureDigestAlgorithm)digest_algorithm stream_callback: (id<FSStreamCallback>)stream_callback client_data: (NSData *)client_data pause: (id<FSPauseCallback>)pause;
-(FSProgressive*)startSignToStreamByCertStream: (id<FSStreamCallback>)cert_file_stream cert_password: (NSString *)cert_password digest_algorithm: (FSSignatureDigestAlgorithm)digest_algorithm stream_callback: (id<FSStreamCallback>)stream_callback client_data: (NSData *)client_data pause: (id<FSPauseCallback>)pause;
-(FSProgressive*)startVerify: (NSData *)client_data pause: (id<FSPauseCallback>)pause;
-(NSString *)getCertificateInfo: (NSString *)key;
-(unsigned int)getState;
-(BOOL)clearSignedData;
-(FSPDFDoc*)getDocument;
-(FSPDFDoc*)getSignedVersionDocument: (NSString *)file_path;
-(void)setAppearanceContent: (NSString *)appearance_content;
-(NSString *)getKeyValue: (FSSignatureKeyName)key;
-(void)setKeyValue: (FSSignatureKeyName)key value: (NSString *)value;
-(void)setKeyLabel: (FSSignatureLabelName)label_name label_value: (NSString *)label_value;
-(NSString *)getKeyLabel: (FSSignatureLabelName)label_name;
-(void)setImage: (FSImage*)image frame_index: (int)frame_index;
-(FSPDFDictionary*)getSignatureDict;
-(void)setDefaultContentsLength: (unsigned int)default_length;
-(int)getCertCount;
-(NSString *)getCert: (int)index;
-(void)setCertChain: (NSArray<NSString *> *)cert_chain;
-(FSSignatureSignatureType)getSignatureType;
-(BOOL)isTimeStamp;
-(FSSignaturePAdESLevel)getPAdESLevel;
-(FSInt32Array*)getByteRangeArray;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSSignatureCallbackCertValidity) {
  FSSignatureCallbackCertValid = 0,
  FSSignatureCallbackCertExpired = 1,
  FSSignatureCallbackCertUnsupportType = 2,
  FSSignatureCallbackCertDataError = 3,
  FSSignatureCallbackCertInvalidPassword = 4,
  FSSignatureCallbackCertInvalidPath = 5,
  FSSignatureCallbackCertNotSet = 6,
  FSSignatureCallbackCertCannotGetPrivateKey = 7
};



@interface FSTimeStampServerMgr : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSErrorCode)initialize;
+(void)destroy;
+(int)getServerCount;
+(FSTimeStampServer*)getServer: (int)index;
+(int)getServerIndex: (FSTimeStampServer*)server;
+(FSTimeStampServer*)getDefaultServer;
+(void)setDefaultServerWithIndex: (int)index;
+(void)setDefaultServer: (FSTimeStampServer*)server;
+(FSTimeStampServer*)addServer: (NSString *)server_name server_url: (NSString *)server_url user_name: (NSString *)user_name password: (NSString *)password;
+(void)removeServerWithIndex: (int)index;
+(void)removeServer: (FSTimeStampServer*)server;
-(id)init;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSTimeStampServerSendRequestResult) {
  FSTimeStampServerSendResultSuccess = 0,
  FSTimeStampServerSendResultFailToCreateSocket = 1,
  FSTimeStampServerSendResultFailToConnect = 2,
  FSTimeStampServerSendResultFailToSendData = 3,
  FSTimeStampServerSendResultFailToReceiveData = 4,
  FSTimeStampServerSendResultFailToRequest = 5,
  FSTimeStampServerSendResultFailToGetData = 6,
  FSTimeStampServerSendResultOutOfMemory = 7
};

@interface FSTimeStampServer : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSTimeStampServer*)other;
-(BOOL)isEmpty;
-(FSTimeStampServerSendRequestResult)sendTimeStampRequest: (NSString *)request;
-(NSString *)getTimeStampMessage;

-(void)dealloc;

@end



typedef NS_ENUM(NSInteger, FSResponseResponseType) {
  FSResponseTypeNone = 0,
  FSResponseTypeCRL = 1,
  FSResponseTypeOCSP = 2
};

@interface FSResponse : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, getter=getType) FSResponseResponseType type;
@property (nonatomic, copy, getter=getResponse_data) NSString * response_data;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithType: (FSResponseResponseType)type response_data: (NSString *)response_data;
-(id)initWithOther: (FSResponse*)other;
-(void)set: (FSResponseResponseType)type response_data: (NSString *)response_data;
-(void)dealloc;

@end

@interface FSTimeRange : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getStart_time) FSDateTime* start_time;
@property (nonatomic, copy, getter=getEnd_time) FSDateTime* end_time;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithStart_time: (FSDateTime*)start_time end_time: (FSDateTime*)end_time;
-(id)initWithOther: (FSTimeRange*)other;
-(void)set: (FSDateTime*)start_time end_time: (FSDateTime*)end_time;
-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSCertVerifyResultCertStatus) {
  FSCertVerifyResultCertStatusValid = 0,
  FSCertVerifyResultCertStatusRevoked = 1,
  FSCertVerifyResultCertStatusExpired = 2,
  FSCertVerifyResultCertStatusUnknown = 3
};

typedef NS_ENUM(NSInteger, FSCertVerifyResultRevocationReason) {
  FSCertVerifyResultReasonNoStatus = -1,
  FSCertVerifyResultReasonUnspecified = 0,
  FSCertVerifyResultReasonKeyCompromise = 1,
  FSCertVerifyResultReasonCACompromise = 2,
  FSCertVerifyResultReasonAffiliationChanged = 3,
  FSCertVerifyResultReasonSuperseded = 4,
  FSCertVerifyResultReasonCessationOfOperation = 5,
  FSCertVerifyResultReasonCertificateHold = 6,
  FSCertVerifyResultReasonRemoveFromCRL = 7,
  FSCertVerifyResultReasonPrivilegeWithDrawn = 8,
  FSCertVerifyResultReasonAACompromise = 9
};

typedef NS_ENUM(NSInteger, FSCertVerifyResultResponseInfoLocation) {
  FSCertVerifyResultLocationNotSet = 0,
  FSCertVerifyResultLocationDSS = 1,
  FSCertVerifyResultLocationSignature = 2,
  FSCertVerifyResultLocationOnline = 3
};

@interface FSCertVerifyResult : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getCert) NSString * cert;
@property (nonatomic, getter=getIs_ca) BOOL is_ca;
@property (nonatomic, getter=getIs_trusted) BOOL is_trusted;
@property (nonatomic, copy, getter=getResponse) FSResponse* response;
@property (nonatomic, copy, getter=getResponse_effect_time_range) FSTimeRange* response_effect_time_range;
@property (nonatomic, copy, getter=getRevoke_time) FSDateTime* revoke_time;
@property (nonatomic, getter=getCert_status) FSCertVerifyResultCertStatus cert_status;
@property (nonatomic, getter=getReason) FSCertVerifyResultRevocationReason reason;
@property (nonatomic, copy, getter=getCert_check_time) FSDateTime* cert_check_time;
@property (nonatomic, getter=getExist_signature_vri_creation_time) BOOL exist_signature_vri_creation_time;
@property (nonatomic, copy, getter=getSignature_vri_creation_time) FSDateTime* signature_vri_creation_time;
@property (nonatomic, getter=getExist_response_signature_vri_creation_time) BOOL exist_response_signature_vri_creation_time;
@property (nonatomic, copy, getter=getResponse_signature_vri_creation_time) FSDateTime* response_signature_vri_creation_time;
@property (nonatomic, getter=getResponse_info_location) FSCertVerifyResultResponseInfoLocation response_info_location;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithCert: (NSString *)cert is_ca: (BOOL)is_ca is_trusted: (BOOL)is_trusted response: (FSResponse*)response response_effect_time_range: (FSTimeRange*)response_effect_time_range revoke_time: (FSDateTime*)revoke_time cert_status: (FSCertVerifyResultCertStatus)cert_status reason: (FSCertVerifyResultRevocationReason)reason cert_check_time: (FSDateTime*)cert_check_time exist_signature_vri_creation_time: (BOOL)exist_signature_vri_creation_time signature_vri_creation_time: (FSDateTime*)signature_vri_creation_time exist_response_signature_vri_creation_time: (BOOL)exist_response_signature_vri_creation_time response_signature_vri_creation_time: (FSDateTime*)response_signature_vri_creation_time response_info_location: (FSCertVerifyResultResponseInfoLocation)response_info_location;
-(id)initWithOther: (FSCertVerifyResult*)other;
-(void)set: (NSString *)cert is_ca: (BOOL)is_ca is_trusted: (BOOL)is_trusted response: (FSResponse*)response response_effect_time_range: (FSTimeRange*)response_effect_time_range revoke_time: (FSDateTime*)revoke_time cert_status: (FSCertVerifyResultCertStatus)cert_status reason: (FSCertVerifyResultRevocationReason)reason cert_check_time: (FSDateTime*)cert_check_time exist_signature_vri_creation_time: (BOOL)exist_signature_vri_creation_time signature_vri_creation_time: (FSDateTime*)signature_vri_creation_time exist_response_signature_vri_creation_time: (BOOL)exist_response_signature_vri_creation_time response_signature_vri_creation_time: (FSDateTime*)response_signature_vri_creation_time response_info_location: (FSCertVerifyResultResponseInfoLocation)response_info_location;
-(void)dealloc;

@end

@interface FSCertVerifyResultArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSCertVerifyResultArray*)other;
-(unsigned long)getSize;
-(FSCertVerifyResult*)getAt: (unsigned long)index;
-(void)add: (FSCertVerifyResult*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSCertVerifyResult*)element;
-(void)removeAll;

-(void)dealloc;

@end

@interface FSCertIssuerPair : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getCert) NSString * cert;
@property (nonatomic, copy, getter=getIssuer) NSString * issuer;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithCert: (NSString *)cert issuer: (NSString *)issuer;
-(id)initWithOther: (FSCertIssuerPair*)other;
-(void)set: (NSString *)cert issuer: (NSString *)issuer;
-(void)dealloc;

@end

@interface FSRevocationArrayInfo : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
@property (nonatomic, copy, getter=getOcsp_array) NSArray<NSData *> * ocsp_array;
@property (nonatomic, copy, getter=getCrl_array) NSArray<NSData *> * crl_array;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOcsp_array: (NSArray<NSData *> *)ocsp_array crl_array: (NSArray<NSData *> *)crl_array;
-(id)initWithOther: (FSRevocationArrayInfo*)other;
-(void)set: (NSArray<NSData *> *)ocsp_array crl_array: (NSArray<NSData *> *)crl_array;
-(void)dealloc;

@end





@interface FSSignatureVerifyResultArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSSignatureVerifyResultArray*)other;
-(unsigned long)getSize;
-(FSSignatureVerifyResult*)getAt: (unsigned long)index;
-(void)add: (FSSignatureVerifyResult*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSSignatureVerifyResult*)element;
-(void)removeAll;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSLTVVerifierTimeType) {
  FSLTVVerifierSignatureCreationTime = 0,
  FSLTVVerifierSignatureTSTTime = 1,
  FSLTVVerifierCurrentTime = 2,
  FSLTVVerifierVRICreationTime = 3
};

typedef NS_ENUM(NSInteger, FSLTVVerifierVerifyMode) {
  FSLTVVerifierVerifyModeAcrobat = 1
};

@interface FSLTVVerifier : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document is_verify_signature: (BOOL)is_verify_signature use_expired_tst: (BOOL)use_expired_tst ignore_doc_info: (BOOL)ignore_doc_info time_type: (FSLTVVerifierTimeType)time_type;
-(id)initWithOther: (FSLTVVerifier*)other;
-(BOOL)isEmpty;
-(void)setRevocationCallback: (id<FSRevocationCallback>)callback;
-(void)setVerifyMode: (FSLTVVerifierVerifyMode)mode;
-(void)setTrustedCertStoreCallback: (id<FSTrustedCertStoreCallback>)callback;
-(FSSignatureVerifyResultArray*)verify;
-(FSSignatureVerifyResultArray*)verifySignature: (FSSignature*)signature;
-(void)addDSS: (FSSignatureVerifyResult*)signature_verify_result;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSSignatureVerifyResultLTVState) {
  FSSignatureVerifyResultLTVStateInactive = 0,
  FSSignatureVerifyResultLTVStateEnable = 1,
  FSSignatureVerifyResultLTVStateNotEnable = 2
};

@interface FSSignatureVerifyResult : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSSignatureVerifyResult*)other;
-(BOOL)isEmpty;
-(NSString *)getSignatureName;
-(NSString *)getSignatureHashValue;
-(unsigned int)getSignatureState;
-(FSDateTime*)getSignatureCheckTime;
-(FSLTVVerifierTimeType)getSignatureCheckTimeType;
-(FSSignatureVerifyResultLTVState)getLTVState;
-(FSCertVerifyResultArray*)getCertificateVerifyResults;
-(FSSignatureVerifyResultArray*)getOCSPSigantureVerifyResults;
-(FSSignatureVerifyResult*)getTSTSignatureVerifyResult;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSPortfolioNodeType) {
  FSPortfolioNodeTypeUnknown = 0,
  FSPortfolioNodeTypeFolder = 1,
  FSPortfolioNodeTypeFile = 2
};

@interface FSPortfolioNode : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSPortfolioNode*)other;
-(BOOL)isEmpty;
-(FSPortfolioNodeType)getNodeType;

-(void)dealloc;

@end

@interface FSPortfolioNodeArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSPortfolioNodeArray*)other;
-(unsigned long)getSize;
-(FSPortfolioNode*)getAt: (unsigned long)index;
-(void)add: (FSPortfolioNode*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSPortfolioNode*)element;
-(void)removeAll;

-(void)dealloc;

@end

@interface FSPortfolioFolderNode : FSPortfolioNode
@property (nonatomic, copy, getter=getDescription) NSString * description;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSPortfolioNode*)other;
-(BOOL)isRoot;
-(NSString *)getName;
-(FSPortfolioFileNode*)addFile: (NSString *)file_path;
-(FSPortfolioFileNode*)addFileWithStreamCallback: (id<FSStreamCallback>)file_stream file_name: (NSString *)file_name;
-(FSPortfolioFileNode*)addPDFDoc: (FSPDFDoc*)pdf_doc file_name: (NSString *)file_name;
-(FSPortfolioFolderNode*)addSubFolder: (NSString *)folder_name;
-(void)removeSubNode: (FSPortfolioNode*)sub_node;
-(FSPortfolioNodeArray*)getSortedSubNodes;
-(FSDateTime*)getModifiedDateTime;
-(FSDateTime*)getCreationDateTime;

-(void)dealloc;

@end

@interface FSPortfolioFileNode : FSPortfolioNode
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithOther: (FSPortfolioNode*)other;
-(FSFileSpec*)getFileSpec;
-(NSString *)getKeyName;

-(void)dealloc;

@end

@interface FSSchemaField : FSBase
@property (nonatomic, copy, getter=getKeyName) NSString * keyName;
@property (nonatomic, copy, getter=getSubtypeName) NSString * subtypeName;
@property (nonatomic, copy, getter=getDisplayName) NSString * displayName;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSSchemaField*)other;
-(BOOL)isEmpty;
-(BOOL)isVisible;
-(void)setVisibility: (BOOL)is_visible;

-(void)dealloc;

@end

@interface FSSchemaFieldArray : NSObject
{
	void *swigCPtr;
	BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSSchemaFieldArray*)other;
-(unsigned long)getSize;
-(FSSchemaField*)getAt: (unsigned long)index;
-(void)add: (FSSchemaField*)element;
-(void)removeAt: (unsigned long)index;
-(void)insertAt: (unsigned long)index element: (FSSchemaField*)element;
-(void)removeAll;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSPortfolioInitialViewMode) {
  FSPortfolioInitialViewUnknownMode = 0,
  FSPortfolioInitialViewDetailMode = 1,
  FSPortfolioInitialViewTileMode = 2,
  FSPortfolioInitialViewHidden = 3
};

@interface FSPortfolio : FSBase
@property (nonatomic, getter=getInitialViewMode) FSPortfolioInitialViewMode initialViewMode;
@property (nonatomic, copy, getter=getSortingFieldKeyName) NSString * sortingFieldKeyName;
@property (nonatomic, copy, getter=getInitialFileSpecKeyName) NSString * initialFileSpecKeyName;
@property (nonatomic, copy, getter=getSchemaFields) FSSchemaFieldArray* schemaFields;
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
+(FSPortfolio*)createPortfolio;
+(FSPortfolio*)createPortfolioWithPDFDoc: (FSPDFDoc*)portfolio_pdf_doc;
-(id)initWithOther: (FSPortfolio*)other;
-(BOOL)isEmpty;
-(FSPDFDoc*)getPortfolioPDFDoc;
-(FSPortfolioNode*)getRootNode;
-(BOOL)isSortedInAscending;
-(void)setSortingOrder: (BOOL)use_ascending_order;

-(void)dealloc;

@end

typedef NS_ENUM(NSInteger, FSAnnotationSummaryCallbackAnnotationSummaryStringID) {
  FSAnnotationSummaryCallbackAnnotationSummaryStringIDAuthor = 0,
  FSAnnotationSummaryCallbackAnnotationSummaryStringIDDate = 1,
  FSAnnotationSummaryCallbackAnnotationSummaryStringIDPage = 2,
  FSAnnotationSummaryCallbackAnnotationSummaryStringIDType = 3,
  FSAnnotationSummaryCallbackAnnotationSummaryStringIDDocumentTitle = 4,
  FSAnnotationSummaryCallbackAnnotationSummaryStringIDPageTitle = 5,
  FSAnnotationSummaryCallbackAnnotationSummaryStringIDNoAnnotations = 6,
  FSAnnotationSummaryCallbackAnnotationSummaryStringIDNumber = 7,
  FSAnnotationSummaryCallbackAnnotationSummaryStringIDSubject = 8
};



typedef NS_ENUM(NSInteger, FSAnnotationSummarySettingsSummaryLayout) {
  FSAnnotationSummarySettingsSummaryLayoutSeparatePagesWithLine = 0,
  FSAnnotationSummarySettingsSummaryLayoutSinglePageWithLine = 1,
  FSAnnotationSummarySettingsSummaryLayoutAnnotationOnly = 2,
  FSAnnotationSummarySettingsSummaryLayoutSeparatePagesWithSequenceNumber = 3,
  FSAnnotationSummarySettingsSummaryLayoutSinglePageWithSequenceNumber = 4
};

typedef NS_ENUM(NSInteger, FSAnnotationSummarySettingsSortType) {
  FSAnnotationSummarySettingsTypeSortByAuthor = 0,
  FSAnnotationSummarySettingsTypeSortByDate = 1,
  FSAnnotationSummarySettingsTypeSortByPage = 2,
  FSAnnotationSummarySettingsTypeSortByAnnotationType = 3
};

typedef NS_ENUM(NSInteger, FSAnnotationSummarySettingsFontSizeType) {
  FSAnnotationSummarySettingsFontSizeSmall = 0,
  FSAnnotationSummarySettingsFontSizeMedium = 1,
  FSAnnotationSummarySettingsFontSizeLarge = 2
};

@interface FSAnnotationSummarySettings : FSBase
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithOther: (FSAnnotationSummarySettings*)other;
-(BOOL)isEmpty;
-(void)setSummaryLayout: (FSAnnotationSummarySettingsSummaryLayout)type;
-(void)setSortType: (FSAnnotationSummarySettingsSortType)type;
-(void)setFontSize: (FSAnnotationSummarySettingsFontSizeType)type;
-(void)setAnnotType: (FSAnnotType)type use_all: (BOOL)use_all;
-(void)setFileTitle: (NSString *)title;
-(void)setPageRect: (FSRectF*)rect;
-(void)setPageMargin: (FSRectF*)margin;
-(void)setStartPage: (int)page_index;
-(void)setEndPage: (int)page_index;
-(void)enableOutputNoAnnotationPage: (BOOL)enable;
-(void)setConnectorLineColor: (unsigned int)color;
-(void)setConnectorLineOpacity: (float)opacity;
-(void)setAnnotThumbnail: (FSAnnotType)type thumbnail: (FSBitmap*)thumbnail;

-(void)dealloc;

@end

@interface FSAnnotationSummary : FSBase
-(id)init NS_UNAVAILABLE;
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)initWithDocument: (FSPDFDoc*)document;
-(id)initWithOther: (FSAnnotationSummary*)other;
-(BOOL)isEmpty;
-(void)setCallback: (id<FSAnnotationSummaryCallback>)callback;
-(FSProgressive*)startSummarize: (NSString *)dest_file_path settings: (FSAnnotationSummarySettings*)settings pause: (id<FSPauseCallback>)pause;

-(void)dealloc;

@end



/** @brief Protocol FSPauseCallback for progressive control. */
@protocol FSPauseCallback <NSObject>
@required
/** @brief Check whether need to pause now. */
-(BOOL)needPauseNow;
@end

/** @brief file reading interface. */
@protocol FSFileReaderCallback <NSObject>
@required
/**
 * @brief    Read a data block from the file
 * @param[in] offset        Byte offset from beginning of the file
 * @param[in] size          Number of bytes for the block.
 * @return a buffer receiving read data.
 */
-(NSData *)readBlock: (unsigned long long)offset size: (unsigned long long)size;
/**
 * @brief    Get total size of the file
 * @return File size, in bytes. Implementation can return 0 for any error.
 */
-(unsigned long long)getSize;
@end

/**
 * This class represents a callback object to do file writing.
 * All the pure virtual functions in this class are used as callback functions and should be implemented by user
 * to do file writing in a customized way.
 */
@protocol FSFileWriterCallback <NSObject>
@required
/**
 * @brief Get total size of the file.
 *
 * @return File size, in bytes. Implementation can return 0 for any error.
 */
-(unsigned long long)getSize;
/**
 * @brief    Write a block data.
 *
 * @param[in] data            The block data.
 * @param[in] offset        Byte offset from beginning of the file
 *
 * @return <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)writeBlock:(NSData*)data offset:(unsigned long long)offset;
/**
 * @brief    Flush internal buffer of the file
 *
 * @return <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)flush;
@end

/** @brief File stream interface, reading & writing. */
@protocol FSStreamCallback <NSObject>
@required
/**
 * @brief Get the current stream size, in bytes.
 *
 * @return Current stream size, in bytes.
 */
-(unsigned long long)getSize;
/**
 * @brief Determine whether reach the end of stream.
 *
 * @return <b>true</b> means reach the end of stream, and <b>false</b> means not yet.
 */
-(BOOL)IsEOF;
/**
 * @brief Get the current reading position in stream.
 *
 * @return Current reading position.
 */
-(unsigned long long)GetPosition;
/**
 * @brief    Read a data block from the file
 * @param[in] offset        Byte offset from beginning of the file
 * @param[in] size          Number of bytes for the block.
 * @return a buffer receiving read data.
 */
-(NSData *)readBlock: (unsigned long long)offset size: (unsigned long long)size;
/**
 * @brief Write a block data to the end of current stream.
 *
 * @param[in] buffer  Pointer to the data block.
 * @param[in] size    The length in bytes of the buffer.
 *
 * @return <b>true</b> means success, and <b>false</b> means failure.
 */
-(BOOL)writeBlock:(NSData*)data offset:(unsigned long long)offset;
/**
 * @brief Flush internal buffer.
 *
 * @return <b>true</b> means success, and <b>false</b> means failure.
 */
-(BOOL)flush;
@end

/**
 * This class represents a callback object for performing PDF actions.
 * All the pure virtual functions in this class are used as callback functions and should be implemented by user,
 * to perform PDF actions, such as javascript actions.
 */
@protocol FSActionCallback <NSObject>
@required
/**
 * @brief A callback function used to receive current page index.
 *
 * @details This callback function is optional, so it can be implemented to do nothing and
 *          just return a useless value.
 *
 * @param[in] pdfDoc  A PDF document object. It would be valid.
 *
 * @return Current page index. The value should be stared from 0 and less than page count of the specified document.
 */
-(int)getCurrentPage:(FSPDFDoc*)pdfDoc;
/**
 * @brief A callback function used to set the current page by index.
 *
 * @details This callback function is optional, so it can be implemented to do nothing.
 *
 * @param[in] pdfDoc    A PDF document object. It would be valid.
 * @param[in] pageIndex  A page index which is used to change current page.
 *                        The index would start from 0 and less than page count of the specified document.
 *
 * @return None.
 */
-(void)setCurrentPage:(FSPDFDoc*)pdfDoc pageIndex:(int)pageIndex;
/**
 * @brief A callback function used to receive current displaying rotation of a page on PDF viewer.
 *
 * @details This callback function is optional, so it can be implemented to do nothing and
 *          just return a useless value.
 *
 * @param[in] pdfDoc    A PDF document object. It would be valid.
 * @param[in] pageIndex  A page index, used to specify which page's rotation is to be retrieved.
 *                        The index would start from 0 and less than page count of the specified document.
 *
 * @return The rotation of specified page. Please refer to values starting from @link FSRotation0 @endlink
 *         and this should be one of these values.
 */
-(FSRotation)getPageRotation:(FSPDFDoc*)pdfDoc pageIndex:(int)pageIndex;
/**
 * @brief A callback function used to set the rotation value of a page on PDF viewer.
 *
 * @details This callback function is optional, so it can be implemented to do nothing.
 *
 * @param[in] pdfDoc    A PDF document object. It would be valid.
 * @param[in] pageIndex  A page index, used to specify which page's rotation is to be changed.
 *                        The index would start from 0 and less than page count of the specified document.
 * @param[in] rotation    New rotation value. Please refer to values starting from @link FSRotation0 @endlink
 *                        and this would be one of these values except @link FSRotationUnknown @endlink.
 *
 * @return <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setPageRotation:(FSPDFDoc*)pdfDoc pageIndex:(int)pageIndex rotation:(FSRotation)rotation;
/**
 * @brief A callback function used to pop up a dialog to show warnings or hints.
 *
 * @details This callback function is optional, so it can be implemented to do nothing and
 *          just return a useless value.
 *
 * @param[in] msg    The message string to be displayed in the dialog.
 * @param[in] title  The title of the dialog.
 * @param[in] type   Type of button group. It would be one of following values:
 *                   <ul>
 *                   <li>0: OK;(default value.)</li>
 *                   <li>1: OK, Cancel;</li>
 *                   <li>2: Yes, NO; </li>
 *                   <li>3: Yes, NO, Cancel.</li>
 *                   </ul>
 * @param[in] icon   Icon type. It would be one of following values:
 *                   <ul>
 *                   <li>0: Error;(default value.)</li>
 *                   <li>1: Warning;</li>
 *                   <li>2: Question;</li>
 *                   <li>3: Status.</li>
 *                   </ul>
 *
 * @return The return value should be one of following values:<br>
 *         <ul>
 *         <li>1: OK;</li>
 *         <li>2: Cancel; </li>
 *         <li>3: NO;</li>
 *         <li>4: Yes;</li>
 *         </ul>
 */
-(int)alert:(NSString*)msg title:(NSString*)title type:(int)type icon:(int)icon;
/**
 * @brief A callback function used to get identity properties of current user.
 *
 * @details This callback function is optional, so it can be implemented to do nothing and
 *          just return a useless value.
 *
 * @return An identity properties object that specifies the identity properties of current user.
 */
-(FSIdentityProperties*)getIdentityProperties;
/**
 * @brief A callback function to set the change mark which indicates whether the content of document is
 *        changed or not.
 *
 * @details This callback function is optional, so it can be implemented to do nothing and
 *          just return a useless value.
 *
 * @param[in] document     A PDF document object. It would be valid.
 * @param[in] change_mark  A boolean value that indicates whether the content of document is changed or not.
 *
 * @return <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setDocChangeMark:(FSPDFDoc*)document change_mark:(BOOL)change_mark;
/**
 * @brief A callback function to receive the change mark which indicates whether the content of document is
 *        changed or not.
 *
 * @details This callback function is optional, so it can be implemented to do nothing and
 *          just return a useless value.
 *
 * @param[in] document  A PDF document object. It would be valid.
 *
 * @return <b>YES</b> means the PDF document is changed, while <b>NO</b> means not.
 */
-(BOOL)getDocChangeMark:(FSPDFDoc*)document;

/**
  * @brief A callback function to verify specified signature..
  *
  * @details This callback function will be triggered when a signature is to be verified by an action.
  *          If user does not want to verify the signature, just implement this function to do nothing and
  *          just return @link pdf::Signature::e_StateUnknown @endlink.
  *          User is recommended to use class @link pdf::LTVVerifier @endlink to verify if a signed signature is valid or not.
  *
  * @param[in] document       A PDF document object. It would be valid.
  * @param[in] signature     A PDF signature which is signed. This signature belongs to input paramter <i>document</i>.
  *
  * @return The signature verified state. Please refer to values starting from @link Signature::e_StateUnknown @endlink and
  *         this would be one or combination of them.
  */
-(unsigned int)verifySignature:(FSPDFDoc *)document signature:(FSSignature *)signature;

/**
 * @brief A callback function to show a file selection dialog.
 *
 * @details This callback function is optional, so it can be implemented to do nothing and
 *          just return a useless value.
 *
 * @param[in]  is_open_dialog  A boolean value to specify whether the dialog is for opening file or saving file.
 *                             </b>true</b> means the dialog should be used to open file, while <b>false</b> means
 *                             the dialog should be used to save file.
 * @param[in]  file_format     The file format string.
 * @param[in]  file_filter     The file filter string.
 *
 * @return The file path. It can be an empty string.
 */
- (NSString *)browseFile:(BOOL)is_open_dialog file_format:(NSString *)file_format file_filter:(NSString *)file_filter;
@end

/**
 * This class represents a callback object as customized annotation icon provider.
 * All the functions in this class are used as callback functions. Pure virtual functions should be implemented
 * by user and user can also choose to implement some or all the reset virtual functions when necessary.
 * Icon provider can only be used for note, file attachment, stamp annotations. <br>
 * Icon provider's ID and version are treated as the name of the icon provider, so please offer different
 * "ID + version" for different icon providers by callback functions
 * @link FSIconProviderCallback::getProviderID @endlink and @link FSIconProviderCallback::getProviderVersion @endlink.
 */
@protocol FSIconProviderCallback <NSObject>
@required
/**
 * @brief A callback function used to get provider ID.
 *
 * @details Icon provider's ID and version are treated as the name of the icon provider, so please offer different
 *          "ID + version" for different icon providers.
 *
 * @return The provider ID.
 */
-(NSString*)getProviderID;
/**
 * @brief A callback function used to get provider version.
 *
 * @details Icon provider's ID and version are treated as the name of the icon provider, so please offer different
 *          "ID + version" for different icon providers.
 *
 * @return Version string.
 */
-(NSString*)getProviderVersion;
/**
 * @brief A callback function used to check if current icon provider supports icon for a specified type.
 *
 * @param[in] annotType  The annotation type. It should be one of @link FSActionCallbackMailTypeMsg @endlink,
 *                        @link FSAnnotFileAttachment @endlink and @link FSAnnotStamp @endlink.
 * @param[in] iconName   Icon name of the annotation.
 *
 * @return <b>YES</b> means current icon provider supports the specified icon, while <b>NO</b> means not support.
 */
-(BOOL)hasIcon: (FSAnnotType)annotType iconName: (NSString*)iconName;
/**
 * @brief A callback function used to check if current icon provider supports to change color for a specified type.
 *
 * @param[in] annotType  The annotation type. It should be one of @link FSActionCallbackMailTypeMsg @endlink,
 *                        @link FSAnnotFileAttachment @endlink and @link FSAnnotStamp @endlink.
 * @param[in] iconName   Icon name of the annotation.
 *
 * @return <b>YES</b> means current icon provider supports to change color for a specified icon type,
 *         while <b>NO</b> means not support.
 */
-(BOOL)canChangeColor: (FSAnnotType)annotType iconName: (NSString*)iconName;
/**
 * @brief A callback function used to get the icon as PDF page contents for a specified type.
 *
 * @param[in] annotType  The annotation type. It should be one of @link FSActionCallbackMailTypeMsg @endlink,
 *                        @link FSAnnotFileAttachment @endlink and @link FSAnnotStamp @endlink.
 * @param[in] iconName   Icon name of the annotation.
 * @param[in] color       The icon color of the annotation. Format: 0xAARRGGBB.
 *
 * @return A pdf::PDFPage object whose content would be used as the icon.
 */
-(FSPDFPage*)getIcon: (FSAnnotType)annotType iconName: (NSString*)iconName color: (unsigned int)color;
/**
 * @brief A callback function used to get the shading colors if current icon provider supports for a specified type.
 *        Currently, only support Type-2 shading settings with two color values.
 *
 * @param[in] annotType          The annotation type. It should be one of @link FSActionCallbackMailTypeMsg @endlink,
 *                                @link FSAnnotFileAttachment @endlink and @link FSAnnotStamp @endlink.
 * @param[in] iconName           Icon name of the annotation.
 * @param[in] refColor           Referenced color. Format: 0xRRGGBB.
 * @param[in] shadingIndex       Index color of shading, starting from 0.
 *                                If shading colors are more than one, this function will be called multiple times.
 * @param[out] out_shading_color  The two shading color value, returned by this function.
 *
 * @return <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(FSShadingColor*)getShadingColor: (FSAnnotType)annotType iconName: (NSString*)iconName refColor: (unsigned int)refColor shadingIndex: (int)shadingIndex ShadingColor:(FSShadingColor*)out_shading_color;
/**
 * @brief A callback function used to get the width for display of a specified icon, in device size(pixel normally).
 *
 * @details This can be triggered during rendering process only
 *          when function @link FSRenderer::setTransformAnnotIcon: @endlink
 *          is called with value <b>NO</b> before rendering.
 *
 * @param[in] annotType  The annotation type. It should be one of @link FSActionCallbackMailTypeMsg @endlink,
 *                        @link FSAnnotFileAttachment @endlink and @link FSAnnotStamp @endlink.
 * @param[in] iconName   Icon name of the annotation.
 *
 * @return The width for display.
 */
-(NSNumber*)getDisplayWidth: (FSAnnotType)annotType iconName: (NSString*)iconName;
/**
 * @brief A callback function used to get the height for display of a specified icon, in device size(pixel normally).
 *
 * @details This can be triggered during rendering process only
 *          when function @link FSRenderer::setTransformAnnotIcon: @endlink
 *          is called with value <b>NO</b> before rendering.
 *
 * @param[in] annotType  The annotation type. It should be one of @link FSActionCallbackMailTypeMsg @endlink,
 *                        @link FSAnnotFileAttachment @endlink and @link FSAnnotStamp @endlink.
 * @param[in] iconName   Icon name of the annotation.
 *
 * @return The height for display.
 */
-(NSNumber*)getDisplayHeight: (FSAnnotType)annotType iconName: (NSString*)iconName;
@end

/**
 * This class represents a callback object to notify the Foxit PDF SDK events.
 * All the pure virtual functions in this class are used as callback functions and should be implemented by user.
 * An implemented NotifierCallback object can be set to Foxit PDF SDK by function @link FSLibrary::setNotifierCallback: @endlink.
 *
 * @see @link FSLibrary @endlink  
 */
@protocol FSNotifierCallback <NSObject>
@required
/**
 * @brief A callback function used to notify application when Foxit PDF SDK runs out of memory.
 *
 * @details When this callback function is triggered, that means Foxit PDF SDK runs out of memory.
 *          At this moment, application cannot use any API in Foxit PDF SDK.
 *          In this case, application can exit with some warning information,
 *          or application is aborted and tried to restart.
 *          Here, "restart an application" does not mean to call function @link FSLibrary::reinitialize @endlink
 *          but to call function @link FSLibrary::initialize:key: @endlink again to load Foxit PDF SDK again from the beginning.
 *
 * @return None.
 */
-(void)onOutOfMemory;
@end

/**
 * This class represents a callback object used to listen PDF document event.
 * All the pure virtual functions in this class are used as callback functions and should be implemented by user
 * in derived class. User can also re-write the virtual functions in this class in custom way.
 */
@protocol FSDocEventCallback <NSObject>
@required
/**
 * @brief Triggered when the document will be opened.
 *
 * @return None.
 */
-(void)onDocWillOpen;
/**
 * @brief Triggered when a PDF document is opened.
 *
 * @param[in] document    A PDF document object which is opened.
 * @param[in] error_code  Error code which represents the error state when opening the PDF document.
 *                        Please refer to values starting from @link FSErrSuccess @endlink and 
 *                        this would be one of these values.
 *
 * @return None.
 */
-(void)onDocOpened:(FSPDFDoc*)document error_code:(FSErrorCode)error_code;
/**
 * @brief Triggered when a PDF document will be destroyed.
 *
 * @param[in] document  A PDF document object which will be destroyed.
 *
 * @return None.
 */
-(void)onDocWillDestroy:(FSPDFDoc*)document;
/**
 * @brief Triggered when a PDF document will be saved.
 *
 * @param[in] document  A PDF document object which will be saved.
 *
 * @return None.
 */
-(void)onDocWillSave:(FSPDFDoc*)document;
/**
 * @brief Triggered when a PDF document is saved.
 *
 * @param[in] document    A PDF document object which is saved.
 * @param[in] error_code  Error code which represents the error state when saving the PDF document.
 *                        Please refer to values starting from @link FSErrSuccess @endlink and 
 *                        this would be one of these values.
 *
 * @return None.
 */
-(void)onDocSaved:(FSPDFDoc*)document error_code:(FSErrorCode)error_code;
@end

/**
 * This class represents a callback object to do file reading asynchronously.
 * This class is derived from class @link FSFileReaderCallback @endlink. All the pure virtual functions in this class
 * and its base class are used as callback functions and should be implemented by user, in order to
 * asynchronously read file data (especially used for loading document), in a customized way.
 *
 * @see @link FSFileReaderCallback @endlink
 */
@protocol FSAsyncReaderCallback <FSFileReaderCallback>
@required
/**
 * @brief A callback function used to check whether the specified data section is available or not.
 *
 * @details A data section is available only if all bytes in the section are available.
 *
 * @param[in] offset  The offset in file.
 * @param[in] size    The size of the data section, which is to be checked if available.
 *
 * @return <b>YES</b> means the specified data section is available,
 *         while <b>NO</b> means the specified data section is not available yet.
 */
-(BOOL)isDataAvail:(int)offset size:(int)size;
/**
 * @brief A callback function used to add offset and size to specify a data section,
 *        which should be downloaded by application then.
 *
 * @details Foxit PDF SDK would call this callback function to report downloading hints for
 *          the download manager of application.<br>
 *          The position (as offset) and size of the section may not be accurate because part of the section might
 *          already be available. The download manager must manage this to maximize download efficiency.
 *
 * @param[in] offset  The offset of a data section, which is to be hinted.
 * @param[in] size    The size of the data section.
 *
 * @return <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)addDownloadHint:(int)offset size:(int)size;
@end

/**
 * This class represents a callback object to assist form filler.
 * All the pure virtual functions in this class are used as callback functions and should be implemented by user.
 */
@protocol FSFillerAssistCallback <NSObject>
@required
/**
 * @brief A callback function used to refresh the specified area on a specified page.
 *
 * @param[in] page  A PDF page object.
 * @param[in] rect  A rectangle that specifies the area on the page to be redrawn.
 *                  <b>nil</b> means to refresh the whole page.
 *
 * @return None.
 */
-(void)refresh:(FSPDFPage*)page rect:(FSRectF*)rect;
/**
 * @brief A callback function used to set a system timer.
 *
 * @details This callback function is called to install a system timer. When a time-out value is specified,
 *          and every time when a time-out occurs, the system passes a message to the timer callback function.
 *
 * @param[in] elapse         Specifies the time-out value, in milliseconds.
 * @param[in] timer          Pointer to a timer callback object as timer.
 * @param[out] out_timer_id  Output parameter that receives the timer identifier of the new timer if the function is
 *                           finished successfully. This value would be passed to callback function
 *                           @link FSFillerAssistCallback::killTimer: @endlink to kill the timer.
 *                           Nonzero if the function is successful; otherwise, this should be zero.
 *
 * @return <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setTimer:(int)elapse timer:(FSTimer*)timer out_timer_id:(int*)out_timer_id;
/**
 * @brief A callback function used to kill the timer event by timer identifier.
 *
 * @param[in] timer_id  The timer identifier returned by an earlier calling of
 *                      callback function @link FSFillerAssistCallback::setTimer:timer:out_timer_id: @endlink.
 *
 * @return <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)killTimer:(int)timer_id;
/**
 * @brief A callback function which is triggered when the focus is set to a form control.
 *
 * @details Currently, only support text field and combobox field.
 *
 * @param[in] control  The form control object to which the focus is set.
 * @param[in] value    The value of form field associated with the control.
 *
 * @return None.
 */
-(void)focusGotOnControl:(FSControl*)control value:(NSString*)value;
/**
 * @brief A callback function which is triggered when the focus is lost from a form control.
 *
 * @details Currently, only support text field and combobox field.
 *
 * @param[in] control  The form control object, from which the focus is lost.
 * @param[in] value    The value of form field associated with the control.
 *
 * @return None.
 */
-(void)focusLostFromControl:(FSControl*)control value:(NSString*)value;

/**
 * @brief A callback function which is triggered when user entered an invalid value.
 *
 * @details This callback function supports text field, combo box field.
 *
 * @param[in] form_field_name The name of form field associated with the control.
 * @param[in] invalid_value The invalid value of form field associated with the control.
 *
 * @return None.
 */
- (void)reportInvalidValue:(NSString *)form_field_name invalid_value:(NSString *)invalid_value;
@optional

/**
 * @brief A callback function which is triggered when need to create a popup menu.
 *
 * @details This callback function supports text field, combo box field.
 *
 * @return Popup menu handle.
 */
- (void *)createPopupMenu;

/**
 * @brief A callback function which is triggered when need to append popup menu item to popup menu.
 *
 * @details This callback function supports text field, combo box field.
 *
 * @param[in] h_popup_menu           The popup menu handle.
 * @param[in] popup_menu_item  The popup menu item id.Please refer to values starting from @link PopupMenuItem::e_PopupMenuItemNone @endlink and
 *                             this should be one of these values.
 * @param[in] default_string   The default popup menu item string.
 *
 * @return <b>true</b> means success, while <b>false</b> means failure.
 */
- (BOOL)appendPopupMenuItem:(void *)h_popup_menu popupMenuItem:(FSFillerAssistCallbackPopupMenuItem)popupMenuItem default_string:(NSString *)default_string;

/**
* @brief A callback function which is triggered when need to enable popup menu item for popup menu.
*
* @details This callback function supports text field, combo box field.
*
* @param[in] h_popup_menu     The popup menu handle.
* @param[in] popup_menu_item  The popup menu item id.Please refer to values starting from @link PopupMenuItem::e_PopupMenuItemNone @endlink and
*                             this should be one of these values.
* @param[in] is_enabled       Whether to enable menu item or disable.
*
* @return <b>true</b> means success, while <b>false</b> means failure.
*/
- (BOOL)enablePopupMenuItem:(void *)h_popup_menu popupMenuItem:(FSFillerAssistCallbackPopupMenuItem)popupMenuItem is_enabled:(BOOL)is_enabled;

/**
* @brief A callback function which is triggered when need to show popup menu.
*
* @details This callback function supports text field, combo box field.
*
* @param[in] h_popup_menu     The menu handle.
* @param[in] point      Left-top point for popup menu, in [PDF coordinate system] (@ref pdf::PDFPage).
*
* @return <b>true</b> means success, while <b>false</b> means failure.
*/
- (BOOL)showPopupMenu:(void *)h_popup_menu point:(FSPointF *)point;

/**
* @brief A callback function which is triggered when need to destroy popup menu.
*
* @details This callback function supports text field, combo box field.
*
* @param[in] h_popup_menu The menu handle.
*
* @return None.
*/
- (void)destroyPopupMenu:(void *)h_popup_menu;

/**
* @brief A callback function which is triggered when need to set clipboard text.
*
* @details This callback function supports text field, combo box field.
*
* @param[in] text The text need to be set to clipboard.
*
* @return None.
*/
- (void)setClipboardText:(NSString *)text;

/**
* @brief A callback function which is triggered when need to get the text on clipboard.
*
* @details This callback function supports text field, combo box field.
*
* @return The text on clipboard.
*/
- (NSString *)getClipboardText;
@end

/**
 * This class represents a callback object to retrieve the searching result during the searching progress by function
 * @link FSFullTextSearch::searchOf:rank_mode:callback: @endlink.
 * All the pure virtual functions in this class are used as callback functions and should be implemented by user.
 *
 * @see @link FSFullTextSearch @endlink
 */
@protocol FSSearchCallback <NSObject>
@required
/**
 * @brief A callback function used to retrieve the searching result.
 *
 * @param[in] file_path               A file path that specifies in which file the matched result is found.
 * @param[in] page_index              A page index that specifies in which page of the file
 *                                    the matched result is found.
 * @param[in] match_result            A string that represents the matched result.
 * @param[in] match_start_text_index  The index of start character in the matched result.
 * @param[in] match_end_text_index    The index of end character in the matched result.
 *
 * @return If non-zero is returned, the search engine will stop searching.
 */
-(int)retrieveSearchResult:(NSString*)file_path page_index:(int)page_index match_result:(NSString*)match_result match_start_text_index:(int)match_start_text_index match_end_text_index:(int)match_end_text_index;
@end

/**
 * This class represents a callback object which can be used to cancel a searching process.
 * All the pure virtual functions in this class are used as callback functions and should be implemented by user.
 */
@protocol FSSearchCancelCallback <NSObject>
@required
/**
 * @brief A callback function used to check whether to cancel the searching process or not.
 *
 * @return <b>YES</b> means the searching process needs to be canceled, while <b>NO</b> means
 *         the searching process does not need to be canceled.
 */
-(BOOL)needToCancelNow;
@end

/**
 * This class represents a callback object for refreshing a region for PSI.
 * All the pure virtual functions in this class are used as callback functions and should be implemented by user.
 * An implemented PSICallback object can be set to a PSI object by function @link FSPSI::setCallback: @endlink.
 */
@protocol FSPSICallback <NSObject>
@required
/**
 * @brief A callback function used to refresh a specified region for PSI.
 *
 * @param[in] psi   A PSI object.
 * @param[in] rect  Rectangle of the refresh region.
 *
 * @return None.
 */
-(void)refresh:(FSPSI*)psi rect:(FSRectF*)rect;
@end

/**
 * This is just the base class for other concrete security callback object. User should not inherit this class directly
 * when implementing a security callback for any type of decryption and encryption. User should inherit
 * any derived callback class of this base class.
 */
@protocol FSSecurityCallback <NSObject>
@required
/**
 * @brief Get the encryption type of security callback.
 *
 * @return The encryption type. If current SecurityCallback object does not represent any specified type of
 *         security callback, it would return @link FSPDFDocEncryptUnknown @endlink.
 */
-(FSPDFDocEncryptType)GetSecurityType;
@end

/**
 * This class represents a callback object for certificate decryption. If user wants to use their own
 * certificate security callback, user should inherit this callback class and implement the pure virtual functions
 * (as callback functions), and then register their own certificate security callback object to Foxit PDF SDK
 * by function @link FSLibrary::registerSecurityCallback:callback: @endlink with <i>filter</i> "Adobe.PubSec".
 * Function @link FSLibrary::unregisterSecurityCallback: @endlink can be called to unregister the security
 * callback object with the registered filter name.
 */
@protocol FSCertificateSecurityCallback <FSSecurityCallback>
@required
/**
 * @brief A callback function used to get the key for decrypting certificate protected PDF document.
 *
 * @param[in] envelope_buffer  A buffer which represents a certificate envelope.
 *
 * @note User should implement this callback function.
 *
 * @return The decryption key.
 */
-(NSData*)getDecryptionKey:(NSData*)envelope_buffer;
@end

/**
 * This class represents a callback object for Foxit DRM decryption. If user wants to use
 * their own Foxit DRM security callback, user should inherit this callback class and implement
 * the pure virtual functions (as callback functions), and then register their own Foxit DRM security callback object
 * to Foxit PDF SDK by function @link FSLibrary::registerSecurityCallback:callback: @endlink with <i>filter</i> "FoxitDRM".
 * Function @link FSLibrary::unregisterSecurityCallback: @endlink can be called to unregister the security callback object
 * with the registered filter name.
 */
@protocol FSDRMSecurityCallback <FSSecurityCallback>
@required
/**
 * @brief A callback function used to check if current user is the owner of the PDF document.
 *
 * @param[in] document    A PDF document object.
 * @param[in] sub_filter  The sub filter of the PDF document.
 *
 * @note User should implement this callback function.
 *
 * @return <b>YES</b> means current user is the owner of the PDF document, while <b>NO</b> means not.
 */
-(BOOL)isOwner: (FSPDFDoc *)document subFilter:(NSString*)sub_filter;
/**
 * @brief A callback function used to get the current user permissions.
 *
 * @param[in] document    A PDF document object.
 * @param[in] sub_filter  The sub filter of the PDF document.
 *
 * @note User should implement this callback function.
 *
 * @return Current user permissions. Please refer to values starting from @link FSPDFDocPermPrint @endlink and
 *         this can be one or combination of these values.
 */
-(int)getUserPermissions:(FSPDFDoc*)document subFilter:(NSString*)sub_filter;
/**
 * @brief A callback function used to get the cipher type for encryption algorithm.
 *
 * @param[in] document    A PDF document object.
 * @param[in] sub_filter  The sub filter of the PDF document.
 *
 * @note User should implement this callback function.
 *
 * @return The cipher type. Please refer to values starting from @link FSSecurityHandlerCipherNone @endlink and
 *         this should be one of these values.
 */
-(FSSecurityHandlerCipherType)getCipherType:(FSPDFDoc*)document subFilter:(NSString*)sub_filter;
/**
 * @brief A callback function used to get the length of cipher key.
 *
 * @param[in] document    A PDF document object.
 * @param[in] sub_filter  The sub filter of the PDF document.
 *
 * @note User should implement this callback function.
 *
 * @return The key length. <br>
 *         For @link FSSecurityHandlerCipherRC4 @endlink cipher, this value should
 *         be between 5 and 16.<br>
 *         For @link FSSecurityHandlerCipherAES @endlink cipher, this value should be 16 or 32.
 */
-(int)getKeyLength:(FSPDFDoc*)document subFilter:(NSString*)sub_filter;
/**
 * @brief A callback function used to get the file identity string.
 *
 * @param[in] document    A PDF document object.
 * @param[in] sub_filter  The sub filter of the PDF document.
 *
 * @note User should implement this callback function.
 *
 * @return The identity string, used to identify the file.
 */
-(NSString*)getFileID:(FSPDFDoc*)document subFilter:(NSString*)sub_filter;
/**
 * @brief A callback function used to get the initial key to decrypt the DRM protected document.
 *
 * @param[in] document    A PDF document object.
 * @param[in] sub_filter  The sub filter of the PDF document.
 *
 * @note User should implement this callback function.
 *
 * @return The initial key.
 */
-(NSData*)getInitialKey:(FSPDFDoc*)document subFilter:(NSString*)sub_filter;
@end

/**
 * This class represents a callback object for custom decryption and encryption. If user wants to use
 * custom security callback, user should inherit this callback class and implement the pure virtual functions
 * (as callback functions), and then register the custom security callback object to Foxit PDF SDK by function
 * @link FSLibrary::registerSecurityCallback:callback: @endlink with with any custom filter name (following the PDF name
 * conventions). Function @link FSLibrary::unregisterSecurityCallback: @endlink can be called to unregister the
 * security callback object with the registered filter name.
 */
@protocol FSCustomSecurityCallback <FSSecurityCallback>
@required
/**
 * @brief A callback function used to create context for encryption and decryption.
 *
 * @param[in] filter        The encryption filter of the PDF document.
 * @param[in] subFilter    The sub filter of the PDF document.
 * @param[in] encryptInfo  The encryption information of the PDF document.
 *
 * @note User should implement this callback function.
 *
 * @return The encryption context.
 */
-(void *)createContext: (NSString*)filter subFilter: (NSString*)subFilter encryptInfo: (NSString*)encryptInfo;
/**
 * @brief A callback function used to release the context for encryption and decryption.
 *
 * @param[in] context  The context for encryption and decryption, returned by callback function
 *                     @link FSCustomSecurityCallback::createContext:sub_filter:encrypt_info: @endlink.
 *
 * @note User should implement this callback function.
 *
 * @return <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)releaseContext: (void *)context;
/**
 * @brief A callback function used to get the user permissions.
 *
 * @param[in] context          The context for encryption and decryption, returned by callback function
 *                             @link FSCustomSecurityCallback::createContext:sub_filter:encrypt_info: @endlink.
 * @param[in] userPermission  Original permission settings of the document. Please refer to values starting from
 *                             @link FSPDFDocPermPrint @endlink and this would be one or combination of these values.
 *
 * @note User should implement this callback function.
 *
 * @return The new user permissions. Please refer to values starting from @link FSPDFDocPermPrint @endlink and
 *         this should be one or combination of these values.
 */
-(FSPDFDocUserPermissions)getUserPermissions: (void *)context userPermission: (FSPDFDocUserPermissions)userPermission;
/**
 * @brief A callback function used to check if current user is the owner of the PDF document.
 *
 * @param[in] context  The context for encryption and decryption, returned by callback function
 *                     @link FSCustomSecurityCallback::createContext:sub_filter:encrypt_info: @endlink.
 *
 * @note User should implement this callback function.
 *
 * @return <b>YES</b> means current user is the owner, and <b>NO</b> means current user is not the owner.
 */
-(BOOL)isOwner: (void *)context;
/**
 * @brief A callback function used to get the cipher type.
 *
 * @param[in] context  The context for encryption and decryption, returned by callback function
 *                     @link FSCustomSecurityCallback::createContext:sub_filter:encrypt_info: @endlink.
 *
 * @note User should implement this callback function.
 *
 * @return The cipher type. Please refer to values starting from @link FSSecurityHandlerCipherNone @endlink and
 *         this should be one of these values.
 */
-(FSSecurityHandlerCipherType)getCipher: (void *)context;
/**
 * @brief A callback function used to get the encryption key.
 *
 * @param[in] context  The context for encryption and decryption, returned by callback function
 *                     @link FSCustomSecurityCallback::createContext:sub_filter:encrypt_info: @endlink.
 *
 * @note User should implement this callback function.
 *
 * @return The encryption key.
 */
-(NSData *)getEncryptKey: (void *)context;
/**
 * @brief A callback function used to get the estimated decrypted data size.
 *
 * @param[in] context        The context for encryption and decryption, returned by callback function
 *                           @link FSCustomSecurityCallback::createContext:sub_filter:encrypt_info: @endlink.
 * @param[in] srcDataSize  Size of source data which is to be decrypted.
 *
 * @note User should implement this callback function.
 *
 * @return The estimated decrypted data size.
 */
-(unsigned int)getDecryptedSize: (void *)context srcDataSize: (unsigned int)srcDataSize;
/**
 * @brief A callback function used to start a decryption.
 *
 * @param[in] context  The context for encryption and decryption, returned by callback function
 *                     @link FSCustomSecurityCallback::createContext:sub_filter:encrypt_info: @endlink.
 * @param[in] objNum  The object number for a PDF object.
 * @param[in] genNum  The generation number for a PDF object.
 *
 * @note User should implement this callback function.
 *
 * @return A decryptor implemented and created by user.
 */
-(void *)startDecryptor: (void *)context objNum: (int)objNum genNum: (int)genNum;
/**
 * @brief A callback function used to decrypt the encrypted data.
 *
 * @param[in] decryptor           The decryptor implemented and created by user, returned by callback function
 *                                @link FSCustomSecurityCallback::startDecryptor:obj_num:gen_num: @endlink.
 * @param[in] encryptedData      The buffer which stores the encrypted data.
 * @param[in] encryptedDataLen  The length of encrypted data, in bytes.
 *
 * @note User should implement this callback function.
 *
 * @return The decrypted data content.
 */
-(NSData*)decryptData: (void *)decryptor encryptedData: (void *)encryptedData encryptedDataLen: (unsigned int)encryptedDataLen;
/**
 * @brief A callback function used to finish the decryption.
 *
 * @param[in] decryptor  The decryptor implemented and created by user, returned by callback function
 *                       @link FSCustomSecurityCallback::startDecryptor:obj_num:gen_num: @endlink.
 *
 * @note User should implement this callback function.
 *
 * @return The decrypted data content.
 */
-(NSData *)finishDecryptor: (void *)decryptor;
/**
 * @brief A callback function used to get the estimated encrypted size.
 *
 * @param[in] context       The context for encryption and decryption, returned by callback function
 *                          @link FSCustomSecurityCallback::createContext:sub_filter:encrypt_info: @endlink.
 * @param[in] objNum       The object number for a PDF object.
 * @param[in] genNum       The generation number for a PDF object.
 * @param[in] srcData      The buffer which stores the plain text to be encrypted.
 * @param[in] srcDataLen  The length of the buffer.
 *
 * @note User should implement this callback function.
 *
 * @return The estimated encrypted size.
 */
-(unsigned int)getEncryptedSize: (void *)context objNum: (int)objNum genNum: (int)genNum srcData: (void *)srcData srcDataLen: (unsigned int)srcDataLen;
/**
 * @brief A callback function used to get encrypted data.
 *
 * @param[in] context              The context for encryption and decryption, returned by callback function
 *                                 @link FSCustomSecurityCallback::createContext:sub_filter:encrypt_info: @endlink.
 * @param[in] objNum              The object number for a PDF object.
 * @param[in] genNum              The generation number for a PDF object.
 * @param[in] srcData             The buffer which stores the plain text to be encrypted.
 * @param[in] srcDataLen         The length of the buffer.
 * @param[out] dstBuffer      Output parameter used to receives the encrypted content.
 * @param[out] dstBufferLen  Output parameter used to received the length of the encrypted data.
 *
 * @note User should implement this callback function.
 *
 * @return <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)encryptData: (void *)context objNum: (int)objNum genNum: (int)genNum srcData: (void *)srcData srcDataLen: (unsigned int)srcDataLen dstBuffer: (void *)dstBuffer dstBufferLen: (unsigned int*)dstBufferLen;

/**
 * @brief A callback function to check if to use stanard crypto method or custom crypto method.
 *
 * @param[in] context  The context for encryption and decryption, returned by callback function
 *                     @link CustomSecurityCallback::CreateContext @endlink.
 *
 * @return <ul>
 *         <li><b>true</b> means to use standard crypto method. In this case, callback functions
 *             @link CustomSecurityCallback::GetDecryptedSize @endlink, @link CustomSecurityCallback::StartDecryptor @endlink,
 *             @link CustomSecurityCallback::DecryptData @endlink, @link CustomSecurityCallback::FinishDecryptor @endlink,
 *             @link CustomSecurityCallback::GetEncryptedSize @endlink, and @link CustomSecurityCallback::EncryptData @endlink will be uselss
 *             and user can just use empy implementation for them.</li>
 *         <li><b>false</b> means use custom crypto method. In this case, please ensure callback functions mentioned above have all been implemented.</li>
 *         </ul>
 */
-(BOOL)useStandardCryptoMethod: (void *)context;
@end

/**
 * This class represents a callback object for RMS decryption and encryption. If user wants to use
 * RMS security callback, user should inherit this callback class and implement the pure virtual functions
 * (as callback functions), and then register the RMS security callback object to Foxit PDF SDK by function
 * @link FSLibrary::registerSecurityCallback:callback: @endlink with <i>filter</i> "MicrosoftIRMServices".
 * Function @link FSLibrary::unregisterSecurityCallback: @endlink can be called to unregister the security
 * callback object with the registered filter name.
 */
@protocol FSRMSSecurityCallback <FSCustomSecurityCallback>

@end

/**
 * This class represent a callback object to sign or verify signature.
 * All the pure virtual functions in this class are used as callback functions and should be implemented by user,
 * in order to sign or verify signature in a customized way.<br>
 * User can set register customized signature callback object to Foxit PDF SDK by function
 * @link FSLibrary::registerSignatureCallback:sub_filter:signature_callback: @endlink  with filter and sub filter as the callback name.
 *
 * @see @link FSLibrary @endlink
 */
@protocol FSSignatureCallback <NSObject>
@required
/**
 * @brief A callback function used to start a custom digest calculation, mainly to initialize the calculation process.
 *
 * @param[in] file              When signing a signature, this represents the source file object to be signed.<br>
 *                              When verifying a signature field, this represents the source file object
 *                              to be verified.
 * @param[in] byteRangeArray  A byte range array of the signed document(not the source document).<br>
 *                              Elements in this array always be in pairs of offset-size values in order of:
 *                              offset,size,offset,size...
 * @param[in] signature         A signature object.
 * @param[in] clientData       Pointer to a user-defined object, which is passed by user from function
 *                              @link FSSignature::startSign:cert_password:digest_algorithm:save_path:client_data:pause: @endlink or
 *                              @link FSSignature::startVerify:pause: @endlink.
 * @return <b>YES</b> means the calculation process is successfully started and then
 *         @link FSSignatureCallback::continueCalcDigest:client_data: @endlink will be triggered to continue the calculation process.
 *         <b>NO</b> means fail to start a calculation process.
 */
-(BOOL)startCalcDigest: (id<FSFileReaderCallback>)file byteRangeArray: (NSArray<NSNumber *> *)byteRangeArray signature: (FSSignature*)signature clientData: (void* )clientData;
/**
 * @brief A callback function used to continue the custom digest calculation process.
 *
 * @param[in] pause        Pause object which decides if the calculation process needs to be paused.
 *                         If this is <b>NULL</b>, it means not to pause during the calculation process.
 *                         If this is not <b>NULL</b>, please check the returned value of
 *                         function <b>PauseCallback::NeedToPauseNow</b> and decide when to pause
 *                         the calculation process.
 * @param[in] clientData  Pointer to a user-defined object, which is passed by user from function
 *                         @link FSSignature::startSign:cert_password:digest_algorithm:save_path:client_data:pause: @endlink or
 *                         @link FSSignature::startVerify:pause: @endlink.
 *
 * @return @link FSProgressiveFinished @endlink means the rendering is finished
 *         successfully.<br>
 *         @link FSProgressiveToBeContinued @endlink means the calculation
 *         process is not finished yet and callback function @link FSSignatureCallback::continueCalcDigest:client_data: @endlink
 *         would be triggered again to continue the process.<br>
 *         @link FSProgressiveError @endlink means any error occurs.
 */
-(FSProgressiveState)continueCalcDigest: (id<FSPauseCallback> )pause clientData: (void* )clientData;
/**
 * @brief A callback function used to get the digest after the calculation process is finished.
 *
 * @details This callback function will be triggered when the calculation process is finished successfully.
 *
 * @param[in] clientData  Pointer to a user-defined object, which is passed by user from function
 *                         @link FSSignature::startSign:cert_password:digest_algorithm:save_path:client_data:pause: @endlink or @link FSSignature::startVerify:pause: @endlink.
 *
 * @return The digest string.
 *         If there is any error, please return an empty string.
 */
-(NSData *)getDigest: (void* )clientData;
/**
 * @brief A callback function used to do signing and return the signed data.
 *
 * @details Host application provides this callback function for custom sign mechanism.
 *          This callback function would be triggered during the signature signing process.
 *
 * @param[in] digest            The digest data buffer, for source file buffer to be signed.
 * @param[in] certPath         The certificate file path, which will be used for signing.
 * @param[in] certPassword     The password string, used to open the cert file. If this is an empty string,
 *                              that means no password is required.
 * @param[in] digestAlgorithm  The algorithm of message digest for signed data. Please refer to values
 *                              starting from @link FSSignatureDigestSHA1 @endlink and this would be one of these values.
 * @param[in] clientData       Pointer to a user-defined object, which is passed by user from function
 *                              @link FSSignature::startSign:cert_password:digest_algorithm:save_path:client_data:pause: @endlink or @link FSSignature::startVerify:pause: @endlink.
 *
 * @return Signed data. If there is any error, please return an empty string.<br>
 *         The length of returned signed data should be within the default length of signature contents
 *         which is 7942 by default or specified by fucntion @link FSSignature::setDefaultContentsLength: @endlink
 *         before signing the unsigned signature.
 */
-(NSData *)sign: (NSData*)digest certPath: (NSString* )certPath certPassword: (NSString* )certPassword digestAlgorithm: (FSSignatureDigestAlgorithm)digestAlgorithm clientData: (void* )clientData;
/**
  * @brief A callback function used to do signing and return the signed data.
  *
  * @details Host application provides this callback function for custom sign mechanism.
  *          This callback function would be triggered during the signature signing process.
  *
  * @param[in] digest            The digest data buffer, for source file buffer to be signed.
  * @param[in] cert_file_stream  The certificate file stream, which will be used for signing.
  * @param[in] cert_password     The password string, used to open the cert file. If this is an empty string,
  *                              that means no password is required.
  * @param[in] digest_algorithm  The algorithm of message digest for signed data. Please refer to values
  *                              starting from @link Signature::e_DigestSHA1 @endlink and this would be one of these values.
  * @param[in] client_data       A user-defined object, which is passed by user from function
  *                              @link Signature::StartSign @endlink or @link Signature::StartVerify @endlink.
  *
  * @return Signed data. If there is any error, please return an empty string.<br>
  *         The length of returned signed data should be within the default length of signature contents
  *         which is 7942 by default or specified by fucntion @link Signature::SetDefaultContentsLength @endlink
  *         before signing the unsigned signature.
  */

-(NSData *)sign: (NSData*)digest certStream:(id<FSStreamCallback>)certStream certPassword: (NSString* )certPassword digestAlgorithm: (FSSignatureDigestAlgorithm)digestAlgorithm clientData: (void* )clientData;/**
 * @brief A callback function used to do verifying and return the verify state.
 *
 * @details Host application provides this callback function for custom sign mechanism.
 *          This callback function would be triggered during the signature verifying process.
 *
 * @param[in] digest           The digest data buffer, for source file buffer to be verified.
 * @param[in] signedData      The signed data buffer.
 * @param[in] clientData      Pointer to a user-defined object, which is passed by user from function
 *                             @link FSSignature::startSign:cert_password:digest_algorithm:save_path:client_data:pause: @endlink or @link FSSignature::startVerify:pause: @endlink.
 *
 * @return Verify state. Please refer to values starting from @link FSSignatureStateVerifyValid @endlink and
 *         this should be one or a combination of them.
 */
-(FSSignatureStates)verifySigState: (NSData*)digest signedData: (NSData*)signedData clientData: (void* )clientData;
/**
 * @brief Whether return all contents all hex string include padding zero when call Verify function.
 *
 * @return TRUE means return all data in contents steam. FALSE return contents data doesn't include zero in stream end.
 */
-(BOOL)isNeedPadData;
/**
 * @brief A callback function used to check the validity of a certificate.
 *
 * @details This callback function will be triggered when function @link Signature::StartSign @endlink is called.
 *          If no need to check the certificate, value @link SignatureCallback::e_CertValid @endlink can
 *          be returned directly.
 *
 * @param[in] cert_path      A full path of a PFX certificate file (including file name and extension),
 *                           which will be used for signing. This is passed by user from function
 *                           @link Signature::StartSign @endlink.
 * @param[in] cert_password  A password string used to open the cert file. If this is an empty string,
 *                           that means no password is required.This is passed by user from function
 *                           @link Signature::StartSign @endlink.
 * @param[in] client_data    A user-defined object, which is passed by user from function
 *                           @link Signature::StartSign @endlink.
 *
 * @return <b>true</b> means the ceritificate is valid, while <b>false</b> means invalid.
 */
-(FSSignatureCallbackCertValidity)CheckCertificateValidity:(NSString *)certPath certPassword: (NSString* )certPassword clientData: (void* )clientData;
@end

/**
 * This class represents a callback object as an XFA application provider.
 * All the functions in this class are used as callback functions. Pure virtual functions should be implemented
 * by user.
 */
@protocol FSAppProviderCallback <NSObject>
@required
/**
 * @brief A callback function used to get application information for a specified information type.
 *
 * @param[in] app_info  The type of application information, whose information is to retrieved. Please refer to
 *                      values starting from @link FSAppProviderCallbackAppInfoType @endlink and this would be
 *                      one of these values.
 *
 * @return A string of application information.
 */
-(NSString*)getAppInfo:(FSAppProviderCallbackAppInfo)app_info;
/**
 * @brief A callback function used to beep for specified beep type.
 *
 * @param[in] type  The beep type. Please refer to values starting from @link FSAppProviderCallbackBeepTypeError @endlink
 *                  and this would be one of these values.
 *
 * @return None.
 */
-(void)beep:(FSAppProviderCallbackBeepType)type;
/**
 * @brief A callback function used to set message box.
 *
 * @param[in] message      A message string.
 * @param[in] title        The title of message box. Default value: an empty string.
 *
 * @return The button ID for message box. Please refer to values starting from @link FSAppProviderCallbackMsgBtnIDOK @endlink
 *         and this should be one of these values.
 */
-(FSAppProviderCallbackMsgBoxButtonID)msgBox:(NSString*)message title:(NSString*)title;
/**
 * @brief A callback function used to response.
 *
 * @param[in] question        A string that represents the question.
 * @param[in] title           A string that represents the title.
 * @param[in] default_answer  A string that represents the default answer. It could be an empty string
 *                            which means no default answer.Default value: an empty string.
 * @param[in] is_mask         <b>YES</b> means the answer should be masked by '*',
 *                            while <b>NO</b> means the answer does not need to be masked by '*'.
 *                            Default value: <b>true</b>.
 *
 * @return A string that represents the response answer.
 */
-(NSString*)response:(NSString*)question title:(NSString*)title default_answer:(NSString*)default_answer is_mask:(BOOL)is_mask;
/**
 * @brief A callback function used to download from specified URL.
 *
 * @param[in] url  A URL to be downloaded.
 *
 * @return Pointer to a ReaderCallback object which can be used to read the downloading result.
 */
-(id<FSFileReaderCallback>)downLoadUrl:(NSString*)url;
/**
 * @brief A callback function used to post data to the given url.
 *
 * @param[in] url           A URL, to which the data will be posted.
 * @param[in] data          The data to be posted.
 * @param[in] content_type  A string that represents the content type of data. This string could be "text/html",
 *                          "text/xml", "text/plain", "multipart/form-data", "application/x-www-form-urlencoded",
 *                          "application/octet-stream", or any valid MIME type.
 * @param[in] encode        A string that represents the encoding of data. This string could be "UTF-8", "UTF-16",
 *                          "ISO8859-1", or any recognized [IANA]character encoding.
 * @param[in] header        A string that represents any additional HTTP headers to be included in the post.
 *
 * @return The response string.
 */
-(NSString*)postRequestURL:(NSString*)url data:(NSString*)data content_type:(NSString*)content_type encode:(NSString*)encode header:(NSString*)header;
/**
 * @brief A callback function used to put data to the given url.
 *
 * @param[in] url     A URL, to which the data will be put.
 * @param[in] data    The data to be put.
 * @param[in] encode  A string that represents the encoding of data. This string could be "UTF-8", "UTF-16",
 *                    ISO8859-1", or any recognized [IANA]character encoding.
 *
 * @return <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)putRequestURL:(NSString*)url data:(NSString*)data encode:(NSString*)encode;
/**
 * @brief A callback function used to load a string in local language for a specified case.
 *
 * @details This function is very useful for user to use local language for message of specified cases.
 *          User can re-write or translate the sample message (which is defined in the comment of
 *          values starting from @link FSAppProviderCallbackStringIDValidateFailed @endlink)
 *          into local language for the specified case, and return the result string to Foxit PDF SDK.
 *          Specially, Foxit PDF SDK will add some necessary information/data to the format part in
 *          the sample message, in order to make the message more useful. User is recommended to
 *          keep these format part in the re-written or translated result string; otherwise,
 *          these information/data will not be lost and will not be added to the message offered by user.
 *
 * @param[in] string_id  A string ID to specify a case. Please refer to values starting from
 *                       @link FSAppProviderCallbackStringIDValidateFailed @endlink and this would be one of these values.
 *
 * @return A string used for the specified case.
 */
-(NSString*)loadString:(FSAppProviderCallbackStringID)string_id;
/**
 * @brief A callback function used to show file dialog.
 *
 * @param[in] string_title        A string that represents the dialog title.
 * @param[in] string_filter       A string that represents the dialog file filter.
 * @param[in] is_openfile_dialog  <b>YES</b> means the dialog is an open-file-dialog,
 *                                while <b>NO</b> means the dialog is a save-as-dialog.
 *
 * @return An array of file paths.
 */
-(NSArray<NSString*>*)showFileDialog:(NSString*)string_title string_filter:(NSString*)string_filter is_openfile_dialog:(BOOL)is_openfile_dialog;
@end

/**
 * This class represents a callback object as an XFA document provider.
 * All the functions in this class are used as callback functions. Pure virtual functions should be implemented
 * by user.
 */
@protocol FSDocProviderCallback <NSObject>
@required
/**
 * @brief A callback function used to invalidate rectangle according the flag.
 *
 * @details This callback function would be used in dynamic XFA document.
 *
 * @param[in] page_index  The index of page.
 * @param[in] rect        A rectangle to be invalidate.
 * @param[in] flag        Invalidate flag. Please refer to values starting from
 *                        @link FSDocProviderCallbackInvalidateFlagAllPages @endlink
 *                        and this would be one of these values.
 *
 * @return None.
 */
-(void)invalidateRect:(int)page_index rect:(FSRectF*)rect flag:(FSDocProviderCallbackInvalidateFlag)flag;
/**
 * @brief A callback function used to display or hide caret.
 *
 * @param[in] page_index  The index of page.
 * @param[in] is_visible  Used to decide whether the caret is visible or not: <b>YES</b> means visible,
 *                        while <b>NO</b> means invisible.
 * @param[in] rect        A recatangle.
 *
 * @return None.
 */
-(void)displayCaret:(int)page_index is_visible:(BOOL)is_visible rect:(FSRectF*)rect;
/**
 * @brief A callback function used to get the pop-up position.
 *
 * @param[in] page_index            The index of page.
 * @param[in] min_popup             The minimum height of drop-down box.
 * @param[in] max_popup             The maximum height of drop-down box.
 * @param[in] rect_widget           The rectangle of current widget.
 * @param[in,out] inout_rect_popup  A rectangle. When this function calls, this is used as an input parameter
 *                                  that speicifies the width of drop-down box.
 *                                  When this function returns, this is used as an output parameter that receives
 *                                  the height of drop-down box.
 *
 * @return <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)getPopupPos:(int)page_index min_popup:(int)min_popup max_popup:(int)max_popup rect_widget:(FSRectF*)rect_widget inout_rect_popup:(FSRectF*)inout_rect_popup;
/**
 * @brief A callback function used to pop up the context menu.
 *
 * @param[in] page_index    The index of page.
 * @param[in] rect_popup    The rectangle where to pop up menu.
 *
 * @return <b>TRUE</b> means success, otherwise means failure.
 */
-(BOOL)popupMenu:(int)page_index rect_popup:(FSPointF*)rect_popup;
/**
 * @brief A callback function used to get index of current page.
 *
 * @param[in] doc  Current XFA document.
 *
 * @return The index of current page.
 */
-(int)getCurrentPage:(FSXFADoc*) doc;
/**
 * @brief A callback function used to set index of current page.
 *
 * @param[in] doc                 Current XFA document.
 * @param[in] current_page_index  The index would be set.
 *
 * @return None.
 */
-(void)setCurrentPage:(FSXFADoc*) doc current_page_index:(int)current_page_index;
/**
 * @brief A callback function used to set change mark flag.
 *
 * @param[in] doc Current XFA document.
 *
 * @return None.
 */
-(void)setChangeMark:(FSXFADoc*) doc;
/**
 * @brief A callback function used to get title of current XFA document.
 *
 * @param[in] doc  Current XFA document.
 *
 * @return The title.
 */
-(NSString*)getTitle:(FSXFADoc*) doc;
/**
 * @brief A callback function used to set focus widget.
 *
 * @param[in] xfa_widget  An XFA widget to be set focus on.
 *
 * @return None.
 */
-(void)setFocus:(FSXFAWidget *) xfa_widget;
/**
 * @brief A callback function used to export data to file.
 *
 * @param[in] doc        Current XFA document.
 * @param[in] file_path  A file path, to which the data should be exported.
 *                       If this is an empty string, user should specify a path as the exported file path.
 *                       In this case, application can show a dialog to user to let user select the file manually.
 *
 * @return None.
 */
-(void)exportData:(FSXFADoc*)doc file_path:(NSString*) file_path;
/**
 * @brief A callback function used to import data from file.
 *
 * @param[in] doc        Current XFA document.
 * @param[in] file_path  A file path, from which the data would be imported.
 *                       If this is an empty string, user should specify a path as the imported file path.
 *                       In this case, application can show a dialog to user to let user select the file manually.
 *
 * @return None.
 */
-(void)importData:(FSXFADoc*)doc file_path:(NSString*) file_path;
/**
 * @brief A callback function used to go to a specified URL.
 *
 * @param[in] doc  Current XFA document.
 * @param[in] url  A URL string.
 *
 * @return None.
 */
-(void)gotoURL:(FSXFADoc*)doc url:(NSString*) url;
/**
 * @brief A callback function used to print.
 *
 * @param[in] doc               Current XFA document.
 * @param[in] start_page_index  The index of start page.
 * @param[in] end_page_index    The index of end page.
 * @param[in] options           Print options. Please refer to values starting from
 *                              @link FSDocProviderCallbackPrintOptionShowDialog @endlink
 *                              and this would be one or a combination of these values.
 *
 * @return None.
 */
-(void)print:(FSXFADoc*)doc start_page_index:(int)start_page_index end_page_index:(int)end_page_index options:(int)options;
/**
 * @brief A callback function get the highlight color.
 *
 * @param[in] doc  Current XFA document.
 *
 * @return The highlight color.
 */
-(int)getHighlightColor:(FSXFADoc*)doc;
/**
 * @brief A callback function to submit data.
 *
 * @param[in] doc            Current XFA document.
 * @param[in] target         A string that represents the target of data to be submit.
 * @param[in] format         The format of data to be submit. Please refer to values starting from
 *                           @link FSDocProviderCallbackSubmitInXDP @endlink and this would be one of these values.
 * @param[in] text_encoding  The text encoding of data to be submit. Please refer to values starting from
 *                           @link FSDocProviderCallbackTextEncodingNone @endlink and this would be one of these values.
 * @param[in] content        The content of data to be submit.
 *
 * @return <b>TRUE</b> means success, otherwise means failure.
 */
-(BOOL)submitData:(FSXFADoc*)doc target:(NSString*)target format:(FSDocProviderCallbackSubmitFormat)format text_encoding:(FSDocProviderCallbackTextEncoding)text_encoding content:(NSString*)content;
/**
 * @brief A callback function to execute page view event.
 *
 * @param[in] page_index            The page index.
 * @param[in] page_view_event_type  Page view event type. PPlease refer to values starting from
 *                                  @link FSDocProviderCallbackPageViewEventTypeAdded @endlink and this would be
 *                                  one of these values.
 *
 * @return None.
 */
-(void)pageViewEvent:(int)page_index page_view_event_type:(FSDocProviderCallbackPageViewEventType)page_view_event_type;
/**
 * @brief A callback function to execute xfa widget event.
 *
 * @param[in] xfa_widget  An XFA widget sended the event   .
 * @param[in] widget_event_type   widget event type. Please refer to values starting from
 *                               @link FSDocProviderCallbackWidgetEventTypeAdded @endlink and
 *                               this would be one of these values.
 *
 * @return None.
 */
-(void)widgetEvent:(FSXFAWidget *) xfa_widget widget_event_type:(FSDocProviderCallbackWidgetEventType)widget_event_type;
@end

/**
 * This class represent a revocation callback object.
 * All the pure virtual functions in this class are used as callback functions and should be implemented by user.<br>
 */
@protocol FSRevocationCallback <NSObject>
@required
/**
 * @brief A callback function used to get the cert chain for the signature content.
 *
 * @param[in] signature_content  Signature content.
 *
 * @return A string array that represents the cert chain.
 *
 * @note User can throw exception for errors. Please refere to class @link foxit::Exception @endlinlk and
 *       values starting from @link foxit::e_ErrFile @endlink.
 */
-(NSArray<NSData*>*)getCertChainFromSignature: (NSData*)signature_content;

/**
 * @brief A callback function used to get response online for a certificate.
 *
 * @param[in] cert_issuer_pair  Certificate and issuer pair.
 *
 * @return Response for the certificate.
 *
 * @note User can throw exception for errors. Please refere to class @link foxit::Exception @endlinlk and
 *       values starting from @link foxit::e_ErrFile @endlink.
 */
-(FSResponse*)getResponseOnLineForSingleCert: (FSCertIssuerPair*)cert_issuer_pair;

/**
 * @brief A callback function used to verify whether the OCSP response matches the certificate.
 *
 * @param[in] cert_issuer_pair  Certificate and issuer pair.
 * @param[in] ocsp_data  OCSP content.
 *
 * @return Certificate verify result.
 *
 * @note User can throw exception for errors. Please refere to class @link foxit::Exception @endlinlk and
 *       values starting from @link foxit::e_ErrFile @endlink.
 */
-(FSCertVerifyResult*)verifyOCSP:(FSCertIssuerPair*)cert_issuer_pair ocsp_data : (NSData*)ocsp_data;

/**
 * @brief A callback function used to verify whether the CRL response matches the certificate.
 *
 * @param[in] cert_issuer_pair  Certificate and issuer pair.
 * @param[in] crl_data  CRL content.
 *
 * @return Certificate verify result.
 *
 * @note User can throw exception for errors. Please refere to class @link foxit::Exception @endlinlk and
 *       values starting from @link foxit::e_ErrFile @endlink.
 */
-(FSCertVerifyResult*)verifyCRL:(FSCertIssuerPair*)cert_issuer_pair crl_data : (NSData*)crl_data;

/**
 * @brief A callback function used to judge whether a certificate is a CA certificate.
 *
 * @param[in] cert  A certificate.
 *
 * @return <b>true</b> means the certificate is a CA certificate, while <b>false</b> means not.
 */
-(BOOL)isCA:(NSData*)cert;

/**
 * @brief A callback function used to get the document time stamp time from signature content.
 *
 * @param[in] signature_content  Signature content.
 *
 * @return Time of document time stamp.  utc_hour_offset and utc_minite_offset are ignored.
 *
 * @note User can throw exception for errors. Please refere to class @link foxit::Exception @endlinlk and
 *       values starting from @link foxit::e_ErrFile @endlink.
 */
-(FSDateTime*)getDTSTime:(NSData*)signature_content;

/**
 * @brief A callback function used to get the time stamp token signature content form a signature content.
 *
 * @param[in] signature_content  Signature content.
 *
 * @return Signature content of the time stamp token signature.
 *
 * @note User can throw exception for errors. Please refere to class @link foxit::Exception @endlinlk and
 *       values starting from @link foxit::e_ErrFile @endlink.
 */
-(NSData*)getTSTSignature:(NSData*)signature_content;

/**
 * @brief A callback function used to get the time stamp token time from signature content.
 *
 * @param[in] signature_content  Signature content.
 *
 * @return Time of time stamp token of a signature. utc_hour_offset and utc_minite_offset are ignored.
 *
 * @note User can throw exception for errors. Please refere to class @link foxit::Exception @endlinlk and
 *       values starting from @link foxit::e_ErrFile @endlink.
 */
-(FSDateTime*)getTSTTime:(NSData*)signature_content;

/**
 * @brief A callback function used to get the cert and issuer of OCSP response.
 *
 * @param[in] ocsp_data         OCSP response data.
 * @param[in] trust_cert_chain  The trust cert chain to find the issuer of the OCSP cert.
 *
 * @return Cert-issuer pair.
 *
 * @note User can throw exception for errors. Please refere to class @link foxit::Exception @endlinlk and
 *       values starting from @link foxit::e_ErrFile @endlink.
 */
-(FSCertIssuerPair*)getOCSPCertAndIssuer:(NSData*)ocsp_data trust_cert_chain : (NSArray<NSData*>*)trust_cert_chain;

/**
 * @brief A callback function used to get the produce time of the OCSP response.
 *
 * @param[in] ocsp_data  OCSP response content.
 *
 * @return Produce time of the OCSP response. utc_hour_offset and utc_minite_offset are ignored.
 *
 * @note User can throw exception for errors. Please refere to class @link foxit::Exception @endlinlk and
 *       values starting from @link foxit::e_ErrFile @endlink.
 */
-(FSDateTime*)getOCSPProducedAtTime:(NSData*)ocsp_data;

/**
 * @brief A callback function used to get flag which decides if need to check OCSP response.
 *
 * @param[in] ocsp_data  OCSP response content.
 *
 * @return <b>true</> means need to check OCSP response, while <b>false</b> means no need.
 */
-(BOOL)isOCSPNeedCheck:(NSData*)ocsp_data;

/**
 * @brief A callback function used to get the valid time range of the certificate..
 *
 * @param[in] cert  A certificate.
 *
 * @return Valid time range of the certificate.
 *
 * @note User can throw exception for errors. Please refere to class @link foxit::Exception @endlinlk and
 *       values starting from @link foxit::e_ErrFile @endlink.
 */
-(FSTimeRange*)getCertValidTimeRange:(NSData*)cert;

/**
 * @brief A callback function used to get the signature from a OCSP response.
 *
 * @param[in] ocsp_data  OCSP response content.
 *
 * @return Signature content .
 *
 * @note User can throw exception for errors. Please refere to class @link foxit::Exception @endlinlk and
 *       values starting from @link foxit::e_ErrFile @endlink.
 */
-(NSData*)getOCSPSignature:(NSData*)ocsp_data;

/**
 * @brief A callback function used to get the signature from a CRL response.
 *
 * @param[in] crl_data  CRL response content.
 *
 * @return Signature content .
 *
 * @note User can throw exception for errors. Please refere to class @link foxit::Exception @endlinlk and
 *       values starting from @link foxit::e_ErrFile @endlink.
 */
-(NSData*)getCRLSignature:(NSData*)crl_data;

/**
 * @brief A callback function used to get the revocation information from a signature.
 *
 * @param[in] signature_content  Signature content.
 * @param[out]    OCSPVector    The OCSP response got from the signature.
 * @param[out]    CRLVector    The CRL response got from the signature.
 *
 * @return Revocation array information object.
 *
 * @note User can throw exception for errors. Please refere to class @link foxit::Exception @endlinlk and
 *       values starting from @link foxit::e_ErrFile @endlink.
 */
-(FSRevocationArrayInfo*)getRevocationInfoFromSignatureData:(NSData*)signature_content;

/**
 * @brief A callback function used to check if an issuer matches a certificate.
 *
 * @param[in] cert_issuer_pair  Certificate and issuer pair.
 *
 * @return <b>true</b> means issuer matches the certificate, while <b>false</b> means not.
 */
-(BOOL)isIssuerMatchCert:(FSCertIssuerPair*)cert_issuer_pair;

@end

/**
 * This class represent a callback object as trusted cert store.
 * All the pure virtual functions in this class are used as callback functions and should be implemented by user.<br>
 * If user wants to trust some certificate during LTV verify process, user can set a customized trusted cert store callback object
 * by function @link LTVVerifier::SetTrustedCertStoreCallback @endlink before doint LTV verifying peocess.
 *
 * @see @link pdf::LTVVerifier @endlink
 */
@protocol FSTrustedCertStoreCallback <NSObject>
@required
/**
 * @brief A callback function used to check if input certificate is trusted.
 *
 * @return <b>true</b> means input certificate is trusted, while <b>false</b> means input certificated is not trusted.
 */
-(BOOL)isCertTrusted:(NSData*)cert;

/**
 * @brief A callback function used to check if input certificate is used as a trusted root.
 *
 * @param[in] cert  Certificate content.
 *
 * @return <b>true</b> means input certificate is used as a trusted root, while <b>false</b> means input certificated is not used as a trusted root..
 */
-(BOOL)isCertTrustedRoot:(NSData*)cert;

@end

/**
 * This class represents a callback object to map font in customized way.
 * All the pure virtual functions in this class are used as callback functions and should be implemented by user.
 * An implemented @link FontMapperCallback @endlink object can be set to Foxit PDF SDK by
 * function @link Library::SetFontMapperCallback @endlink.
 *
 * @see @link Library @endlink
 */
@protocol FSFontMapperCallback <NSObject>
@required

/**
 * @brief A callback function used to map a suitable font according to input parameters.
 *
 * @param[in] font_name     Font name.
 * @param[in] is_truetype   <b>true</b> means the font is expected to be a TrueType font, while <b>false</b> means the font is expected to be a Type1 font.
 * @param[in] styles        Font styles. Please refer to values starting from @link Font::e_StyleFixedPitch @endlink and
 *                          this would be one or a combination of these values.
 * @param[in] weight        Original font weight. 0 means unspecified.
 * @param[in] italic_angle  Italic angle.
 * @param[in] charset       The charset of the font to be mapped. Please refer to values starting from
 *                          @link Font::e_CharsetANSI @endlink and this would be one of these values.
 *
 * @return Font map result object. If any member in the returned @link FontMapResult @endlink is invalid,
 *         that means no mapped font is found. Then Foxit PDF SDK will do font mapping.
 */
-(FSFontMapResult*)mapFont:(NSString*)font_name is_truetype:(BOOL)is_truetype styles:(unsigned int)styles weight:(int)weight italic_angle:(int)italic_angle charset:(FSFontCharset)charset;

@end

/**
 * This class represents a callback object which is used during summarizing annotation to allow user to decide some format/data.
 * All the pure virtual functions in this class are used as callback functions and should be implemented by user.
 * An implemented @link AnnotationSummaryCallback @endlink object can be set to a AnnotationSummary object by function
 * @link AnnotationSummary::SetCallback @endlink.
 */
@protocol FSAnnotationSummaryCallback <NSObject>
@required

  /**
   * @brief A callback function used to specify current locale ID.
   *
   * @details Locale ID is used to decide locale format for some information, such as date format.
   *
   * @return A locale ID. Please refer to values starting from @link common::e_LocaleIDUnspecified @endlink and
   *         this should be one of these values. If returned locale ID is not supported, Foxit PDF SDK will use
   *         value @link common::e_LocaleIDUnspecified @endlink by default.
   */
-(FSLocaleID) getCurrentLocaleID;

  /**
   * @brief A callback function used to specify the font name used locally.
   *
   * @details This function is very useful for user to specify the font used in result document.
   *
   * @return Font name string. If an empty string is returned, Foxit PDF SDK will use "Helvetica" as default font name.
   *         If returned font name is invalid, this name will not take any effect.
   */
-(NSString*) getLocalFontName;

  /**
   * @brief A callback function used to load a string in local language for a specified case.
   *
   * @details This function is very useful for user to use local language for some string content in result document.
   *          By using this function, user can re-write or translate default output strings to local language for specified case
   *          in result document. Default output strings for these specified cases can be found in comment for values
   *          starting from @link AnnotationSummaryCallback::e_AnnotationSummaryStringIDAuthor @endlink.<br>
   *          Specially, Foxit PDF SDK will add some necessary information/data to the format part in
   *          the result document, in order to make content in the result document more useful.
   *
   * @param[in] stringID   An annotation summary string ID to specify a summary case. Please refer to values starting
   *                    from @link AnnotationSummaryCallback::e_AnnotationSummaryStringIDAuthor @endlink and this would be
   *                    one of these values.
   *
   * @return A string used for the specified case.
   */
-(NSString*) loadString:(FSAnnotationSummaryCallbackAnnotationSummaryStringID) stringID;

@end

@protocol FSTimeStampCallback <NSObject>
@optional

/**
 * @brief A callback function used to send time stamp request.
 *
 * @param[in] request  Time stamp request to be sent. It may be an empty string.
 *
 * @return Result value of the sending request process. Please refer to values starting from
 *         @link TimeStampServer::e_SendResultSuccess @endlink and this would be one of these values.
 */
- (FSTimeStampServerSendRequestResult)sendTimeStampRequest:(NSString *)request;
/**
 * @brief A callback function used to get time stamp message.
 *
 * @return Time stamp message.It can be an empty string.
 */
- (NSString *)getTimeStampMessage;

@end

@interface FSSwiftException : NSObject

+ (BOOL)tryBlock: (void(^)(void))block error:(__autoreleasing NSError **)error;

@end



#ifdef __cplusplus
}
#endif

